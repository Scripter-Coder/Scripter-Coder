--Webhook
УУУУУУУУУУУУУУУУУУУУУУУУУУУУУУУУУУУУУУУУУУУУУУУУУУУУУУУУУУУУУУУУУУУУУУУУУУУУУУУУУУУУУУУУУУУУУУУУУУУУУУУУУУУУУУУУУУУУУУУУУУУУУУУУУУУУУУУУУУУУУУУУУУУУУУУУУУУУУУУУУУУУУУУУУУУУУУУУУУУУУУУ
local WebhookScripterHub = loadstring(game:HttpGet("https://raw.githubusercontent.com/Scripter-Coder/Scripter-Coder/refs/heads/main/Universal/Webhook"))()

--Start Of Script
local MarketplaceService = game:GetService("MarketplaceService")
local placeInfo = MarketplaceService:GetProductInfo(game.PlaceId)
local gameName = placeInfo.Name

local OrionLib = loadstring(game:HttpGet("https://raw.githubusercontent.com/Scripter-Coder/Scripter-Coder/refs/heads/main/Universal/Orion%20Hub%20Library"))()

--If SAEN Then
--Creating Window
if game.PlaceId == 14410213941 or 14667049509 then
local Window = OrionLib:MakeWindow({Name = gameName .. " Hub (Scripter Hub) OP V. 3.5.7", HidePremium = true, IntroEnabled = true, IntroText = gameName, IntroIcon = "rbxassetid://7743866529", ToggleIcon = "assetid://7734091286"})

OrionLib:MakeNotification({Name = "From Scripter",Content = "GoodLuck!",Image = "rbxassetid://7734059095",Time = 3})

Tab = Window:MakeTab({
 Name = "Welcome",
 Icon = "rbxassetid://7734059095",
 PremiumOnly = false
 })

local player = game.Players.LocalPlayer
Tab:AddLabel("Hello " .. player.Name .. "!")

Tab:AddButton({
    Name = "Bypass Anti Cheats",
    Callback = function()
workspace["#GAME"].Map._Other.MountainWedge:destroy()
workspace["#GAME"].Map._Other["Touch/TargetParts"].MountainPart:destroy()
workspace["#GAME"].Map._Other.Mountain:destroy()
game:GetService("ReplicatedStorage")["#GAME"]._Storage.Events.AntiSpeed:destroy()
workspace["#GAME"].Map._Other.BOEL:destroy()
workspace["#GAME"].Map._Other.Water:destroy()
task.wait(0.3)
                OrionLib:MakeNotification({
                    Name = "Bypassed",
                    Content = "Total Bypassed: 6 Anti Cheats",
                    Image = "rbxassetid://4483345998",
                    Time = 3
                })
    end
})

Tab:AddParagraph("Note:", [[
Use in private server if u dont wanna get caught and getting banned!
]])

Tab:AddButton({
    Name = "Check Server Type",
    Callback = function()
        local function detectServerType()
            
            -- Main method: Check PrivateServerOwner attribute
            local privateServerOwner = workspace:GetAttribute("PrivateServerOwner")
            local localPlayer = game:GetService("Players").LocalPlayer
            local localUserId = localPlayer.UserId
            
            print("PrivateServerOwner attribute:", privateServerOwner)
            print("Your UserId:", localUserId)
            
            if privateServerOwner == nil then
                return "Unknown (Attribute not found)"
                
            elseif privateServerOwner == 0 then
                return "Public Server"
                
            elseif privateServerOwner == localUserId then
                return "Private Server (You own it)"
                
            elseif privateServerOwner > 0 and privateServerOwner ~= localUserId then
                -- Optional: Try to get the owner's username
                local ownerName = "Unknown Player"
                pcall(function()
                    local playerService = game:GetService("Players")
                    ownerName = playerService:GetNameFromUserIdAsync(privateServerOwner)
                end)
                return "VIP Server (Owned by: " .. ownerName .. ")"
                
            else
                return "Unknown Server Type"
            end
        end
        
        -- Run detection
        local serverType = detectServerType()
        
        -- Create notification
        OrionLib:MakeNotification({
            Name = "Server Type",
            Content = serverType,
            Image = "rbxassetid://4483345998",
            Time = 5
        })
        
        -- Optional: Display additional info in notification if you want
        local localPlayer = game:GetService("Players").LocalPlayer
        local privateServerOwner = workspace:GetAttribute("PrivateServerOwner")
        
        if privateServerOwner and privateServerOwner > 0 and privateServerOwner ~= localPlayer.UserId then
            pcall(function()
                local ownerName = game:GetService("Players"):GetNameFromUserIdAsync(privateServerOwner)
                OrionLib:MakeNotification({
                    Name = "Server Owner Info",
                    Content = "Owner: " .. ownerName .. " (ID: " .. privateServerOwner .. ")",
                    Image = "rbxassetid://4483345998",
                    Time = 5
                })
            end)
        end
    end
})

Tab = Window:MakeTab({
 Name = "Info",
 Icon = "rbxassetid://7734053426",
 PremiumOnly = false
 })

Section = Tab:AddSection({
 Name = "Currency/Leaderstats"
})

CheckCoins = Tab:AddLabel("Check Coins: [ "..game:GetService("Players").LocalPlayer.leaderstats.Coins.Value.." ]")
CheckBites = Tab:AddLabel("Check Bites: [ "..game:GetService("Players").LocalPlayer.leaderstats.Bites.Value.." ]")

Section = Tab:AddSection({
 Name = "Others"
})

InsaenityTracker = Tab:AddLabel("Insaenity Lvl: [ "..workspace["#GAME"].Map._Other.InsaenityTracker.LVL.SurfaceGui.TextLabel.Text.." ]")
BossTimer = Tab:AddLabel("BOSS Noob in: [ "..workspace["#GAME"].Map._Other.BOSS_Timer.SurfaceGui.TextLabel.Text.." ]")

KillsCountHouse1 = Tab:AddLabel("House 1 Kllls: [ "..workspace["#GAME"].Map._Other.HouseTrackers["1"].Count.SurfaceGui.TextLabel.Text.." ]")
KillsCountHouse2 = Tab:AddLabel("House 2 Kills: [ "..workspace["#GAME"].Map._Other.HouseTrackers["2"].Count.SurfaceGui.TextLabel.Text.." ]")
KillsCountHouse3 = Tab:AddLabel("House 3 Kllls: [ "..workspace["#GAME"].Map._Other.HouseTrackers["3"].Count.SurfaceGui.TextLabel.Text.." ]")
KillsCountHouse4 = Tab:AddLabel("House 4 Kllls: [ "..workspace["#GAME"].Map._Other.HouseTrackers["4"].Count.SurfaceGui.TextLabel.Text.." ]")
KillsCountHouse5 = Tab:AddLabel("House 5 Kllls: [ "..workspace["#GAME"].Map._Other.HouseTrackers["5"].Count.SurfaceGui.TextLabel.Text.." ]")

Section = Tab:AddSection({
 Name = "Universal"
})

InfoPlaceName = Tab:AddLabel("Place Name: [ "..gameName.." ]")
InfoPlaceId = Tab:AddLabel("Place Id: [ "..game.PlaceId.." ]")

ClientVersion = Tab:AddLabel("Client Version [ "..game:GetService("CoreGui").RobloxGui.SettingsClippingShield.SettingsShield.VersionContainer.ClientVersionLabel.Text.." ]")

ServerVersion = Tab:AddLabel("Server Version [ "..game:GetService("CoreGui").RobloxGui.SettingsClippingShield.SettingsShield.VersionContainer.ServerVersionLabel.Text.." ]")

ServerChannel = Tab:AddLabel("Server Channel [ "..game:GetService("CoreGui").RobloxGui.SettingsClippingShield.SettingsShield.VersionContainer.ServerChannelLabel.Text.." ]")

PlaceVersion = Tab:AddLabel("Place Version [ "..game:GetService("CoreGui").RobloxGui.SettingsClippingShield.SettingsShield.VersionContainer.PlaceVersionLabel.Text.." ]")

ClientCoreScriptVersion = Tab:AddLabel("Client CoreScript Version [ "..game:GetService("CoreGui").RobloxGui.SettingsClippingShield.SettingsShield.VersionContainer.CoreScriptVersionLabel.Text.." ]")

local AutoSetInfoServer
AutoSetInfo = Tab:AddToggle({
 Name = "Auto Set Info",
 Default = false,
 Callback = function(Value)
_G.AutoSetInfo = Value
AutoSetInfoServer = game:GetService("RunService").RenderStepped:Connect(function()
if _G.AutoSetInfo == true then

CheckCoins:Set("Check Coins: [ "..game:GetService("Players").LocalPlayer.leaderstats.Coins.Value.." ]")

CheckBites:Set("Check Bites: [ "..game:GetService("Players").LocalPlayer.leaderstats.Bites.Value.." ]")

InsaenityTracker:Set("Insaenity Lvl: [ "..workspace["#GAME"].Map._Other.InsaenityTracker.LVL.SurfaceGui.TextLabel.Text.." ]")
BossTimer:Set("BOSS Noob in: [ "..workspace["#GAME"].Map._Other.BOSS_Timer.SurfaceGui.TextLabel.Text.." ]")

KillsCountHouse1:Set("House 1 Kllls: [ "..workspace["#GAME"].Map._Other.HouseTrackers["1"].Count.SurfaceGui.TextLabel.Text.." ]")
KillsCountHouse2:Set("House 2 Kills: [ "..workspace["#GAME"].Map._Other.HouseTrackers["2"].Count.SurfaceGui.TextLabel.Text.." ]")
KillsCountHouse3:Set("House 3 Kllls: [ "..workspace["#GAME"].Map._Other.HouseTrackers["3"].Count.SurfaceGui.TextLabel.Text.." ]")
KillsCountHouse4:Set("House 4 Kllls: [ "..workspace["#GAME"].Map._Other.HouseTrackers["4"].Count.SurfaceGui.TextLabel.Text.." ]")
KillsCountHouse5:Set("House 5 Kllls: [ "..workspace["#GAME"].Map._Other.HouseTrackers["5"].Count.SurfaceGui.TextLabel.Text.." ]")

InfoPlaceName:Set("Place Name: [ "..gameName.." ]")

InfoPlaceId:Set("Place Id: [ "..game.PlaceId.." ]")

ClientVersion:Set("Client Version [ "..game:GetService("CoreGui").RobloxGui.SettingsClippingShield.SettingsShield.VersionContainer.ClientVersionLabel.Text.." ]")

ServerVersion:Set("Server Version [ "..game:GetService("CoreGui").RobloxGui.SettingsClippingShield.SettingsShield.VersionContainer.ServerVersionLabel.Text.." ]")

ServerChannel:Set("Server Channel [ "..game:GetService("CoreGui").RobloxGui.SettingsClippingShield.SettingsShield.VersionContainer.ServerChannelLabel.Text.." ]")

PlaceVersion:Set("Place Version [ "..game:GetService("CoreGui").RobloxGui.SettingsClippingShield.SettingsShield.VersionContainer.PlaceVersionLabel.Text.." ]")

ClientCoreScriptVersion:Set("Client CoreScript Version [ "..game:GetService("CoreGui").RobloxGui.SettingsClippingShield.SettingsShield.VersionContainer.CoreScriptVersionLabel.Text.." ]")

elseif _G.AutoSetInfo == false then
  if AutoSetInfoServer then
   AutoSetInfoServer:Disconnect()
   AutoSetInfoServer = nil
  end
end
end)
 end
})

Tab = Window:MakeTab({
 Name = "Main",
 Icon = "rbxassetid://7733799901",
 PremiumOnly = false
 })

Section = Tab:AddSection({
 Name = "Auto Eat Feature"
})

-- Add this at the TOP of your script (after variables but before functions)
local RunService = game:GetService("RunService")
local Camera = workspace.CurrentCamera
local Players = game:GetService("Players")
local LocalPlayer = Players.LocalPlayer

local AutoEat = {
    -- Performance optimization variables
    PERFORMANCE_THRESHOLD = 0.033,
    lastPerformanceCheck = tick(),
    frameCount = 0,
    currentFPS = 60,
    lastActionTime = 0,
    ACTION_COOLDOWN = 0.1, -- Increased from 0.01 to reduce spam
    lastScanTime = 0,
    SCAN_INTERVAL = 0.1, -- Increased from 0.01 to reduce spam
    
    -- Cache for NPC lists to reduce scanning
    cachedDeadNPCs = {},
    cachedDeadNoobs = {},
    lastNPCCacheTime = 0,
    NPC_CACHE_INTERVAL = 0.5, -- Increased from 0.02 to reduce scanning
    
    -- Toggle states
    isActiveAll = false,
    isActiveSmart = false,
    isActiveChoosed = false,
    selectedCoinType = "Positive Coins",
    isAutoClicking = false,
    autoClickConnection = nil,
    
    -- Game settings
    USE_DEVIATION = true,
    MAX_DEVIATION_STUDS = 0.5,
    
    -- FIXED: Store camera reference
    Camera = nil,
    
    -- NEW: Game value calculation data
    baseValues = {
        Basic = {coins = 3, bites = 1},
        Ginger = {coins = 4, bites = 1},
        Delicious = {coins = 4, bites = 1},
        Party = {coins = 4, bites = 1},
        Buoyant = {coins = 5, bites = 1},
        Baby = {coins = 5, bites = 2},
        Big = {coins = 5, bites = 2},
        Bomb = {coins = 4, bites = 1},
        Bombarder = {coins = 12, bites = 7},
        Fat = {coins = 4, bites = 3},
        Fatter = {coins = 7, bites = 6},
        Fattest = {coins = 13, bites = 9},
        Flying = {coins = 10, bites = 3},
        Jumperino = {coins = 10, bites = 3},
        Metal = {coins = 12, bites = 5},
        Moai = {coins = 10, bites = 4},
        Nuke = {coins = 15, bites = 2},
        Paper = {coins = 5, bites = 1},
        Old = {coins = 1, bites = 3},
        Poop = {coins = 0, bites = 4},
        Rock = {coins = 8, bites = 3},
        Small = {coins = 4, bites = 1},
        Smaller = {coins = 6, bites = 1},
        Smallest = {coins = 8, bites = 1},
        Skinny = {coins = 4, bites = 10},
        Squished = {coins = 4, bites = 1},
        Squashed = {coins = 4, bites = 1},
        Tall = {coins = 4, bites = 2},
        Taller = {coins = 8, bites = 6},
        Tallest = {coins = 10, bites = 7},
        Turd = {coins = -1, bites = 9},
        Wide = {coins = 8, bites = 6},
        Werewolf = {coins = 50, bites = 20},
        Berend = {coins = 25, bites = 8},
        Dead = {coins = 5, bites = 1},
        BOSS = {coins = 200, bites = 50},
        Cracked = {coins = 85, bites = 5},
        BULL = {coins = 100, bites = 5},
        Nasty = {coins = -3, bites = 1},
        Raffie = {coins = -4, bites = -1},
        SigmaBloxian = {coins = -10, bites = -4},
        Stinky = {coins = -1, bites = 2},
        Greasy = {coins = -1, bites = 3},
        Rusty = {coins = -1, bites = 3},
        Rotten = {coins = -1, bites = 4},
        Burnt = {coins = -1, bites = 5},
    },
    
    -- Rarity multipliers from game code
    rarityMultipliers = {
        Silver = {coins = 2, bites = 1.5},
        Golden = {coins = 4, bites = 2},
        Diamond = {coins = 8, bites = 3},
        Emerald = {coins = 32, bites = 4},
        Ruby = {coins = 160, bites = 6},
        Amethyst = {coins = 800, bites = 8},
    },
    
    -- P2W (Pay-to-Win) detection - ONLY Emerald, Ruby, Amethyst
    p2wRarities = {"Amethyst", "Ruby", "Emerald"}
}

-- Initialize camera reference
AutoEat.Camera = workspace.CurrentCamera

-- ========== UPDATED PATH INITIALIZATION ==========
-- Initialize folders and remotes with correct paths
task.spawn(function()
    local success, errorMsg = pcall(function()
        -- Try to find the game folder with multiple attempts
        local gameFolder = workspace:FindFirstChild("#GAME") or workspace:FindFirstChild("GAME")
        
        if gameFolder then
            -- Try to find NPC folder with multiple path variations
            local possibleNPCPaths = {
                gameFolder:FindFirstChild("Folders") and gameFolder.Folders:FindFirstChild("VisibleInstances") and gameFolder.Folders.VisibleInstances:FindFirstChild("HumanoidFolder") and gameFolder.Folders.VisibleInstances.HumanoidFolder:FindFirstChild("NPCFolder"),
                gameFolder:FindFirstChild("NPCs"),
                gameFolder:FindFirstChild("Noobs"),
                workspace:FindFirstChild("NPCs"),
                workspace:FindFirstChild("Noobs")
            }
            
            for _, folder in ipairs(possibleNPCPaths) do
                if folder then
                    AutoEat.mainFolder = folder
                    break
                end
            end
            
            print("NPC Folder found:", AutoEat.mainFolder and AutoEat.mainFolder.Name or "Not found")
        end
        
        -- Get the ReplicatedStorage game folder
        local repStorageGame = game:GetService("ReplicatedStorage"):FindFirstChild("#GAME")
        if repStorageGame then
            -- MainAttack remote (as specified)
            AutoEat.remote = repStorageGame:FindFirstChild("_Storage") and 
                            repStorageGame._Storage:FindFirstChild("Events") and 
                            repStorageGame._Storage.Events:FindFirstChild("MainAttack")
            
            -- Click remote (updated path)
            AutoEat.clickRemote = repStorageGame:FindFirstChild("_Storage") and 
                                 repStorageGame._Storage:FindFirstChild("Events") and 
                                 repStorageGame._Storage.Events:FindFirstChild("Click")
            
            -- UsableTool remote (updated path)
            AutoEat.usableToolRemote = repStorageGame:FindFirstChild("_Storage") and 
                                      repStorageGame._Storage:FindFirstChild("Events") and 
                                      repStorageGame._Storage.Events:FindFirstChild("UsableTool")
        end
        
        -- Fallback: Try old paths if new ones don't work
        if not AutoEat.remote then
            AutoEat.remote = game:GetService("ReplicatedStorage"):FindFirstChild("Events") and game:GetService("ReplicatedStorage").Events:FindFirstChild("MainAttack")
        end
        if not AutoEat.clickRemote then
            AutoEat.clickRemote = game:GetService("ReplicatedStorage"):FindFirstChild("Events") and game:GetService("ReplicatedStorage").Events:FindFirstChild("Click")
        end
        if not AutoEat.usableToolRemote then
            AutoEat.usableToolRemote = game:GetService("ReplicatedStorage"):FindFirstChild("Events") and game:GetService("ReplicatedStorage").Events:FindFirstChild("UsableTool")
        end
        
        -- Debug prints
        print("=== AutoEat Path Debug ===")
        print("MainAttack Remote:", AutoEat.remote and AutoEat.remote:GetFullName() or "Not found")
        print("Click Remote:", AutoEat.clickRemote and AutoEat.clickRemote:GetFullName() or "Not found")
        print("UsableTool Remote:", AutoEat.usableToolRemote and AutoEat.usableToolRemote:GetFullName() or "Not found")
        print("NPC Folder:", AutoEat.mainFolder and AutoEat.mainFolder:GetFullName() or "Not found")
        print("==========================")
    end)
    
    if not success then
        warn("AutoEat: Failed to initialize game folders. Error:", errorMsg)
    end
end)

-- ========== REAL VALUE CALCULATION FUNCTIONS ==========
local function parseNoobInfo(npcName)
    local name = npcName:lower()
    local info = {
        baseType = "Basic",
        rarity = nil,
        modifiers = {},
        isP2W = false
    }
    
    -- Check for BOSS first
    if string.find(name, "boss") then
        info.baseType = "BOSS"
        return info
    end
    
    -- Check for special high-value types
    if string.find(name, "werewolf") then
        info.baseType = "Werewolf"
        return info
    end
    if string.find(name, "berend") then
        info.baseType = "Berend"
        return info
    end
    if string.find(name, "cracked") then
        info.baseType = "Cracked"
        return info
    end
    if string.find(name, "bull") then
        info.baseType = "BULL"
        return info
    end
    
    -- Check for dead types
    if string.find(name, "dead") then
        table.insert(info.modifiers, "Dead")
    end
    
    -- Check for negative/stink coin types
    local negativeTypes = {"nasty", "raffie", "sigmabloxian", "stinky", "greasy", "rusty", "rotten", "burnt", "turd", "poop"}
    for _, negType in ipairs(negativeTypes) do
        if string.find(name, negType) then
            info.baseType = negType:gsub("^%l", string.upper)
            break
        end
    end
    
    -- Check for cookies
    local cookieTypes = {"ginger", "delicious", "party", "buoyant", "primo"}
    for _, cookie in ipairs(cookieTypes) do
        if string.find(name, cookie) then
            info.baseType = cookie:gsub("^%l", string.upper)
            break
        end
    end
    
    -- Check for rarity
    local rarities = {"amethyst", "ruby", "emerald", "diamond", "golden", "gold", "silver", "rock"}
    for _, rarity in ipairs(rarities) do
        if string.find(name, rarity) then
            info.rarity = rarity:gsub("^%l", string.upper)
            if info.rarity == "Gold" then
                info.rarity = "Golden"
            end
            
            -- P2W detection: ONLY Emerald, Ruby, Amethyst are P2W
            for _, p2wRarity in ipairs(AutoEat.p2wRarities) do
                if info.rarity == p2wRarity then
                    info.isP2W = true
                    break
                end
            end
            break
        end
    end
    
    -- Check for base noob types
    if info.baseType == "Basic" then
        local baseTypes = {
            "baby", "big", "bomb", "fat", "fatter", "fattest", "flying", "jumperino",
            "metal", "moai", "nuke", "paper", "old", "small", "smaller", "smallest",
            "skinny", "squished", "squashed", "tall", "taller", "tallest", "wide"
        }
        for _, base in ipairs(baseTypes) do
            if string.find(name, base) then
                info.baseType = base:gsub("^%l", string.upper)
                break
            end
        end
    end
    
    return info
end

local function calculateActualCoins(noobInfo)
    local baseValue = AutoEat.baseValues[noobInfo.baseType] or AutoEat.baseValues.Basic
    local baseCoins = baseValue.coins
    
    -- Apply rarity multiplier
    if noobInfo.rarity and AutoEat.rarityMultipliers[noobInfo.rarity] then
        baseCoins = baseCoins * AutoEat.rarityMultipliers[noobInfo.rarity].coins
    end
    
    return math.floor(baseCoins)
end

local function calculateActualBites(noobInfo)
    local baseValue = AutoEat.baseValues[noobInfo.baseType] or AutoEat.baseValues.Basic
    local baseBites = baseValue.bites
    
    -- Apply rarity multiplier
    if noobInfo.rarity and AutoEat.rarityMultipliers[noobInfo.rarity] then
        baseBites = baseBites * AutoEat.rarityMultipliers[noobInfo.rarity].bites
    end
    
    return math.floor(baseBites)
end

-- ========== PERFORMANCE MONITORING ==========
local function checkPerformance()
    AutoEat.frameCount = AutoEat.frameCount + 1
    local currentTime = tick()
    
    if currentTime - AutoEat.lastPerformanceCheck >= 1 then
        AutoEat.currentFPS = AutoEat.frameCount
        AutoEat.frameCount = 0
        AutoEat.lastPerformanceCheck = currentTime
        
        if AutoEat.currentFPS < 25 then
            return false
        end
    end
    return true
end

-- Replace the useBurger function with this improved version:
local function useBurger()
    local player = game.Players.LocalPlayer
    local character = player.Character
    if not character then return false end
    
    -- First, check if we have any burgers equipped or in backpack
    local burgers = {}
    
    -- Check equipped tool
    local equippedTool = character:FindFirstChildWhichIsA("Tool")
    if equippedTool and string.find(equippedTool.Name:lower(), "burger") then
        table.insert(burgers, equippedTool)
    end
    
    -- Check backpack for burgers
    for _, item in ipairs(player.Backpack:GetChildren()) do
        if item:IsA("Tool") and string.find(item.Name:lower(), "burger") then
            table.insert(burgers, item)
        end
    end
    
    if #burgers == 0 then return false end
    
    -- Select a random burger
    local selectedBurger = burgers[math.random(1, #burgers)]
    
    -- If not equipped, equip it first
    if selectedBurger.Parent == player.Backpack then
        if equippedTool then
            equippedTool.Parent = player.Backpack
            task.wait(0.05)
        end
        selectedBurger.Parent = character
        task.wait(0.1)
    end
    
    -- Try to use the burger
    if AutoEat.usableToolRemote then
        local burgerArgs = {selectedBurger}
        local success = pcall(function()
            AutoEat.usableToolRemote:FireServer(unpack(burgerArgs))
        end)
        
        if success then
            -- Also send a click to ensure action registers
            if AutoEat.clickRemote then
                pcall(function()
                    AutoEat.clickRemote:FireServer()
                end)
            end
            return true
        end
    end
    
    -- Fallback to click if burger remote fails
    if AutoEat.clickRemote then
        pcall(function()
            AutoEat.clickRemote:FireServer()
        end)
        return true
    end
    
    return false
end

-- ========== AUTO CLICK FUNCTIONS ==========
local function startAutoClick()
    if AutoEat.autoClickConnection then
        AutoEat.autoClickConnection:Disconnect()
        AutoEat.autoClickConnection = nil
    end
    
    AutoEat.isAutoClicking = true
    AutoEat.autoClickConnection = RunService.Heartbeat:Connect(function()
        if not checkPerformance() then
            task.wait(0.01)
            return
        end
        
        local currentTime = tick()
        
        if AutoEat.isActiveChoosed and AutoEat.selectedCoinType == "Burgers" then
            if currentTime - AutoEat.lastActionTime >= AutoEat.ACTION_COOLDOWN then
                if AutoEat.clickRemote then
                    pcall(function()
                        AutoEat.clickRemote:FireServer()
                    end)
                end
            end
            return
        end
        
        if AutoEat.clickRemote then
            pcall(function()
                AutoEat.clickRemote:FireServer()
            end)
        end
        task.wait(0.01)
    end)
end

local function stopAutoClick()
    AutoEat.isAutoClicking = false
    if AutoEat.autoClickConnection then
        AutoEat.autoClickConnection:Disconnect()
        AutoEat.autoClickConnection = nil
    end
end

-- ========== NPC SCANNING FUNCTIONS ==========
local function getDeadNPCs()
    local currentTime = tick()
    
    if #AutoEat.cachedDeadNPCs > 0 and (currentTime - AutoEat.lastNPCCacheTime) < AutoEat.NPC_CACHE_INTERVAL then
        return AutoEat.cachedDeadNPCs
    end
    
    local deadList = {}
    if not AutoEat.mainFolder then 
        AutoEat.cachedDeadNPCs = deadList
        return deadList 
    end

    pcall(function()
        local foldersToCheck = {AutoEat.mainFolder}
        
        -- Alternative path check
        local alternativePath = workspace:FindFirstChild("#GAME") and 
                               workspace["#GAME"]:FindFirstChild("Folders") and 
                               workspace["#GAME"].Folders:FindFirstChild("VisibleInstances") and 
                               workspace["#GAME"].Folders.VisibleInstances:FindFirstChild("HumanoidFolder") and 
                               workspace["#GAME"].Folders.VisibleInstances.HumanoidFolder:FindFirstChild("NPCFolder")
        if alternativePath and alternativePath ~= AutoEat.mainFolder then
            table.insert(foldersToCheck, alternativePath)
        end

        for _, folder in ipairs(foldersToCheck) do
            local npcs = folder:GetChildren()
            for i = 1, #npcs do
                local npc = npcs[i]
                if npc:IsA("Model") then
                    local humanoid = npc:FindFirstChildOfClass("Humanoid")
                    if humanoid and (humanoid.Health <= 0 or string.find(npc.Name, "Dead", 1, true) or string.find(humanoid.Name, "Dead", 1, true)) then
                        table.insert(deadList, npc)
                    end
                end
                
                if i % 20 == 0 then
                    task.wait()
                end
            end
        end
    end)
    
    AutoEat.cachedDeadNPCs = deadList
    AutoEat.lastNPCCacheTime = currentTime
    return deadList
end

-- ========== FIXED TARGET SELECTION ==========

-- AUTO EAT SMART: First P2W noobs, then regular highest coin noobs
local function getSmartTarget(npcList)
    if not npcList or #npcList == 0 then return nil end
    
    local p2wTargets = {}
    local regularTargets = {}
    
    -- Separate P2W and regular noobs
    for _, npc in ipairs(npcList) do
        local noobInfo = parseNoobInfo(npc.Name)
        local coins = calculateActualCoins(noobInfo)
        
        if noobInfo.isP2W then
            -- P2W noob
            table.insert(p2wTargets, {
                npc = npc,
                coins = coins,
                isP2W = true,
                rarity = noobInfo.rarity
            })
        else
            -- Regular noob
            table.insert(regularTargets, {
                npc = npc,
                coins = coins,
                isP2W = false
            })
        end
    end
    
    -- 1. First priority: P2W noobs (sorted highest to lowest coins)
    if #p2wTargets > 0 then
        table.sort(p2wTargets, function(a, b)
            return a.coins > b.coins
        end)
        return p2wTargets[1].npc
    end
    
    -- 2. Second priority: Regular noobs (sorted highest to lowest coins)
    if #regularTargets > 0 then
        table.sort(regularTargets, function(a, b)
            return a.coins > b.coins
        end)
        return regularTargets[1].npc
    end
    
    return nil
end

-- AUTO EAT ALL: Targets ALL noobs (highest to lowest coins overall)
local function getAllNoobsTarget(npcList)
    if not npcList or #npcList == 0 then return nil end
    
    -- Collect all noobs with their coin values
    local allTargets = {}
    
    for _, npc in ipairs(npcList) do
        local noobInfo = parseNoobInfo(npc.Name)
        local coins = calculateActualCoins(noobInfo)
        
        table.insert(allTargets, {
            npc = npc,
            coins = coins
        })
    end
    
    -- Sort ALL targets from HIGHEST to LOWEST coins
    table.sort(allTargets, function(a, b)
        return a.coins > b.coins
    end)
    
    -- Return the highest coin target overall
    return allTargets[1].npc
end

local function getChoosedTypeTarget(npcList, coinType)
    if not npcList or #npcList == 0 then return nil end
    
    if coinType == "Positive Coins" then
        -- Get all positive coin targets
        local positiveTargets = {}
        for _, npc in ipairs(npcList) do
            local noobInfo = parseNoobInfo(npc.Name)
            local coins = calculateActualCoins(noobInfo)
            if coins > 0 then
                table.insert(positiveTargets, {
                    npc = npc,
                    coins = coins
                })
            end
        end
        
        -- Sort positive targets from HIGHEST to LOWEST
        if #positiveTargets > 0 then
            table.sort(positiveTargets, function(a, b)
                return a.coins > b.coins
            end)
            return positiveTargets[1].npc
        end
        
    elseif coinType == "Negative Coins" then
        -- Get all negative coin targets
        local negativeTargets = {}
        for _, npc in ipairs(npcList) do
            local noobInfo = parseNoobInfo(npc.Name)
            local coins = calculateActualCoins(noobInfo)
            if coins < 0 then
                table.insert(negativeTargets, {
                    npc = npc,
                    coins = coins
                })
            end
        end
        
        -- Sort negative targets from LOWEST to HIGHEST (most negative first)
        if #negativeTargets > 0 then
            table.sort(negativeTargets, function(a, b)
                return a.coins < b.coins
            end)
            return negativeTargets[1].npc
        end
        
    elseif coinType == "Stink Coins" then
        -- Get stink coin noobs (coins <= 0)
        local stinkTargets = {}
        for _, npc in ipairs(npcList) do
            local noobInfo = parseNoobInfo(npc.Name)
            local coins = calculateActualCoins(noobInfo)
            if coins <= 0 then
                table.insert(stinkTargets, {
                    npc = npc,
                    coins = coins
                })
            end
        end
        
        -- Sort stink targets from LOWEST to HIGHEST (most negative first)
        if #stinkTargets > 0 then
            table.sort(stinkTargets, function(a, b)
                return a.coins < b.coins
            end)
            return stinkTargets[1].npc
        end
        
    elseif coinType == "Cookies" then
        -- Get cookie noobs
        local cookieNames = {"Ginger", "Delicious", "Party", "Buoyant", "Primo"}
        local cookieTargets = {}
        for _, npc in ipairs(npcList) do
            for _, cookieName in ipairs(cookieNames) do
                if string.find(npc.Name, cookieName, 1, true) then
                    local noobInfo = parseNoobInfo(npc.Name)
                    local coins = calculateActualCoins(noobInfo)
                    table.insert(cookieTargets, {
                        npc = npc,
                        coins = coins
                    })
                    break
                end
            end
        end
        
        -- Sort cookie targets from HIGHEST to LOWEST
        if #cookieTargets > 0 then
            table.sort(cookieTargets, function(a, b)
                return a.coins > b.coins
            end)
            return cookieTargets[1].npc
        end
        
    elseif coinType == "King Coins" then
        for _, npc in ipairs(npcList) do
            if npc.Name:find("BOSS", 1, true) then
                return npc
            end
        end
        
    elseif coinType == "Dead Noobs" then
        local deadNoobList = {}
        for _, npc in ipairs(npcList) do
            if string.find(npc.Name:lower(), "dead", 1, true) then
                local noobInfo = parseNoobInfo(npc.Name)
                local coins = calculateActualCoins(noobInfo)
                table.insert(deadNoobList, {
                    npc = npc,
                    coins = coins
                })
            end
        end
        
        -- Sort dead noobs from HIGHEST to LOWEST
        if #deadNoobList > 0 then
            table.sort(deadNoobList, function(a, b)
                return a.coins > b.coins
            end)
            return deadNoobList[1].npc
        end
        
    elseif coinType == "Burgers" then
        return "BURGER_MODE"
        
    elseif coinType == "Pouwkoins" then
    -- Get only targets with "Pouwk" in the name (case insensitive)
    local pouwkTargets = {}
    for _, npc in ipairs(npcList) do
        local npcNameLower = npc.Name:lower()
        if string.find(npcNameLower, "pouwk") then
            local noobInfo = parseNoobInfo(npc.Name)
            local bites = calculateActualBites(noobInfo)
            table.insert(pouwkTargets, {
                npc = npc,
                bites = bites,
                name = npc.Name
            })
        end
    end
    
    -- Sort from HIGHEST to LOWEST bites
    if #pouwkTargets > 0 then
        table.sort(pouwkTargets, function(a, b)
            return a.bites > b.bites
        end)

        return pouwkTargets[1].npc
    end
        
    elseif coinType == "BULLoneys" then
    -- Get only targets with "BULL" in the name (case insensitive)
    local bullTargets = {}
    for _, npc in ipairs(npcList) do
        local npcNameLower = npc.Name:lower()
        if string.find(npcNameLower, "bull") then
            local noobInfo = parseNoobInfo(npc.Name)
            local coins = calculateActualCoins(noobInfo)
            local bites = calculateActualBites(noobInfo)
            local totalValue = coins + (bites * 0.5)
            table.insert(bullTargets, {
                npc = npc,
                value = totalValue,
                coins = coins,
                name = npc.Name
            })
        end
    end
    
    -- Sort from HIGHEST to LOWEST total value
    if #bullTargets > 0 then
        table.sort(bullTargets, function(a, b)
            return a.value > b.value
        end)
        
        return bullTargets[1].npc
    end
    
    end

    return nil
end

-- ========== FIXED ATTACK FUNCTION ==========
local function attackTarget(targetNpc)
    local currentTime = tick()
    
    if currentTime - AutoEat.lastActionTime < AutoEat.ACTION_COOLDOWN then
        return
    end
    
    if not targetNpc or not targetNpc.Parent then return end

    -- FIXED: Get camera safely
    local camera = AutoEat.Camera
    if not camera or not camera.CFrame then
        -- Try to get fresh camera reference
        camera = workspace.CurrentCamera
        if not camera then return end
        AutoEat.Camera = camera
    end

    local validParts = {}
    pcall(function()
        for _, part in ipairs(targetNpc:GetDescendants()) do
            if part:IsA("BasePart") then
                local isGettingEaten = part:GetAttribute("IsGettingEaten")
                if not isGettingEaten then
                    table.insert(validParts, part)
                end
            end
            
            if #validParts >= 5 then
                break
            end
        end
    end)
    
    if #validParts == 0 then return end

    local bodyPart = validParts[math.random(1, #validParts)]
    local origin = camera.CFrame.Position
    local targetPosition = bodyPart.Position

    if AutoEat.USE_DEVIATION and AutoEat.MAX_DEVIATION_STUDS > 0 then
        local offsetX = (math.random() - 0.5) * 2 * AutoEat.MAX_DEVIATION_STUDS
        local offsetY = (math.random() - 0.5) * 2 * AutoEat.MAX_DEVIATION_STUDS
        local offsetZ = (math.random() - 0.5) * 2 * AutoEat.MAX_DEVIATION_STUDS
        targetPosition = targetPosition + Vector3.new(offsetX, offsetY, offsetZ)
    end

    local direction = (targetPosition - origin).Unit

    if direction.X ~= direction.X or direction.Y ~= direction.Y or direction.Z ~= direction.Z then
        direction = camera.CFrame.LookVector
    end

    local args = {
        [1] = {
            ["AN"] = "Eat",
            ["D"] = direction,
            ["O"] = origin,
            ["FBP"] = bodyPart
        }
    }
    
    local success = false
    if AutoEat.remote then
        success = pcall(function()
            AutoEat.remote:FireServer(unpack(args))
        end)
    end
    
    if success then
        AutoEat.lastActionTime = currentTime
    end
end

-- ========== FIXED MAIN LOOP ==========
local mainConnection = nil

local function startMainLoop()
    if mainConnection then
        mainConnection:Disconnect()
        mainConnection = nil
    end
    
    mainConnection = RunService.Heartbeat:Connect(function()
        -- Only run if at least one toggle is active
        if not (AutoEat.isActiveAll or AutoEat.isActiveSmart or AutoEat.isActiveChoosed) then
            return
        end
        
        if not checkPerformance() then
            task.wait(0.01)
            return
        end
        
        local currentTime = tick()
        
        -- Reduced scanning frequency
        if currentTime - AutoEat.lastScanTime < AutoEat.SCAN_INTERVAL then
            return
        end
        
        AutoEat.lastScanTime = currentTime

        local deadNPCList = getDeadNPCs()

        -- Auto Eat All: Targets ALL noobs (highest to lowest coins overall)
        if AutoEat.isActiveAll then
            local targetNpc = getAllNoobsTarget(deadNPCList)
            if targetNpc then
                attackTarget(targetNpc)
                return
            end
        end

        -- Auto Eat Smart: First P2W noobs, then regular highest coin noobs
        if AutoEat.isActiveSmart then
            local targetNpc = getSmartTarget(deadNPCList)
            if targetNpc then
                attackTarget(targetNpc)
                return
            end
        end

        -- Auto Eat Choosed Type
        if AutoEat.isActiveChoosed then
            local targetNpc = getChoosedTypeTarget(deadNPCList, AutoEat.selectedCoinType)
            
            if targetNpc == "BURGER_MODE" then
                if currentTime - AutoEat.lastActionTime >= AutoEat.ACTION_COOLDOWN then
                    useBurger()
                    AutoEat.lastActionTime = currentTime
                end
                return
            elseif targetNpc then
                attackTarget(targetNpc)
                return
            end
        end
    end)
end

local function stopMainLoop()
    if mainConnection then
        mainConnection:Disconnect()
        mainConnection = nil
    end
end

-- ========== FLUENT HUB UI ELEMENTS ==========
local coinTypes = {
    "Positive Coins",
    "Stink Coins",
    "Cookies",
    "King Coins",
    "Dead Noobs",
    "Burgers",
    "Pouwkoins",
    "BULLoneys"
}

-- ========== ORION HUB UI FOR AUTO EAT ==========

-- Auto Eat All Type Toggle (Orion Hub)
Tab:AddToggle({
    Name = "Auto Eat All Type",
    Default = false,
    Callback = function(value)
        AutoEat.isActiveAll = value
        if value then
            -- Turn off other modes
            AutoEat.isActiveSmart = false
            AutoEat.isActiveChoosed = false
            
            startAutoClick()
            startMainLoop()
            OrionLib:MakeNotification({
                Name = "Auto Eat",
                Content = "Enabled for all coins (Value Based - Highest to Lowest)",
                Image = "rbxassetid://4483345998",
                Time = 2
            })
        else
            if not AutoEat.isActiveSmart and not AutoEat.isActiveChoosed then
                stopAutoClick()
                stopMainLoop()
            end
        end
    end
})

-- Auto Eat Smart Toggle (Orion Hub)
Tab:AddToggle({
    Name = "Auto Eat Smart",
    Default = false,
    Callback = function(value)
        AutoEat.isActiveSmart = value
        if value then
            -- Turn off other modes
            AutoEat.isActiveAll = false
            AutoEat.isActiveChoosed = false
            
            startAutoClick()
            startMainLoop()
            OrionLib:MakeNotification({
                Name = "Auto Eat Smart",
                Content = "Enabled (P2W > Highest Value > Value Based)",
                Image = "rbxassetid://4483345998",
                Time = 2
            })
        else
            if not AutoEat.isActiveAll and not AutoEat.isActiveChoosed then
                stopAutoClick()
                stopMainLoop()
            end
        end
    end
})

-- Coin Type Dropdown (Orion Hub)
Tab:AddDropdown({
    Name = "Choose Type To Auto Eat",
    Default = "Positive Coins",
    Options = {
        "Positive Coins",
        "Stink Coins",
        "Cookies",
        "King Coins",
        "Dead Noobs",
        "Burgers",
        "Pouwkoins",
        "BULLoneys"
    },
    Callback = function(value)
        -- value is the actual string
        AutoEat.selectedCoinType = value
        OrionLib:MakeNotification({
            Name = "Coin Type",
            Content = "Selected: " .. value,
            Image = "rbxassetid://4483345998",
            Time = 2
        })
    end
})

-- Auto Eat Choosed Type Toggle (Orion Hub)
Tab:AddToggle({
    Name = "Auto Eat Choosed Type",
    Default = false,
    Callback = function(value)
        AutoEat.isActiveChoosed = value
        if value then
            -- Turn off other modes
            AutoEat.isActiveAll = false
            AutoEat.isActiveSmart = false
            
            startAutoClick()
            startMainLoop()
            OrionLib:MakeNotification({
                Name = "Auto Eat",
                Content = "Enabled for " .. (AutoEat.selectedCoinType or "Selected Type") .. " (Value Based)",
                Image = "rbxassetid://4483345998",
                Time = 2
            })
        else
            if not AutoEat.isActiveAll and not AutoEat.isActiveSmart then
                stopAutoClick()
                stopMainLoop()
            end
        end
    end
})

Section = Tab:AddSection({
 Name = "Auto Shoot Feature"
})

-- Auto Shoot System (Optimized)
local ShootSystem = setmetatable({
    Running = false,
    Connection = nil,
    LastShootTime = 0,
    IsHolding = false,
    HoldStartTime = 0,
    CurrentTarget = nil,
    TwoPhasePhase = 1,
    MainAttackEvent = nil,
    _cleaningUp = false,
    
    -- Weak references for better memory management
    CachedNPCs = setmetatable({}, {__mode = "v"})
}, {
    __index = function(self, key)
        -- Lazy load services
        if key == "Players" then return game:GetService("Players")
        elseif key == "ReplicatedStorage" then return game:GetService("ReplicatedStorage")
        elseif key == "RunService" then return game:GetService("RunService")
        elseif key == "Workspace" then return game:GetService("Workspace")
        elseif key == "Player" then 
            local players = game:GetService("Players")
            local player = players.LocalPlayer
            if not player then
                players.PlayerAdded:Wait()
                player = players.LocalPlayer
            end
            rawset(self, "Player", player)
            return player
        end
    end
})

-- Settings (using local table instead of _G for better performance)
local AutoShootSettings = {
    GunName = "Minigun",
    ShootingSpeed = 6,
    MaxDistance = 1000,
    Enabled = false
}

-- Configuration tables (local for faster access)
local HoldTools = {"TMG V2", "SMOGGTTLTSG"}
local TwoPhaseGuns = {"The Eggsterminator", "Firework Launcher", "Nubids Bow", "Pumpkin Launcher"}
local IgnoreNPCs = {"dead", "invincible", "crackedbas", "whitebas"}

-- Cache for NPC folder
local NPCFolderCache = nil
local lastFolderCheck = 0

-- Find NPC folder with caching
local function getNPCFolder()
    local currentTime = tick()
    if NPCFolderCache and (currentTime - lastFolderCheck) < 5 then
        return NPCFolderCache
    end
    
    local Workspace = game:GetService("Workspace")
    local gameFolder = Workspace:FindFirstChild("#GAME") or Workspace:FindFirstChild("GAME") or Workspace:FindFirstChild("Game")
    
    if not gameFolder then
        lastFolderCheck = currentTime
        return nil
    end
    
    -- Check common paths
    local possiblePaths = {
        gameFolder:FindFirstChild("Folders") and gameFolder.Folders:FindFirstChild("VisibleInstances") and 
        gameFolder.Folders.VisibleInstances:FindFirstChild("HumanoidFolder") and 
        gameFolder.Folders.VisibleInstances.HumanoidFolder:FindFirstChild("NPCFolder"),
        gameFolder:FindFirstChild("NPCs"),
        Workspace:FindFirstChild("NPCs"),
        Workspace:FindFirstChild("Noobs"),
        Workspace:FindFirstChild("DeadNoobs")
    }
    
    for _, folder in ipairs(possiblePaths) do
        if folder then
            NPCFolderCache = folder
            lastFolderCheck = currentTime
            return folder
        end
    end
    
    -- Search recursively as last resort
    local function searchForNPCFolder(parent)
        for _, child in ipairs(parent:GetChildren()) do
            if child:IsA("Folder") then
                local nameLower = child.Name:lower()
                if nameLower:find("npc") or nameLower:find("noob") then
                    return child
                end
                local found = searchForNPCFolder(child)
                if found then return found end
            end
        end
        return nil
    end
    
    NPCFolderCache = searchForNPCFolder(gameFolder) or searchForNPCFolder(Workspace)
    lastFolderCheck = currentTime
    return NPCFolderCache
end

-- Cache for attack event
local MainAttackEvent = nil
local lastEventCheck = 0

-- Get main attack event with caching
local function getAttackEvent()
    local currentTime = tick()
    if MainAttackEvent and (currentTime - lastEventCheck) < 10 then
        return MainAttackEvent
    end
    
    local rs = game:GetService("ReplicatedStorage")
    local paths = {
        rs:FindFirstChild("#GAME") and rs["#GAME"]:FindFirstChild("_Storage") and 
        rs["#GAME"]._Storage:FindFirstChild("Events") and rs["#GAME"]._Storage.Events:FindFirstChild("MainAttack"),
        rs:FindFirstChild("Events") and rs.Events:FindFirstChild("MainAttack")
    }
    
    for _, event in ipairs(paths) do
        if event and event:IsA("RemoteEvent") then
            MainAttackEvent = event
            lastEventCheck = currentTime
            return event
        end
    end
    
    lastEventCheck = currentTime
    return nil
end

-- Helper functions
local function shouldIgnore(npc)
    if not npc or not npc:IsA("Model") then return true end
    
    local name = npc.Name:lower()
    for _, ignore in ipairs(IgnoreNPCs) do
        if name:find(ignore) then
            if ignore == "crackedbas" or ignore == "whitebas" then
                local h = npc:FindFirstChildOfClass("Humanoid")
                if h and h.MaxHealth == 500000 then return true end
            else
                return true
            end
        end
    end
    return false
end

local function isHoldTool(name)
    for _, tool in ipairs(HoldTools) do
        if name == tool then return true end
    end
    return false
end

local function isTwoPhase(name)
    for _, gun in ipairs(TwoPhaseGuns) do
        if name == gun then return true end
    end
    return false
end

local function getTool(name)
    local player = ShootSystem.Player
    if not player then return nil end
    
    -- Check character first
    local char = player.Character
    if char then
        local tool = char:FindFirstChild(name)
        if tool then return tool end
    end
    
    -- Check backpack
    local backpack = player.Backpack
    if backpack then
        return backpack:FindFirstChild(name)
    end
    
    return nil
end

-- Two-phase gun attacks (optimized)
local function twoPhaseAttack(target, gunName, phase)
    local char = ShootSystem.Player.Character
    if not char then return end
    
    local tool = getTool(gunName)
    if not tool then return end
    
    local head = target:FindFirstChild("Head")
    if not head then return end
    
    local event = getAttackEvent()
    if not event then return end
    
    local args = {}
    local headPos = head.Position
    
    if gunName == "The Eggsterminator" then
        if phase == 1 then
            args = {{
                A = char, AN = gunName, O = headPos,
                D = Vector3.new(-0.5608, -0.5042, -0.6567), T = tool,
                SP = headPos, HP = headPos, RS = headPos
            }}
        else
            args = {{
                ALV = Vector3.new(-0.2052, -391.425, -5.5824), EP = headPos,
                T = tool, AN = gunName .. "Explode", A = char
            }}
        end
    elseif gunName == "Firework Launcher" then
        if phase == 1 then
            args = {{
                A = char, D = Vector3.new(0.3890, -0.3426, -0.8552), RS = headPos,
                AN = gunName, T = tool, O = headPos - Vector3.new(0, 10, 0),
                SP = headPos, FireworkCount = 2, HP = headPos, CanExplodeFirework = true
            }}
        else
            args = {{
                ALV = Vector3.new(29.2565, -18.4212, -80.4404), EP = headPos,
                T = tool, AN = gunName .. "Explode", A = char
            }}
        end
    elseif gunName == "Nubids Bow" then
        if phase == 1 then
            args = {{
                A = char, AN = gunName, O = headPos,
                D = Vector3.new(0.6942, -0.5255, -0.4919), T = tool,
                SP = headPos, HP = headPos, RS = headPos
            }}
        else
            args = {{AN = gunName .. " Hit", H = head, T = tool}}
        end
    elseif gunName == "Pumpkin Launcher" then
        if phase == 1 then
            args = {{
                A = char, AN = gunName, O = headPos,
                D = Vector3.new(0.2887, -0.4179, -0.8614), T = tool,
                SP = headPos, HP = headPos, RS = headPos
            }}
        else
            args = {{
                ALV = Vector3.new(6.4805, 122.9122, -108.0439), EP = headPos,
                T = tool, AN = gunName .. "Explode", A = char
            }}
        end
    end
    
    if #args > 0 then
        pcall(function()
            event:FireServer(unpack(args))
        end)
    end
end

-- Regular attack function (optimized)
local function regularAttack(target, gunName, isHold)
    local char = ShootSystem.Player.Character
    if not char then return end
    
    local tool = getTool(gunName)
    if not tool then return end
    
    -- Ensure tool is equipped
    if tool.Parent == ShootSystem.Player.Backpack then
        local equipped = char:FindFirstChildWhichIsA("Tool")
        if equipped then
            equipped.Parent = ShootSystem.Player.Backpack
            task.wait(0.01)
        end
        tool.Parent = char
        task.wait(0.01)
    end
    
    local head = target:FindFirstChild("Head")
    if not head then return end
    
    local root = char:FindFirstChild("HumanoidRootPart") or char.PrimaryPart
    if not root then return end
    
    local event = getAttackEvent()
    if not event then return end
    
    local args = {{
        FD = head.Position, 
        SD = Vector3.new(), 
        FO = root.Position + Vector3.new(0, 1.5, 0),
        T = tool, 
        AN = gunName, 
        H = head, 
        BM = 22.15, 
        RP = root.Position,
        HP = head.Position, 
        SP = head.Position
    }}
    
    if isHold then
        args[1].IsHolding = true
        args[1].Duration = 0.1
    end
    
    pcall(function()
        event:FireServer(unpack(args))
    end)
end

-- Find target (optimized with caching)
local lastTargetScan = 0
local cachedTargets = {}
local function findTarget(char, maxDist)
    if not char or not char.PrimaryPart then return nil end
    
    local npcFolder = getNPCFolder()
    if not npcFolder then return nil end
    
    local currentTime = tick()
    if #cachedTargets > 0 and (currentTime - lastTargetScan) < 0.1 then
        local charPos = char.PrimaryPart.Position
        for _, npc in ipairs(cachedTargets) do
            if npc and npc.Parent then
                local head = npc:FindFirstChild("Head")
                if head then
                    local dist = (charPos - head.Position).Magnitude
                    if dist <= maxDist then
                        return npc
                    end
                end
            end
        end
    end
    
    -- Refresh cache
    local validNPCs = {}
    local charPos = char.PrimaryPart.Position
    
    for _, npc in ipairs(npcFolder:GetChildren()) do
        if not ShootSystem.Running then break end
        if shouldIgnore(npc) then continue end
        
        local h = npc:FindFirstChildOfClass("Humanoid")
        local head = npc:FindFirstChild("Head")
        
        if h and head and h.Health > 0 then
            local dist = (charPos - head.Position).Magnitude
            if dist <= maxDist then
                table.insert(validNPCs, npc)
            end
        end
    end
    
    cachedTargets = validNPCs
    lastTargetScan = currentTime
    
    return validNPCs[1] -- Return first valid target
end

-- Main loop
local function startLoop()
    if ShootSystem.Connection then
        ShootSystem.Connection:Disconnect()
        ShootSystem.Connection = nil
    end
    
    ShootSystem.Connection = ShootSystem.RunService.Heartbeat:Connect(function()
        if ShootSystem._cleaningUp or not ShootSystem.Running then return end
        
        local char = ShootSystem.Player.Character
        if not char or not char.PrimaryPart then 
            task.wait(0.1)
            return 
        end
        
        local target = findTarget(char, AutoShootSettings.MaxDistance)
        if not target then
            ShootSystem.IsHolding = false
            ShootSystem.CurrentTarget = nil
            ShootSystem.TwoPhasePhase = 1
            task.wait(0.05)
            return
        end
        
        local currentTime = tick()
        local interval = 1 / math.clamp(AutoShootSettings.ShootingSpeed, 1, 60)
        
        if isTwoPhase(AutoShootSettings.GunName) then
            if not getTool(AutoShootSettings.GunName) then
                task.wait(0.1)
                return
            end
            
            if currentTime - ShootSystem.LastShootTime >= 0.01 then
                twoPhaseAttack(target, AutoShootSettings.GunName, ShootSystem.TwoPhasePhase)
                ShootSystem.TwoPhasePhase = ShootSystem.TwoPhasePhase == 1 and 2 or 1
                ShootSystem.LastShootTime = currentTime
            end
        else
            local isHold = isHoldTool(AutoShootSettings.GunName)
            
            if isHold then
                if ShootSystem.CurrentTarget ~= target then
                    ShootSystem.IsHolding = false
                    ShootSystem.CurrentTarget = target
                end
                
                if not ShootSystem.IsHolding then
                    ShootSystem.IsHolding = true
                    ShootSystem.HoldStartTime = currentTime
                    regularAttack(target, AutoShootSettings.GunName, true)
                elseif currentTime - ShootSystem.HoldStartTime >= interval then
                    regularAttack(target, AutoShootSettings.GunName, true)
                    ShootSystem.HoldStartTime = currentTime
                end
            elseif currentTime - ShootSystem.LastShootTime >= interval then
                regularAttack(target, AutoShootSettings.GunName, false)
                ShootSystem.LastShootTime = currentTime
            end
        end
    end)
end

-- Cleanup function
local function cleanup()
    if ShootSystem._cleaningUp then return end
    
    ShootSystem._cleaningUp = true
    ShootSystem.Running = false
    ShootSystem.IsHolding = false
    ShootSystem.CurrentTarget = nil
    ShootSystem.TwoPhasePhase = 1
    
    if ShootSystem.Connection then
        ShootSystem.Connection:Disconnect()
        ShootSystem.Connection = nil
    end
    
    -- Clear caches
    cachedTargets = {}
    ShootSystem.CachedNPCs = setmetatable({}, {__mode = "v"})
    
    -- Allow garbage collection
    task.wait(0.1)
    ShootSystem._cleaningUp = false
end

-- Character respawn handler
ShootSystem.Player.CharacterAdded:Connect(function()
    task.wait(1)
    if AutoShootSettings.Enabled then
        ShootSystem.Running = true
        task.wait(1)
        startLoop()
    end
end)

-- UI Elements
Tab:AddTextbox({
    Name = "Gun Name",
    Default = "Minigun",
    Callback = function(Text)
        AutoShootSettings.GunName = tostring(Text) or "Minigun"
    end
})

Tab:AddTextbox({
    Name = "Shooting Speed",
    Default = "6",
    Callback = function(Text)
        AutoShootSettings.ShootingSpeed = math.clamp(tonumber(Text) or 6, 1, 60)
    end
})

Tab:AddTextbox({
    Name = "Max Distance",
    Default = "1000",
    Callback = function(Text)
        AutoShootSettings.MaxDistance = math.clamp(tonumber(Text) or 1000, 10, 5000)
    end
})

Tab:AddToggle({
    Name = "Auto Shoot",
    Default = false,
    Callback = function(Value)
        AutoShootSettings.Enabled = Value
        
        if Value then
            ShootSystem.Running = true
            ShootSystem.IsHolding = false
            ShootSystem.CurrentTarget = nil
            ShootSystem.LastShootTime = 0
            ShootSystem.TwoPhasePhase = 1
            
            task.spawn(function()
                getAttackEvent() -- Pre-cache event
                task.wait(1)
                if ShootSystem.Running then
                    startLoop()
                end
            end)
        else
            cleanup()
        end
    end
})

Section = Tab:AddSection({
 Name = "Hitbox Stuff"
})

-- Sword Hitbox Size Controller
local SwordHitboxController = {
    Players = game:GetService("Players"),
    RunService = game:GetService("RunService"),
    
    Player = nil,
    
    -- Control variables
    isAutoSetHitbox = false,
    hitboxSize = 10,
    selectedSword = "Classic Sword",
    
    -- Threads
    hitboxUpdateThread = nil,
    
    -- Sword names list
    swordNames = {
        "Balloon Sword",
        "Classic Sword", 
        "Lamppost",
        "King Slayer",
        "Pine Tree",
        "Soulreaper",
        "Billboard"
    }
}

-- Initialize
SwordHitboxController.Player = SwordHitboxController.Players.LocalPlayer

-- Function to safely stop threads
function SwordHitboxController:stopThread(thread)
    if thread then
        task.cancel(thread)
        return nil
    end
    return nil
end

-- Function to find sword tool in backpack
function SwordHitboxController:findSwordTool()
    if not self.Player then return nil end
    
    -- Check backpack
    local backpack = self.Player:FindFirstChild("Backpack")
    if not backpack then return nil end
    
    -- Look for the selected sword
    local swordTool = backpack:FindFirstChild(self.selectedSword)
    if not swordTool then
        -- Try alternative names (case insensitive)
        for _, tool in pairs(backpack:GetChildren()) do
            if tool:IsA("Tool") and tool.Name:lower() == self.selectedSword:lower() then
                return tool
            end
        end
    end
    
    return swordTool
end

-- Function to find sword tool if equipped in character
function SwordHitboxController:findEquippedSword()
    local character = self.Player.Character
    if not character then return nil end
    
    -- Look for the selected sword in character
    local swordTool = character:FindFirstChild(self.selectedSword)
    if not swordTool then
        -- Try alternative names (case insensitive)
        for _, tool in pairs(character:GetChildren()) do
            if tool:IsA("Tool") and tool.Name:lower() == self.selectedSword:lower() then
                return tool
            end
        end
    end
    
    return swordTool
end

-- Function to update sword hitbox size
function SwordHitboxController:updateSwordHitbox()
    local swordTool = self:findSwordTool() or self:findEquippedSword()
    
    if not swordTool then
        return false
    end
    
    local updated = false
    
    -- Look for BaseParts inside the sword tool
    for _, descendant in pairs(swordTool:GetDescendants()) do
        if descendant:IsA("BasePart") then
            -- Check if this part is likely a hitbox (not decorative)
            -- Common hitbox names or large parts
            if descendant.Name:lower():find("hit") or 
               descendant.Name:lower():find("box") or
               descendant.Name:lower():find("blade") or
               descendant.Name:lower():find("sword") or
               descendant.Name:lower():find("handle") or
               descendant.Name:lower():find("part") or
               descendant.Size.Magnitude > 5 then  -- If it's a significant sized part
                
                -- Apply the hitbox size
                descendant.Size = Vector3.new(self.hitboxSize, self.hitboxSize, self.hitboxSize)
                updated = true
                
                -- Optional: Make hitbox transparent and visible for debugging
                if descendant.Transparency < 0.5 then
                    descendant.Transparency = 0.7
                    descendant.Material = Enum.Material.Neon
                    descendant.Color = Color3.new(1, 0, 0) -- Red for visibility
                end
            end
        end
    end
    
    return updated
end

-- Main function to auto-set hitbox
function SwordHitboxController:autoSetHitbox()
    while self.isAutoSetHitbox do
        if self.isAutoSetHitbox then
            local success, result = pcall(function()
                return self:updateSwordHitbox()
            end)
            
            if success and result then
                -- Optional: Show notification on first successful update
                if not self.hasShownSuccess then
                    self.hasShownSuccess = true
                    task.spawn(function()
                        OrionLib:MakeNotification({
                            Name = "Hitbox",
                            Content = "Hitbox updated to size: " .. self.hitboxSize,
                            Image = "rbxassetid://4483345998",
                            Time = 2
                        })
                    end)
                end
            elseif not success then
                -- Error occurred
                warn("Error updating hitbox:", result)
            end
        end
        
        -- Wait before next update
        task.wait(0.5)
    end
end

-- Function to stop auto-set
function SwordHitboxController:stopAutoSet()
    self.isAutoSetHitbox = false
    self.hasShownSuccess = false
    
    if self.hitboxUpdateThread then
        self:stopThread(self.hitboxUpdateThread)
        self.hitboxUpdateThread = nil
    end
end

-- Function to start auto-set
function SwordHitboxController:startAutoSet()
    self:stopAutoSet()
    self.isAutoSetHitbox = true
    self.hasShownSuccess = false
    
    self.hitboxUpdateThread = task.spawn(function()
        SwordHitboxController:autoSetHitbox()
    end)
end

-- Monitor for tool changes
SwordHitboxController.Player.CharacterAdded:Connect(function()
    -- Restart auto-set if it was active
    task.wait(1)
    if SwordHitboxController.isAutoSetHitbox then
        SwordHitboxController:startAutoSet()
    end
end)

-- Slider for Hitbox Size
Tab:AddSlider({
    Name = "Hitbox Size",
    Min = 1,
    Max = 1000,
    Default = 10,
    Increment = 1,
    ValueName = "studs",
    Callback = function(value)
        SwordHitboxController.hitboxSize = value
        
        -- If auto-set is active, update immediately
        if SwordHitboxController.isAutoSetHitbox then
            SwordHitboxController:updateSwordHitbox()
        end
    end
})

-- Dropdown for Sword Selection
Tab:AddDropdown({
    Name = "Choose Your Sword",
    Default = "Classic Sword",
    Options = SwordHitboxController.swordNames,
    Callback = function(value)
        SwordHitboxController.selectedSword = value
        
        -- If auto-set is active, update immediately
        if SwordHitboxController.isAutoSetHitbox then
            SwordHitboxController:updateSwordHitbox()
        end
    end
})

Tab:AddToggle({
    Name = "Auto Set Sword's Hitbox",
    Default = false,
    Callback = function(value)
        if value then
            -- ... code ...
            SwordHitboxController:startAutoSet()
            -- Only show success notification, not disable notification
        else
            SwordHitboxController:stopAutoSet()
            -- Don't show "disabled" notification
        end
    end
})

-- Manual update button
Tab:AddButton({
    Name = "Manual Update Hitbox",
    Callback = function()
        local swordTool = SwordHitboxController:findSwordTool() or SwordHitboxController:findEquippedSword()
        
        if not swordTool then
            OrionLib:MakeNotification({
                Name = "Error",
                Content = SwordHitboxController.selectedSword .. " not found!",
                Image = "rbxassetid://7743878857",
                Time = 3
            })
            return
        end
        
        local updated = SwordHitboxController:updateSwordHitbox()
        
        if updated then
            OrionLib:MakeNotification({
                Name = "Hitbox Updated",
                Content = "Hitbox size set to " .. SwordHitboxController.hitboxSize .. " for " .. SwordHitboxController.selectedSword,
                Image = "rbxassetid://4483345998",
                Time = 3
            })
        else
            OrionLib:MakeNotification({
                Name = "Warning",
                Content = "No BaseParts found to update in " .. SwordHitboxController.selectedSword,
                Image = "rbxassetid://7743878857",
                Time = 3
            })
        end
    end
})

-- Reset hitbox button (restore original sizes)
Tab:AddButton({
    Name = "Reset Hitbox Sizes",
    Callback = function()
        -- Store original sizes first (this would need to be tracked from the start)
        -- For now, just stop auto-set and notify
        SwordHitboxController:stopAutoSet()
        
        OrionLib:MakeNotification({
            Name = "Hitbox Reset",
            Content = "Hitbox auto-set stopped. Restart game for original size.",
            Image = "rbxassetid://4483345998",
            Time = 3
        })
    end
})

Section = Tab:AddSection({
 Name = "Spinner Stuff"
})

-- Spin/Unspin System
local SpinController = {
    spinSpeed = 20,
    isSpinning = false,
    currentSpinObject = nil
}

-- Function to safely get the root part
local function getRoot(character)
    if character and character:IsA("Model") then
        return character:FindFirstChild("HumanoidRootPart") or 
               character:FindFirstChild("Torso") or 
               character:FindFirstChild("UpperTorso")
    end
    return nil
end

-- Function to check if string is a number
local function isNumber(str)
    return tonumber(str) ~= nil
end

-- Function to start spinning
local function startSpin(speaker)
    if SpinController.isSpinning then
        OrionLib:MakeNotification({
            Name = "Spin",
            Content = "Already spinning!",
            Image = "rbxassetid://7743878857",
            Time = 2
        })
        return
    end
    
    local character = speaker.Character
    if not character then
        OrionLib:MakeNotification({
            Name = "Error",
            Content = "Character not found!",
            Image = "rbxassetid://7743878857",
            Time = 2
        })
        return
    end
    
    local root = getRoot(character)
    if not root then
        OrionLib:MakeNotification({
            Name = "Error",
            Content = "Root part not found!",
            Image = "rbxassetid://7743878857",
            Time = 2
        })
        return
    end
    
    -- Remove any existing spin objects
    for _, v in pairs(root:GetChildren()) do
        if v.Name == "Spinning" then
            v:Destroy()
        end
    end
    
    -- Create new spin object
    local Spin = Instance.new("BodyAngularVelocity")
    Spin.Name = "Spinning"
    Spin.Parent = root
    Spin.MaxTorque = Vector3.new(0, math.huge, 0)
    Spin.AngularVelocity = Vector3.new(0, SpinController.spinSpeed, 0)
    
    SpinController.currentSpinObject = Spin
    SpinController.isSpinning = true
    
    OrionLib:MakeNotification({
        Name = "Spin",
        Content = "Started spinning at speed: " .. SpinController.spinSpeed,
        Image = "rbxassetid://4483345998",
        Time = 3
    })
end

-- Function to stop spinning
local function stopSpin(speaker)
    if not SpinController.isSpinning then
        OrionLib:MakeNotification({
            Name = "Spin",
            Content = "Not currently spinning!",
            Image = "rbxassetid://7743878857",
            Time = 2
        })
        return
    end
    
    local character = speaker.Character
    if not character then
        SpinController.isSpinning = false
        SpinController.currentSpinObject = nil
        return
    end
    
    local root = getRoot(character)
    if root then
        -- Remove any spin objects
        for _, v in pairs(root:GetChildren()) do
            if v.Name == "Spinning" then
                v:Destroy()
            end
        end
    end
    
    SpinController.currentSpinObject = nil
    SpinController.isSpinning = false
    
    OrionLib:MakeNotification({
        Name = "Spin",
        Content = "Stopped spinning",
        Image = "rbxassetid://4483345998",
        Time = 3
    })
end

-- Auto stop spinning on character death/change
game.Players.LocalPlayer.CharacterAdded:Connect(function()
    if SpinController.isSpinning then
        SpinController.isSpinning = false
        SpinController.currentSpinObject = nil
    end
end)

game.Players.LocalPlayer.CharacterRemoving:Connect(function()
    if SpinController.isSpinning then
        SpinController.isSpinning = false
        SpinController.currentSpinObject = nil
    end
end)

-- Textbox for spin speed (numbers only)
Tab:AddTextbox({
    Name = "Spin Speed",
    Default = "20",
    TextDisappear = false,
    Callback = function(Text)
        if isNumber(Text) then
            local speed = tonumber(Text)
            if speed > 0 then
                SpinController.spinSpeed = speed
                OrionLib:MakeNotification({
                    Name = "Spin Speed",
                    Content = "Spin speed set to: " .. speed,
                    Image = "rbxassetid://4483345998",
                    Time = 2
                })
                
                -- Update spin speed if currently spinning
                if SpinController.isSpinning and SpinController.currentSpinObject then
                    SpinController.currentSpinObject.AngularVelocity = Vector3.new(0, speed, 0)
                end
            else
                OrionLib:MakeNotification({
                    Name = "Error",
                    Content = "Spin speed must be greater than 0!",
                    Image = "rbxassetid://7743878857",
                    Time = 3
                })
            end
        else
            OrionLib:MakeNotification({
                Name = "Error",
                Content = "Please enter a valid number!",
                Image = "rbxassetid://7743878857",
                Time = 3
            })
        end
    end
})

-- Button to start spinning
Tab:AddButton({
    Name = "Spin",
    Callback = function()
        startSpin(game.Players.LocalPlayer)
    end
})

-- Button to stop spinning
Tab:AddButton({
    Name = "Unspin",
    Callback = function()
        stopSpin(game.Players.LocalPlayer)
    end
})

-- Status indicator
local spinStatusParagraph = Tab:AddParagraph("Spin Status:", "Not spinning")
Tab:AddToggle({
    Name = "Auto Update Spin Status",
    Default = false,
    Callback = function(value)
        if value then
            local connection
            connection = game:GetService("RunService").Heartbeat:Connect(function()
                if SpinController.isSpinning then
                    spinStatusParagraph:Set("Spin Status: Spinning at speed " .. SpinController.spinSpeed)
                else
                    spinStatusParagraph:Set("Spin Status: Not spinning")
                end
            end)
            
            -- Store connection to disconnect later
            game:GetService("Players").LocalPlayer:GetPropertyChangedSignal("Character"):Connect(function()
                if connection then
                    connection:Disconnect()
                end
            end)
        end
    end
})

Section = Tab:AddSection({
 Name = "Rest/Others Feature"
})

-- Variables to manage teleportation
_G.isTeleporting = false
local teleportCoroutine

-- Function to stop the teleport loop
local function stopTeleporting()
    isTeleporting = false  -- Stop teleporting
end

-- Function to teleport the player to a random NPC in the NPCFolder
local function teleportToRandomNPC()
    if isTeleporting then return end  -- Prevent starting multiple loops

    isTeleporting = true

    teleportCoroutine = coroutine.create(function()
        while isTeleporting do
            local npcFolder = workspace:WaitForChild("#GAME"):WaitForChild("Folders"):WaitForChild("VisibleInstances"):WaitForChild("HumanoidFolder"):WaitForChild("NPCFolder")
            local npcs = {}

            for _, npc in pairs(npcFolder:GetChildren()) do
                if npc:IsA("Model") and npc:FindFirstChild("HumanoidRootPart") then
                    table.insert(npcs, npc)
                end
            end

            if #npcs > 0 then
                local randomNPC = npcs[math.random(1, #npcs)]
                local npcPosition = randomNPC.HumanoidRootPart.Position
                local character = game.Players.LocalPlayer.Character
                if character and character:FindFirstChild("HumanoidRootPart") then
                    character:SetPrimaryPartCFrame(CFrame.new(npcPosition + Vector3.new(0, 5, 0))) -- teleport 5 studs above to prevent collision
                end
            end

            task.wait(0.2)
        end
    end)

    coroutine.resume(teleportCoroutine)
end

-- Toggle setup
Tab:AddToggle({
    Name = "Auto Teleport To NPC's",
    Default = false,
    Callback = function(Value)
        if Value then
            teleportToRandomNPC()
        else
            stopTeleporting()
        end
    end
})

-- Variables to manage auto using the sword
_G.isUsingSword = false
local swordConnection

-- List of all swords to auto use
local swordList = {
    "Balloon Sword",
    "Classic Sword", 
    "Lamppost",
    "King Slayer",
    "Pine Tree",
    "Soulreaper",
    "Billboard"
}

-- Function to start auto using the sword every 0.1 seconds
local function autoUseSword()
    if isUsingSword then return end  -- Prevent starting multiple loops

    isUsingSword = true

    swordConnection = game:GetService("RunService").Heartbeat:Connect(function()
        local player = game.Players.LocalPlayer
        local character = player.Character
        if not character then return end

        -- Check both character and backpack for all swords in the list
        local foundSword = nil
        
        for _, swordName in ipairs(swordList) do
            local sword = character:FindFirstChild(swordName) or player.Backpack:FindFirstChild(swordName)
            if sword then
                foundSword = sword
                break  -- Use the first sword found
            end
        end

        -- If a sword was found, activate it
        if foundSword then
            -- Make sure sword is equipped before activating
            if foundSword.Parent == player.Backpack then
                foundSword.Parent = character
            end
            
            -- Use mouse event simulation for activation
            local tool = foundSword
            if tool:IsA("Tool") then
                -- Simulate mouse click for tool activation
                tool:Activate()
                -- Alternative activation methods
                pcall(function()
                    tool:InvokeServer("Activate")
                end)
                pcall(function()
                    -- Try different activation methods
                    tool:InvokeServer("MouseClick")
                end)
                pcall(function()
                    tool:InvokeServer("Click")
                end)
            end
        end
    end)
end

-- Function to stop auto using the sword
local function stopAutoUsingSword()
    isUsingSword = false
    if swordConnection then
        swordConnection:Disconnect()
        swordConnection = nil
    end
end

Tab:AddToggle({
    Name = "Auto Use Sword",
    Default = false,
    Callback = function(Value)
        if Value then
            -- Start using the sword if toggle is enabled
            autoUseSword()
        else
            -- Stop the loop if the toggle is disabled
            stopAutoUsingSword()
        end
    end
})

-- Variables to manage auto using the sword
_G.isUsingHatred = false
local HatredConnection

-- List of all swords to auto use
local HatredList = {
    "Hatred"
}

-- Function to start auto using the sword every 0.1 seconds
local function autoUseHatred()
    if isUsingHatred then return end  -- Prevent starting multiple loops

    isUsingHatred = true

    HatredConnection = game:GetService("RunService").Heartbeat:Connect(function()
        local player = game.Players.LocalPlayer
        local character = player.Character
        if not character then return end

        -- Check both character and backpack for all swords in the list
        local foundHatred = nil
        
        for _, hatredName in ipairs(HatredList) do
            local hatred = character:FindFirstChild(hatredName) or player.Backpack:FindFirstChild(hatredName)
            if hatred then
                foundHatred = hatred
                break  -- Use the first sword found
            end
        end

        -- If a sword was found, activate it
        if foundHatred then
            -- Make sure sword is equipped before activating
            if foundHatred.Parent == player.Backpack then
                foundHatred.Parent = character
            end
            
            -- Use mouse event simulation for activation
            local tool = foundHatred
            if tool:IsA("Tool") then
                -- Simulate mouse click for tool activation
                tool:Activate()
                -- Alternative activation methods
                pcall(function()
                    tool:InvokeServer("Activate")
                end)
                pcall(function()
                    -- Try different activation methods
                    tool:InvokeServer("MouseClick")
                end)
                pcall(function()
                    tool:InvokeServer("Click")
                end)
            end
        end
    end)
end

-- Function to stop auto using the sword
local function stopAutoUsingHatred()
    isUsingHatred = false
    if HatredConnection then
        HatredConnection:Disconnect()
        HatredConnection = nil
    end
end

Tab:AddToggle({
    Name = "Auto Use Hatred Tool",
    Default = false,
    Callback = function(Value)
        if Value then
            -- Start using the sword if toggle is enabled
            autoUseHatred()
        else
            -- Stop the loop if the toggle is disabled
            stopAutoUsingHatred()
        end
    end
})

-- Variables to manage the teleporting state (using local instead of _G)
local isBringing = false
local bringCoroutine = nil
local bringConnection = nil
local player = game.Players.LocalPlayer

-- Cache for NPC folder to reduce WaitForChild calls
local npcFolderCache = nil
local lastFolderCheck = 0

-- Function to get NPC folder with caching
local function getNPCFolder()
    local currentTime = tick()
    if npcFolderCache and (currentTime - lastFolderCheck) < 5 then
        return npcFolderCache
    end
    
    local success, folder = pcall(function()
        return workspace:WaitForChild("#GAME"):WaitForChild("Folders"):WaitForChild("VisibleInstances"):WaitForChild("HumanoidFolder"):WaitForChild("NPCFolder")
    end)
    
    if success and folder then
        npcFolderCache = folder
        lastFolderCheck = currentTime
        return folder
    end
    
    -- Alternative path check
    success, folder = pcall(function()
        return workspace:WaitForChild("GAME"):WaitForChild("Folders"):WaitForChild("VisibleInstances"):WaitForChild("HumanoidFolder"):WaitForChild("NPCFolder")
    end)
    
    if success and folder then
        npcFolderCache = folder
        lastFolderCheck = currentTime
        return folder
    end
    
    -- Last resort: search for folder
    for _, child in pairs(workspace:GetDescendants()) do
        if child.Name == "NPCFolder" and child:IsA("Folder") then
            npcFolderCache = child
            lastFolderCheck = currentTime
            return child
        end
    end
    
    return nil
end

-- Function to teleport the NPCs to the player in front of them (excluding CrackedBas)
local function bringNoobsAndWerewolves()
    -- Prevent starting multiple loops
    if isBringing then return end
    isBringing = true

    local runService = game:GetService("RunService")
    
    bringCoroutine = task.spawn(function()
        local folder = getNPCFolder()
        if not folder then
            warn("Auto Bring: Could not find NPC folder!")
            isBringing = false
            return
        end
        
        print("Auto Bring: Started teleporting NPCs")
        
        while isBringing do
            local character = player.Character
            if character and character.PrimaryPart then
                local humanoidRootPart = character.PrimaryPart
                local direction = humanoidRootPart.CFrame.LookVector
                
                -- Get all NPCs once per loop
                local npcs = folder:GetChildren()
                local teleportCount = 0
                
                for _, npc in ipairs(npcs) do
                    if not isBringing then break end
                    
                    -- Check if NPC is a Model, has PrimaryPart or HumanoidRootPart, and is NOT named "CrackedBas"
                    if npc:IsA("Model") and (npc.PrimaryPart or npc:FindFirstChild("HumanoidRootPart")) and 
                       not string.find(npc.Name:lower(), "crackedbas") then
                        
                        local targetPart = npc.PrimaryPart or npc:FindFirstChild("HumanoidRootPart")
                        if targetPart then
                            -- Teleport the NPC to a point in front of the player
                            local offsetX = (teleportCount % 5) * 4  -- Spread NPCs horizontally
                            local offsetZ = math.floor(teleportCount / 5) * 4  -- Spread NPCs in rows
                            
                            local newPosition = humanoidRootPart.Position + 
                                                (direction * 15) +  -- 15 studs in front
                                                (humanoidRootPart.CFrame.RightVector * offsetX) + 
                                                (humanoidRootPart.CFrame.LookVector * offsetZ)
                            
                            -- Set the new position for the NPC
                            pcall(function()
                                npc:SetPrimaryPartCFrame(CFrame.new(newPosition))
                            end)
                            
                            teleportCount = teleportCount + 1
                            
                            -- Small delay every 5 NPCs to prevent lag
                            if teleportCount % 5 == 0 then
                                task.wait()
                            end
                        end
                    end
                end
                
                if teleportCount > 0 then
                    -- Update counter for UI (if implemented)
                end
            end
            
            -- Wait for next frame
            runService.Heartbeat:Wait()
        end
        
        print("Auto Bring: Stopped teleporting NPCs")
    end)
end

-- Function to stop the teleporting loop
local function stopBringing()
    isBringing = false
    
    if bringCoroutine then
        task.cancel(bringCoroutine)
        bringCoroutine = nil
    end
    
    -- Clean up any pending tasks
    task.wait(0.1)
end

-- Function to handle character respawns
local function onCharacterAdded(character)
    if isBringing then
        -- Wait a bit for character to fully load
        task.wait(1)
        -- Restart the bringing process
        stopBringing()
        task.wait(0.5)
        bringNoobsAndWerewolves()
    end
end

-- Function to cleanup connections
local function cleanupBring()
    stopBringing()
    
    if bringConnection then
        bringConnection:Disconnect()
        bringConnection = nil
    end
end

-- Cleanup when player leaves or script ends
player.CharacterRemoving:Connect(function()
    if isBringing then
        stopBringing()
    end
end)

game:GetService("Players").PlayerRemoving:Connect(function(leavingPlayer)
    if leavingPlayer == player then
        cleanupBring()
    end
end)

Tab:AddToggle({
    Name = "Auto Bring NPC's",
    Default = false,
    Callback = function(Value)
        if Value then
            bringConnection = player.CharacterAdded:Connect(onCharacterAdded)
            bringNoobsAndWerewolves()
        else
            cleanupBring()
        end
    end
})

-- Auto Delete Models Controller
local AutoDeleteController = {
    Workspace = game:GetService("Workspace"),
    RunService = game:GetService("RunService"),
    
    -- Control variables
    isAutoDeleteModels = false,
    
    -- Threads
    deleteThread = nil
}

-- Function to safely stop threads
function AutoDeleteController:stopThread(thread)
    if thread then
        task.cancel(thread)
        return nil
    end
    return nil
end

-- Function to find and delete all Models in NPCFolder
function AutoDeleteController:deleteAllModels()
    local success, result = pcall(function()
        -- Try to find the NPCFolder using the full path
        local gameFolder = self.Workspace:FindFirstChild("#GAME")
        if not gameFolder then 
            warn("Game folder not found")
            return 0 
        end
        
        local foldersFolder = gameFolder:FindFirstChild("Folders")
        if not foldersFolder then 
            warn("Folders folder not found")
            return 0 
        end
        
        local visibleInstances = foldersFolder:FindFirstChild("VisibleInstances")
        if not visibleInstances then 
            warn("VisibleInstances folder not found")
            return 0 
        end
        
        local humanoidFolder = visibleInstances:FindFirstChild("HumanoidFolder")
        if not humanoidFolder then 
            warn("HumanoidFolder not found")
            return 0 
        end
        
        local npcFolder = humanoidFolder:FindFirstChild("NPCFolder")
        if not npcFolder then 
            warn("NPCFolder not found")
            return 0 
        end
        
        print("Found NPCFolder at: workspace[\"#GAME\"].Folders.VisibleInstances.HumanoidFolder.NPCFolder")
        
        local deletedCount = 0
        
        -- Get all children first to avoid iteration issues
        local children = npcFolder:GetChildren()
        print("Found " .. #children .. " items in NPCFolder")
        
        for _, child in ipairs(children) do
            if not self.isAutoDeleteModels then break end
            
            if child:IsA("Model") then
                print("Deleting model: " .. child.Name)
                
                -- Safe delete with pcall
                local deleteSuccess = pcall(function()
                    child:Destroy()
                end)
                
                if deleteSuccess then
                    deletedCount = deletedCount + 1
                else
                    warn("Failed to delete model: " .. child.Name)
                end
            end
            
            -- Small yield every 10 models to prevent freezing
            if deletedCount % 10 == 0 then
                task.wait()
            end
        end
        
        return deletedCount
    end)
    
    if success then
        return result
    else
        warn("Error deleting models:", result)
        return 0
    end
end

-- Function to check if the NPCFolder path exists
function AutoDeleteController:checkPathExists()
    local success, exists = pcall(function()
        local gameFolder = self.Workspace:FindFirstChild("#GAME")
        if not gameFolder then return false end
        
        local foldersFolder = gameFolder:FindFirstChild("Folders")
        if not foldersFolder then return false end
        
        local visibleInstances = foldersFolder:FindFirstChild("VisibleInstances")
        if not visibleInstances then return false end
        
        local humanoidFolder = visibleInstances:FindFirstChild("HumanoidFolder")
        if not humanoidFolder then return false end
        
        local npcFolder = humanoidFolder:FindFirstChild("NPCFolder")
        if not npcFolder then return false end
        
        return true
    end)
    
    return success and exists
end

-- Main function to auto delete models
function AutoDeleteController:autoDeleteModels()
    while self.isAutoDeleteModels do
        if self.isAutoDeleteModels then
            local deletedCount = self:deleteAllModels()
            
            -- Show notification if models were deleted
            if deletedCount > 0 and self.isAutoDeleteModels then
                task.spawn(function()
                    OrionLib:MakeNotification({
                        Name = "Models Deleted",
                        Content = "Deleted " .. deletedCount .. " models from NPCFolder",
                        Image = "rbxassetid://7733715400",
                        Time = 1
                    })
                end)
            end
            
            -- Wait before next deletion cycle
            task.wait(0.2)
        end
    end
end

-- Function to stop auto delete
function AutoDeleteController:stopAutoDelete()
    self.isAutoDeleteModels = false
    
    if self.deleteThread then
        self:stopThread(self.deleteThread)
        self.deleteThread = nil
    end
end

-- Function to start auto delete
function AutoDeleteController:startAutoDelete()
    self:stopAutoDelete()
    
    -- Check if path exists first
    if not self:checkPathExists() then
        OrionLib:MakeNotification({
            Name = "Path Not Found",
            Content = "NPCFolder path does not exist!",
            Image = "rbxassetid://7743878857",
            Time = 3
        })
        return
    end
    
    self.isAutoDeleteModels = true
    
    self.deleteThread = task.spawn(function()
        AutoDeleteController:autoDeleteModels()
    end)
end

-- Cleanup when game closes
game:GetService("Players").PlayerRemoving:Connect(function(player)
    if player == game.Players.LocalPlayer then
        AutoDeleteController:stopAutoDelete()
    end
end)

-- Toggle for Auto Delete Models
Tab:AddToggle({
    Name = "Auto Delete All NPC's",
    Default = false,
    Callback = function(value)
        if value then
            -- Start auto delete
            AutoDeleteController:startAutoDelete()
        else
            -- Stop auto delete
            AutoDeleteController:stopAutoDelete()
        end
    end
})

local RunService = game:GetService("RunService")
local Workspace = game:GetService("Workspace")

-- State variables
local spawnLoopConnection = nil
local isSpawningEnabled = false

-- Function to start the spawning loop
local function startSpawningLoop()
    if spawnLoopConnection then
        spawnLoopConnection:Disconnect()
        spawnLoopConnection = nil
    end
    
    spawnLoopConnection = RunService.Heartbeat:Connect(function()
        if not isSpawningEnabled then
            spawnLoopConnection:Disconnect()
            spawnLoopConnection = nil
            return
        end
        
        local success, error = pcall(function()
            workspace:WaitForChild("#GAME"):WaitForChild("Globals"):WaitForChild("Comms"):WaitForChild("Remote"):WaitForChild("Functions"):WaitForChild("SpawnNoobOnPad"):InvokeServer()
        end)
        
        if not success then
            warn("Failed to spawn noob:", error)
            isSpawningEnabled = false
            spawnLoopConnection:Disconnect()
            spawnLoopConnection = nil
        end
        
        task.wait(0.01) -- Wait 0.01 seconds between invocations
    end)
end

-- Function to stop the spawning loop
local function stopSpawningLoop()
    isSpawningEnabled = false
    if spawnLoopConnection then
        spawnLoopConnection:Disconnect()
        spawnLoopConnection = nil
    end
end

-- Create the toggle
Tab:AddToggle({
    Name = "Auto Spawn Noobs From Pad",
    Default = false,
    Callback = function(Value)
        isSpawningEnabled = Value
        
        if Value then
            -- Start the spawning loop
            task.spawn(function()
                startSpawningLoop()
            end)
        else
            -- Stop the spawning loop
            stopSpawningLoop()
        end
    end
})

Section = Tab:AddSection({
 Name = "Auto Teleport/Collect/Click Stuff"
})

-- Egg Collection System (Optimized for Auto Teleport)
local EggSystem = {
    Workspace = game:GetService("Workspace"),
    Players = game:GetService("Players"),
    RunService = game:GetService("RunService"),
    VirtualInputManager = game:GetService("VirtualInputManager"),
    
    Player = nil,
    
    -- Feature toggles
    isAutoSetHoldDuration = false,
    isTeleportToEggs = false,
    isAutoSpamKey = false,
    
    -- Threads
    autoSetHoldDurationThread = nil,
    teleportToEggsThread = nil,
    spamKeyThread = nil,
    
    -- Performance optimization
    cachedEggPrompts = {},
    cachedEggs = {},
    lastScanTime = 0,
    SCAN_INTERVAL = 0.1,
    lastTeleportTime = 0,
    TELEPORT_COOLDOWN = 0.01,
    lastPromptTime = 0,
    PROMPT_COOLDOWN = 0.01,
    
    -- Performance monitoring
    frameCount = 0,
    lastFPSUpdate = tick(),
    currentFPS = 60
}

-- Initialize
EggSystem.Player = EggSystem.Players.LocalPlayer

-- Exact egg names from the list (only these will be collected)
local VALID_EGG_NAMES = {
    -- Small/Big variants
    "Basic Egg",
    "Small Egg",
    "Smaller Egg",
    "Smallest Egg",
    "Fat Egg",
    "Fatter Egg",
    "Fattest Egg",
    "Tall Egg",
    "Taller Egg",
    "Tallest Egg",
    "Big Egg",
    "Baby Egg",
    "Bomb Egg",
    "Skinny Egg",
    "Squished Egg",
    "Paper Egg",
    "Squashed Egg",
    "Wide Egg",
    "Flying Egg",
    "Zombie Egg",
    "Mega Egg",
    "Nuke Egg",
    "Bombarder Egg",
    "Dark Egg",
    "Micro Egg",
    "OOOOOOMEGA Egg",
    "Poop Egg",
    
    -- Precious metal eggs
    "Silver Egg",
    "Golden Egg",
    "Diamond Egg",
    "Emerald Egg",
    "Ruby Egg",
    "Amethyst Egg",
    
    -- Bigger variants
    "Bigger Egg",
    "Biggest Egg",
    "Biggest Bigger Egg",
    "Biggester Egg",
    "Monster Egg",
    "Enraged Egg",
    "Rock Egg",
    "Nasty Egg",
    "Moai Egg",
    "Cracked Egg",
    "Bas Egg",
    "Raffie Egg",
    "Ghost Egg",
    "BULLKER Egg",
    "Pouwker Egg",
    "Berend Egg",
    "Chicken Egg",
    
    -- BOSS and special
    "BOSS Egg",
    "Delicious Egg",
    "Burnt Egg",
    "OOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOMEGAAAAAAAAAAAAHHHHHHHHHHHH Egg",
    "Dead Egg",
    "Hellfire Egg",
    "Invincible Egg",
    "Invisible Egg",
    "Metal Egg",
    "Santa Egg",
    "Für Egg",
    "Rotten Egg",
    "SigmaBloxian Egg",
    "Stinky Egg",
    "Jack Egg",
    "Buoyant Egg",
    "Primo Egg",
    "Werewolf Egg",
    "Boeman Egg",
    "Mighty Egg",
    "Old Egg",
    "Bacon Egg",
    "Ginger Egg",
    "Headless Egg",
    "Skeleton Egg",
    "Elf Egg",
    "Pouwk Egg",
    "BULL Egg",
    "Turd Egg",
    "Co Egg",
    "Nano Egg",
    "Not Egg",
    "R6 Egg",
    "Bunny Egg",
    "Banana Egg",
    "Bananade Egg",
    "Glitch Egg",
    "Error Egg",
    "Jumperino Egg",
    "Cheese Egg",
    "Greasy Egg",
    "Rusty Egg",
    "Hateful Egg",
    "Happy Egg",
    "Party Egg",
    "Yoss Egg",
    "Cato Egg",
    "Noob Egg"
}

-- Create a lookup table for faster checking
local VALID_EGG_LOOKUP = {}
for _, eggName in ipairs(VALID_EGG_NAMES) do
    VALID_EGG_LOOKUP[eggName] = true
end

-- Function to check if object is a REAL egg (exact name match only)
function EggSystem:isValidEgg(obj)
    if not obj or not obj.Parent then
        return false
    end
    
    local isValidType = obj:IsA("BasePart") or obj:IsA("Model") or obj:IsA("MeshPart")
    if not isValidType then
        return false
    end
    
    -- Check if the exact name is in our list
    if VALID_EGG_LOOKUP[obj.Name] then
        return true
    end
    
    return false
end

-- Function to monitor FPS and adjust performance
function EggSystem:monitorPerformance()
    self.frameCount = self.frameCount + 1
    local currentTime = tick()
    
    if currentTime - self.lastFPSUpdate >= 1 then
        self.currentFPS = self.frameCount
        self.frameCount = 0
        self.lastFPSUpdate = currentTime
        
        if self.currentFPS < 30 then
            self.SCAN_INTERVAL = 0.5
            self.TELEPORT_COOLDOWN = 0.02
        else
            self.SCAN_INTERVAL = 0.1
            self.TELEPORT_COOLDOWN = 0.01
        end
    end
end

-- Function to safely stop threads
function EggSystem:stopThread(thread)
    if thread then
        task.cancel(thread)
        return nil
    end
    return nil
end

-- Function to get valid egg position (checks if egg still exists)
function EggSystem:getValidEggPosition(egg)
    if not egg or not egg.Parent then
        return nil
    end
    
    local success, position = pcall(function()
        if egg:IsA("Model") then
            if egg.PrimaryPart and egg.PrimaryPart.Parent then
                return egg.PrimaryPart.Position
            else
                local firstPart = egg:FindFirstChildWhichIsA("BasePart")
                if firstPart and firstPart.Parent then
                    return firstPart.Position
                end
            end
        else
            -- MeshPart or BasePart
            if egg.Parent then
                return egg.Position
            end
        end
        return nil
    end)
    
    return success and position or nil
end

-- FAST function to get fresh eggs from GeneralFolder
function EggSystem:getFreshEggs()
    self.cachedEggs = {}
    
    local generalFolder = self.Workspace:FindFirstChild("#GAME") and 
                         self.Workspace["#GAME"]:FindFirstChild("Folders") and 
                         self.Workspace["#GAME"].Folders:FindFirstChild("GeneralFolder")
    
    if generalFolder then
        -- Fast scan through all children
        for _, egg in pairs(generalFolder:GetChildren()) do
            if self:isValidEgg(egg) then -- Use the new isValidEgg function
                local position = self:getValidEggPosition(egg)
                if position then
                    table.insert(self.cachedEggs, {
                        object = egg,
                        position = position,
                        name = egg.Name
                    })
                end
            end
        end
    end
    
    self.lastScanTime = tick()
    return self.cachedEggs
end

-- OPTIMIZED: Function to get ProximityPrompts without lag
function EggSystem:getEggProximityPrompts()
    local currentTime = tick()
    
    -- Only rescan if cache is empty or enough time has passed
    if #self.cachedEggPrompts == 0 or (currentTime - self.lastScanTime) > 5.0 then
        self.cachedEggPrompts = {}
        
        -- Only scan GeneralFolder
        local generalFolder = self.Workspace:FindFirstChild("#GAME") and 
                             self.Workspace["#GAME"]:FindFirstChild("Folders") and 
                             self.Workspace["#GAME"].Folders:FindFirstChild("GeneralFolder")
        
        if generalFolder then
            -- Limit scanning to prevent lag
            local scanCount = 0
            for _, egg in pairs(generalFolder:GetChildren()) do
                if scanCount > 50 then break end -- Safety limit
                
                if self:isValidEgg(egg) then -- Use the new isValidEgg function
                    -- Only check first few descendants to prevent lag
                    local prompt = egg:FindFirstChildWhichIsA("ProximityPrompt")
                    if prompt and prompt.Parent then
                        table.insert(self.cachedEggPrompts, prompt)
                    else
                        -- Quick check for prompts in descendants (limited)
                        local descendants = egg:GetDescendants()
                        for i = 1, math.min(10, #descendants) do -- Limit to 10 descendants
                            local descendant = descendants[i]
                            if descendant:IsA("ProximityPrompt") then
                                table.insert(self.cachedEggPrompts, descendant)
                                break -- Only need one prompt per egg
                            end
                        end
                    end
                    scanCount = scanCount + 1
                end
            end
        end
        
        self.lastScanTime = currentTime
    end
    
    return self.cachedEggPrompts
end

-- OPTIMIZED: Function to auto set ProximityPrompts without lag
function EggSystem:autoSetHoldDuration()
    while self.isAutoSetHoldDuration do
        -- Get fresh prompts every time to ensure we catch new eggs
        local eggPrompts = self:getEggProximityPrompts()
        
        if #eggPrompts > 0 then
            -- Process prompts in batches to prevent lag
            local processed = 0
            for _, prompt in ipairs(eggPrompts) do
                if not self.isAutoSetHoldDuration then break end
                
                -- Check if prompt and its parent still exist
                if prompt and prompt.Parent then
                    -- Always update to ensure it's set to 0 (no condition checks)
                    prompt.HoldDuration = 0
                    prompt.Enabled = true
                    prompt.RequiresLineOfSight = false
                    
                    processed = processed + 1
                    -- Small yield every 5 prompts to prevent freezing but still be fast
                    if processed % 5 == 0 then
                        task.wait()
                    end
                end
            end
        end
        
        -- Wait between scans
        task.wait(0.5)
    end
end

-- ULTRA FAST: Function to teleport to eggs - optimized for AFK farming
function EggSystem:teleportToEggs()
    while self.isTeleportToEggs do
        local character = self.Player.Character
        if not character then
            task.wait(0.1)
            continue
        end
        
        local humanoidRootPart = character:FindFirstChild("HumanoidRootPart")
        if not humanoidRootPart then
            task.wait(0.1)
            continue
        end
        
        -- Clear cache and find fresh eggs in GeneralFolder
        self.cachedEggs = {}
        
        -- Search specifically in GeneralFolder
        local generalFolder = self.Workspace:FindFirstChild("#GAME") and 
                             self.Workspace["#GAME"]:FindFirstChild("Folders") and 
                             self.Workspace["#GAME"].Folders:FindFirstChild("GeneralFolder")
        
        if generalFolder then
            -- Scan all children of GeneralFolder
            for _, egg in pairs(generalFolder:GetChildren()) do
                if not self.isTeleportToEggs then break end
                
                -- Use your isValidEgg function to check if it's a REAL egg (exact name match)
                if self:isValidEgg(egg) then
                    local position = self:getValidEggPosition(egg)
                    if position then
                        table.insert(self.cachedEggs, {
                            object = egg,
                            position = position,
                            name = egg.Name
                        })
                    end
                end
            end
        end
        
        if #self.cachedEggs > 0 then
            -- Find the closest valid egg
            local closestEgg = nil
            local closestDistance = math.huge
            
            for _, eggData in ipairs(self.cachedEggs) do
                if not self.isTeleportToEggs then break end
                
                -- Quick check if egg still exists
                if eggData.object and eggData.object.Parent then
                    local freshPosition = self:getValidEggPosition(eggData.object)
                    if freshPosition then
                        local distance = (humanoidRootPart.Position - freshPosition).Magnitude
                        if distance < closestDistance then
                            closestDistance = distance
                            closestEgg = eggData
                        end
                    end
                end
            end
            
            if closestEgg then
                -- Debug: Print egg name to verify filtering is working
                print("Teleporting to: " .. closestEgg.name)
                
                -- Instant teleport to the closest egg
                local success = pcall(function()
                    humanoidRootPart.CFrame = CFrame.new(closestEgg.position + Vector3.new(0, 3, 0))
                end)
                
                if not success then
                    task.wait(0.01)
                end
            end
        end
        
        -- Minimal wait between scans
        task.wait(0.1)
    end
end

-- Function to auto spam E key
function EggSystem:autoSpamKey()
    while self.isAutoSpamKey do
        if self.isAutoSpamKey then
            self.VirtualInputManager:SendKeyEvent(true, Enum.KeyCode.E, false, game)
            task.wait(0.01)
            self.VirtualInputManager:SendKeyEvent(false, Enum.KeyCode.E, false, game)
            task.wait(0.01)
        end
    end
end

-- Function to restart all active features after respawn
function EggSystem:restartFeatures()
    -- Minimal wait for character to load
    task.wait(1.0)
    
    -- Clear cache on respawn
    self.cachedEggPrompts = {}
    self.cachedEggs = {}
    self.lastScanTime = 0
    
    -- Restart features if they were active
    if self.isAutoSetHoldDuration then
        self.autoSetHoldDurationThread = self:stopThread(self.autoSetHoldDurationThread)
        task.wait(0.5) -- Small delay before restarting
        self.autoSetHoldDurationThread = task.spawn(function()
            self:autoSetHoldDuration()
        end)
    end
    
    if self.isTeleportToEggs then
        self.teleportToEggsThread = self:stopThread(self.teleportToEggsThread)
        task.wait(0.5) -- Small delay before restarting
        self.teleportToEggsThread = task.spawn(function()
            self:teleportToEggs()
        end)
    end
    
    if self.isAutoSpamKey then
        self.spamKeyThread = self:stopThread(self.spamKeyThread)
        task.wait(0.5) -- Small delay before restarting
        self.spamKeyThread = task.spawn(function()
            self:autoSpamKey()
        end)
    end
end

-- Connect to character added event for respawn handling
EggSystem.Player.CharacterAdded:Connect(function(character)
    EggSystem:restartFeatures()
end)

-- Egg Spawn Notifier
local EggNotifier = {
    enabled = false,
    connection = nil,
    detectedEggs = {}
}

-- Function to check if object is a REAL egg (exact name match only)
EggNotifier.isValidEgg = function(obj)
    if not obj or not obj.Parent then
        return false
    end
    
    local isValidType = obj:IsA("BasePart") or obj:IsA("Model") or obj:IsA("MeshPart")
    if not isValidType then
        return false
    end
    
    -- Check if the exact name is in our list
    if VALID_EGG_LOOKUP[obj.Name] then
        return true
    end
    
    return false
end

-- Function to handle new descendants
EggNotifier.onDescendantAdded = function(descendant)
    if not EggNotifier.enabled then return end
    
    -- Only check descendants that are in GeneralFolder
    local isInGeneralFolder = false
    local current = descendant
    while current do
        if current.Name == "GeneralFolder" and 
           current.Parent and 
           current.Parent.Name == "Folders" and
           current.Parent.Parent and 
           current.Parent.Parent.Name == "#GAME" then
            isInGeneralFolder = true
            break
        end
        current = current.Parent
    end
    
    if isInGeneralFolder and EggNotifier.isValidEgg(descendant) then
        local eggName = descendant.Name
        local eggId = tostring(descendant:GetFullName())
        
        -- Check if we've already detected this egg
        if not EggNotifier.detectedEggs[eggId] then
            EggNotifier.detectedEggs[eggId] = true
            
            -- KEEP THIS NOTIFICATION - it's the important one!
            OrionLib:MakeNotification({
                Name = "Egg Spawned!",
                Content = eggName .. " has spawned in GeneralFolder!",
                Image = "rbxassetid://7734059095",
                Time = 5
            })
            
            -- Optional: Print to console for debugging
            warn("EGG SPAWNED: " .. eggName .. " at " .. tostring(descendant:GetFullName()))
        end
    end
end

-- Function to start egg spawn detection
EggNotifier.startDetection = function()
    if EggNotifier.connection then
        EggNotifier.connection:Disconnect()
    end
    
    -- Clear previous detections
    EggNotifier.detectedEggs = {}
    
    -- Connect to descendant added event
    EggNotifier.connection = workspace.DescendantAdded:Connect(EggNotifier.onDescendantAdded)
    
    -- Also check for existing eggs in GeneralFolder when starting
    task.spawn(function()
        task.wait(1) -- Wait a bit for game to load
        
        local generalFolder = workspace:FindFirstChild("#GAME") and 
                             workspace["#GAME"]:FindFirstChild("Folders") and 
                             workspace["#GAME"].Folders:FindFirstChild("GeneralFolder")
        
        if generalFolder then
            local eggCount = 0
            for _, egg in pairs(generalFolder:GetChildren()) do
                if EggNotifier.isValidEgg(egg) then -- Use the new isValidEgg function
                    local eggId = tostring(egg:GetFullName())
                    if not EggNotifier.detectedEggs[eggId] then
                        EggNotifier.detectedEggs[eggId] = true
                        eggCount = eggCount + 1
                    end
                end
            end
            
            if eggCount > 0 then
                OrionLib:MakeNotification({
                    Name = "Egg Detected",
                    Content = "Found " .. eggCount .. " eggs already in GeneralFolder!",
                    Image = "rbxassetid://7734059095",
                    Time = 3
                })
            end
        end
    end)
end

-- Function to stop egg spawn detection
EggNotifier.stopDetection = function()
    if EggNotifier.connection then
        EggNotifier.connection:Disconnect()
        EggNotifier.connection = nil
    end
    EggNotifier.detectedEggs = {}
end

-- Improved toggle with better error handling
Tab:AddToggle({
    Name = "Auto Set Instant CD To Eggs",
    Default = false,
    Callback = function(Value)
        EggSystem.isAutoSetHoldDuration = Value
        if Value then
            -- Clear cache and start immediately
            EggSystem.cachedEggPrompts = {}
            EggSystem.lastScanTime = 0
            
            -- Force one immediate scan
            EggSystem:getEggProximityPrompts()
            
            EggSystem.autoSetHoldDurationThread = task.spawn(function()
                EggSystem:autoSetHoldDuration()
            end)
        else
            if EggSystem.autoSetHoldDurationThread then
                EggSystem:stopThread(EggSystem.autoSetHoldDurationThread)
                EggSystem.autoSetHoldDurationThread = nil
            end
        end
    end
})

Tab:AddToggle({
    Name = "Auto Teleport To Eggs",
    Default = false,
    Callback = function(Value)
        EggSystem.isTeleportToEggs = Value
        if Value then
            EggSystem.teleportToEggsThread = task.spawn(function()
                EggSystem:teleportToEggs()
            end)
        else
            EggSystem.teleportToEggsThread = EggSystem:stopThread(EggSystem.teleportToEggsThread)
        end
    end
})

-- Add the toggle to your tab
Tab:AddToggle({
    Name = "Auto Notify Spawned Eggs",
    Default = false,
    Callback = function(Value)
        EggNotifier.enabled = Value
        
        if Value then
            EggNotifier.startDetection()
        else
            EggNotifier.stopDetection()
        end
    end
})

-- Optional: Add a button to manually check for eggs
Tab:AddButton({
    Name = "Check For Existing Eggs",
    Callback = function()
        local eggCount = 0
        local generalFolder = workspace:FindFirstChild("#GAME") and 
                             workspace["#GAME"]:FindFirstChild("Folders") and 
                             workspace["#GAME"].Folders:FindFirstChild("GeneralFolder")
        
        if generalFolder then
            for _, egg in pairs(generalFolder:GetChildren()) do
                if EggNotifier.isValidEgg(egg) then -- Use the new isValidEgg function
                    eggCount = eggCount + 1
                    print("Found egg: " .. egg.Name)
                end
            end
        end
        
        OrionLib:MakeNotification({
            Name = "Egg Check",
            Content = "Found " .. eggCount .. " eggs in GeneralFolder",
            Time = 3
        })
    end
})

-- Optional: Add a button to clear egg detection history
Tab:AddButton({
    Name = "Clear Eggs Detection History",
    Callback = function()
        EggNotifier.detectedEggs = {}
        OrionLib:MakeNotification({
            Name = "Egg Notifier",
            Content = "Egg detection history cleared!",
            Time = 3
        })
    end
})

Tab:AddToggle({
    Name = "Auto Spam E Key Prompt",
    Default = false,
    Callback = function(Value)
        EggSystem.isAutoSpamKey = Value
        if Value then
            EggSystem.spamKeyThread = task.spawn(function()
                EggSystem:autoSpamKey()
            end)
        else
            EggSystem.spamKeyThread = EggSystem:stopThread(EggSystem.spamKeyThread)
        end
    end
})

Tab = Window:MakeTab({
    Name = "Event",
    Icon = "rbxassetid://7733919198",
    PremiumOnly = false
})

Tab:AddLabel("Halloween Stuff")

-- ========== Helper: Create Billboard ESP ==========
local function createESP(parent, name, text, color)
    local esp = Instance.new("BillboardGui", parent)
    esp.Name = name
    esp.Adornee = parent
    esp.Size = UDim2.new(0, 150, 0, 40)
    esp.StudsOffset = Vector3.new(0, 2, 0)
    esp.AlwaysOnTop = true

    local label = Instance.new("TextLabel", esp)
    label.BackgroundTransparency = 1
    label.Size = UDim2.new(1, 0, 1, 0)
    label.TextSize = 16
    label.Font = Enum.Font.FredokaOne
    label.TextColor3 = color
    label.TextStrokeTransparency = 0.2
    label.Text = text

    return label
end

-- ========== Helper: Create Highlight ==========
local function createHighlight(parent, color)
    local highlight = Instance.new("Highlight")
    highlight.Parent = parent
    highlight.FillColor = color
    highlight.FillTransparency = 0.5
    highlight.OutlineColor = color
    highlight.OutlineTransparency = 0
    highlight.DepthMode = Enum.HighlightDepthMode.AlwaysOnTop
    return highlight
end

-- ========== Souls ESP ==========
Tab:AddToggle({
    Name = "Souls ESP",
    Default = false,
    Callback = function(Value)
        SoulESP = Value
        if not Value then
            for _, v in pairs(workspace:GetDescendants()) do
                if v:IsA("BillboardGui") and v.Name == "SoulESP" then
                    v:Destroy()
                end
                if v:IsA("Highlight") then
                    v:Destroy()
                end
            end
            return
        end

        task.spawn(function()
            while SoulESP do
                local dumpFolder = workspace:FindFirstChild("#GAME") and workspace["#GAME"]:FindFirstChild("Folders"):FindFirstChild("DumpFolder")

                if dumpFolder then
                    for _, item in pairs(dumpFolder:GetDescendants()) do
                        if item:IsA("BasePart") and item.Name == "Handle" then
                            -- Create ESP
                            if not item:FindFirstChild("SoulESP") then
                                createESP(item, "SoulESP", "Soul", Color3.fromRGB(0, 255, 255))
                            end
                            
                            -- Create highlight
                            if not item:FindFirstChildOfClass("Highlight") then
                                createHighlight(item, Color3.fromRGB(0, 255, 255))
                            end
                        end
                    end
                end
                task.wait(1)
            end
        end)
    end
})

Tab:AddLabel("Christmas Stuff")

Section = Tab:AddSection({
 Name = "Snowflake Stuff"
})

-- ========== HITBOX SIZE CHANGER SYSTEM ==========

-- Services
local Workspace = game:GetService("Workspace")

-- Global variables
_G.HitBoxSize = 100  -- Default size
_G.AutoApplyHitBoxSize = false
_G.AutoApplyConnection = nil

-- Function to find GeneralFolder
local function findGeneralFolder()
    local success, generalFolder = pcall(function()
        return Workspace["#GAME"]:WaitForChild("Folders"):WaitForChild("GeneralFolder")
    end)
    
    if not success then
        -- Try alternative path
        local gameFolder = Workspace:WaitForChild("#GAME", 5)
        if not gameFolder then return nil end
        
        local foldersFolder = gameFolder:WaitForChild("Folders", 5)
        if not foldersFolder then return nil end
        
        generalFolder = foldersFolder:WaitForChild("GeneralFolder", 5)
    end
    
    return generalFolder
end

-- Function to find and resize HitBox parts
local function resizeHitBoxes(size)
    local generalFolder = findGeneralFolder()
    if not generalFolder then
        warn("GeneralFolder not found!")
        return false
    end
    
    local hitBoxCount = 0
    local successCount = 0
    
    -- Find all Models in GeneralFolder
    for _, model in ipairs(generalFolder:GetChildren()) do
        if model:IsA("Model") then
            -- Find HitBox BasePart inside the Model
            local hitBox = model:FindFirstChild("HitBox")
            if hitBox and hitBox:IsA("BasePart") then
                hitBoxCount = hitBoxCount + 1
                
                -- Apply new size
                local success, err = pcall(function()
                    hitBox.Size = Vector3.new(size, size, size)
                    successCount = successCount + 1
                end)
                
                if not success then
                    warn("Failed to resize HitBox in", model.Name, ":", err)
                end
            end
        end
    end
    
    if hitBoxCount > 0 then

        return true
    else
        print("No HitBox parts found in GeneralFolder models")
        return false
    end
end

-- Function to start auto-applying hitbox size
local function startAutoApply()
    if _G.AutoApplyConnection then
        _G.AutoApplyConnection:Disconnect()
        _G.AutoApplyConnection = nil
    end
    
    _G.AutoApplyHitBoxSize = true
    _G.AutoApplyConnection = game:GetService("RunService").Heartbeat:Connect(function()
        local success = pcall(function()
            local size = _G.HitBoxSize or 100
            resizeHitBoxes(size)
        end)
        
        if not success then
            warn("Auto-apply failed, retrying...")
        end
        
        task.wait(0.1)  -- Apply every 0.1 seconds
    end)
end

-- Function to stop auto-applying
local function stopAutoApply()
    _G.AutoApplyHitBoxSize = false
    if _G.AutoApplyConnection then
        _G.AutoApplyConnection:Disconnect()
        _G.AutoApplyConnection = nil
    end
end

-- Manual apply function
local function manualApplySize()
    local size = _G.HitBoxSize or 100
    resizeHitBoxes(size)
end

-- UI Elements
Tab:AddSlider({
    Name = "Snowflakes Hitbox Size",
    Min = 1,
    Max = 1000,
    Default = 100,
    Color = Color3.fromRGB(255, 255, 255),
    Increment = 1,
    ValueName = "Size",
    Callback = function(Value)
        _G.HitBoxSize = Value
        
        -- If auto-apply is enabled, it will automatically apply
        -- If not, we could optionally apply immediately, but let's keep it simple
        if not _G.AutoApplyHitBoxSize then
            -- You can optionally apply immediately here:
            -- manualApplySize()
        end
    end
})

Tab:AddToggle({
    Name = "Auto Set Snowflakes Size",
    Default = false,
    Callback = function(Value)
        if Value then
            startAutoApply()
        else
            stopAutoApply()
        end
    end
})

Tab:AddToggle({
    Name = "Auto Teleport To Snowflakes",
    Default = false,
    Callback = function(Value)
        AutoTeleportSnowflakes = Value
        
        task.spawn(function()
            local player = game.Players.LocalPlayer
            
            while AutoTeleportSnowflakes do
                local character = player.Character
                if not character then
                    task.wait(0.01)
                    continue
                end
                
                local rootPart = character:FindFirstChild("HumanoidRootPart")
                if not rootPart then
                    task.wait(0.01)
                    continue
                end
                
                -- Find all SnowflakeModels with HitBoxes
                local snowflakes = {}
                
                for _, item in ipairs(game.workspace["#GAME"].Folders.GeneralFolder:GetChildren()) do
                    if item.Name == "SnowflakeModel" and item:IsA("Model") then
                        local hitBox = item:FindFirstChild("HitBox")
                        if hitBox then
                            table.insert(snowflakes, {
                                model = item,
                                hitBox = hitBox,
                                position = hitBox.Position
                            })
                        end
                    end
                end
                
                -- Teleport to each snowflake very quickly
                for _, snowflake in ipairs(snowflakes) do
                    if not AutoTeleportSnowflakes then break end
                    
                    -- Instant teleport
                    rootPart.CFrame = CFrame.new(snowflake.position + Vector3.new(0, 1, 0))
                    
                    -- Small delay for game to register position
                    task.wait(0.001)
                end
                
                task.wait(0.01) -- Overall loop delay
            end
        end)
    end
})

-- ========== Snowflakes ESP ==========
Tab:AddToggle({
    Name = "Snowflakes ESP",
    Default = false,
    Callback = function(Value)
        SnowflakeESP = Value
        if not Value then
            for _, v in pairs(workspace:GetDescendants()) do
                if v:IsA("BillboardGui") and v.Name == "SnowflakeESP" then
                    v:Destroy()
                end
                if v:IsA("Highlight") then
                    v:Destroy()
                end
            end
            return
        end

        task.spawn(function()
            while SnowflakeESP do
                -- UPDATED PATH: workspace["#GAME"].Folders.GeneralFolder
                local generalFolder = workspace:FindFirstChild("#GAME") and 
                                     workspace["#GAME"]:FindFirstChild("Folders") and 
                                     workspace["#GAME"].Folders:FindFirstChild("GeneralFolder")

                if generalFolder then
                    for _, item in pairs(generalFolder:GetDescendants()) do
                        -- Check if the object is a SnowflakeModel
                        local isSnowflake = false
                        
                        if item:IsA("Model") and item.Name == "SnowflakeModel" then
                            isSnowflake = true
                        end
                        
                        if isSnowflake then
                            -- Create ESP
                            if not item:FindFirstChild("SnowflakeESP") then
                                createESP(item, "SnowflakeESP", "Snowflake", Color3.fromRGB(255, 255, 0)) -- Yellow color for snowflakes
                            end
                            
                            -- Create highlight
                            if not item:FindFirstChildOfClass("Highlight") then
                                createHighlight(item, Color3.fromRGB(255, 255, 0)) -- Yellow color for snowflakes
                            end
                        else
                            -- Remove ESP and highlight if not a snowflake
                            local existingESP = item:FindFirstChild("SnowflakeESP")
                            if existingESP then
                                existingESP:Destroy()
                            end
                            local highlight = item:FindFirstChildOfClass("Highlight")
                            if highlight then
                                highlight:Destroy()
                            end
                        end
                    end
                end
                task.wait(1)
            end
        end)
    end
})

Section = Tab:AddSection({
 Name = "Presents Stuff"
})

-- Present Collection System (Optimized for Auto Teleport)
local PresentSystem = {
    Workspace = game:GetService("Workspace"),
    Players = game:GetService("Players"),
    RunService = game:GetService("RunService"),
    VirtualInputManager = game:GetService("VirtualInputManager"),
    
    Player = nil,
    
    -- Feature toggles
    isAutoSetHoldDuration = false,
    isTeleportToPresents = false,
    isAutoSpamKey = false,
    
    -- Threads
    autoSetHoldDurationThread = nil,
    teleportToPresentsThread = nil,
    spamKeyThread = nil,
    
    -- Performance optimization
    cachedPresentPrompts = {},
    cachedPresents = {},
    lastScanTime = 0,
    SCAN_INTERVAL = 0.1, -- Faster scanning
    lastTeleportTime = 0,
    TELEPORT_COOLDOWN = 0.01, -- Very fast cooldown
    lastPromptTime = 0,
    PROMPT_COOLDOWN = 0.01,
    
    -- Performance monitoring
    frameCount = 0,
    lastFPSUpdate = tick(),
    currentFPS = 60
}

-- Initialize
PresentSystem.Player = PresentSystem.Players.LocalPlayer

-- Function to check if object is a REAL present (not just named "Present")
-- Only presents with names containing "Present" but is not just "Present"
function PresentSystem:isValidPresent(obj)
    if not obj or not obj.Parent then
        return false
    end
    
    local isValidType = obj:IsA("BasePart") or obj:IsA("Model") or obj:IsA("MeshPart")
    if not isValidType then
        return false
    end
    
    local nameLower = obj.Name:lower()
    
    -- Check if name contains "present" but is NOT just "present"
    if string.find(nameLower, "present") then
        -- If the name is exactly "present" (case-insensitive), ignore it
        if nameLower == "present" then
            return false
        end
        
        -- Check for present types we want (contains present but has other text)
        local presentTypes = {
            "basic present",
            "noob present", 
            "rare present",
            "epic present",
            "legendary present",
            "mythical present",
            "exotic present",
            "golden present",
            "diamond present",
            "crystal present",
            "ruby present",
            "emerald present",
            "sapphire present",
            "amethyst present",
            "obsidian present",
            "shadow present",
            "light present",
            "fire present",
            "ice present",
            "water present",
            "earth present",
            "wind present",
            "electric present",
            "nature present",
            "metal present",
            "void present",
            "solar present",
            "lunar present",
            "star present",
            "galaxy present",
            "cosmic present",
            "rainbow present",
            "mystery present",
            "secret present",
            "hidden present",
            "boss present",
            "event present",
            "holiday present",
            "christmas present",
            "halloween present",
            "easter present",
            "valentine present",
            "summer present",
            "winter present",
            "spring present",
            "fall present",
            "anniversary present",
            "present mythic",
            "present epic",
            "present legendary",
            "present rare"
        }
        
        for _, presentType in ipairs(presentTypes) do
            if string.find(nameLower, presentType) then
                return true
            end
        end
        
        -- Also accept any name that contains "present" and has a space or other characters
        -- This catches patterns like "Basic Present", "Present_Mythic", "present123", etc.
        if #nameLower > 7 then -- "present" is 7 characters, so anything longer
            return true
        end
    end
    
    return false
end

-- Function to monitor FPS and adjust performance
function PresentSystem:monitorPerformance()
    self.frameCount = self.frameCount + 1
    local currentTime = tick()
    
    if currentTime - self.lastFPSUpdate >= 1 then
        self.currentFPS = self.frameCount
        self.frameCount = 0
        self.lastFPSUpdate = currentTime
        
        if self.currentFPS < 30 then
            self.SCAN_INTERVAL = 0.5
            self.TELEPORT_COOLDOWN = 0.02
        else
            self.SCAN_INTERVAL = 0.1
            self.TELEPORT_COOLDOWN = 0.01
        end
    end
end

-- Function to safely stop threads
function PresentSystem:stopThread(thread)
    if thread then
        task.cancel(thread)
        return nil
    end
    return nil
end

-- Function to get valid present position (checks if present still exists)
function PresentSystem:getValidPresentPosition(present)
    if not present or not present.Parent then
        return nil
    end
    
    local success, position = pcall(function()
        if present:IsA("Model") then
            if present.PrimaryPart and present.PrimaryPart.Parent then
                return present.PrimaryPart.Position
            else
                local firstPart = present:FindFirstChildWhichIsA("BasePart")
                if firstPart and firstPart.Parent then
                    return firstPart.Position
                end
            end
        else
            -- MeshPart or BasePart
            if present.Parent then
                return present.Position
            end
        end
        return nil
    end)
    
    return success and position or nil
end

-- FAST function to get fresh presents from GeneralFolder
function PresentSystem:getFreshPresents()
    self.cachedPresents = {}
    
    local generalFolder = self.Workspace:FindFirstChild("#GAME") and 
                         self.Workspace["#GAME"]:FindFirstChild("Folders") and 
                         self.Workspace["#GAME"].Folders:FindFirstChild("GeneralFolder")
    
    if generalFolder then
        -- Fast scan through all children
        for _, present in pairs(generalFolder:GetChildren()) do
            if self:isValidPresent(present) then
                local position = self:getValidPresentPosition(present)
                if position then
                    table.insert(self.cachedPresents, {
                        object = present,
                        position = position
                    })
                end
            end
        end
    end
    
    self.lastScanTime = tick()
    return self.cachedPresents
end

-- OPTIMIZED: Function to get ProximityPrompts without lag
function PresentSystem:getPresentProximityPrompts()
    local currentTime = tick()
    
    -- Only rescan if cache is empty or enough time has passed
    if #self.cachedPresentPrompts == 0 or (currentTime - self.lastScanTime) > 5.0 then
        self.cachedPresentPrompts = {}
        
        -- Only scan GeneralFolder
        local generalFolder = self.Workspace:FindFirstChild("#GAME") and 
                             self.Workspace["#GAME"]:FindFirstChild("Folders") and 
                             self.Workspace["#GAME"].Folders:FindFirstChild("GeneralFolder")
        
        if generalFolder then
            -- Limit scanning to prevent lag
            local scanCount = 0
            for _, present in pairs(generalFolder:GetChildren()) do
                if scanCount > 50 then break end -- Safety limit
                
                if self:isValidPresent(present) then
                    -- Only check first few descendants to prevent lag
                    local prompt = present:FindFirstChildWhichIsA("ProximityPrompt")
                    if prompt and prompt.Parent then
                        table.insert(self.cachedPresentPrompts, prompt)
                    else
                        -- Quick check for prompts in descendants (limited)
                        local descendants = present:GetDescendants()
                        for i = 1, math.min(10, #descendants) do -- Limit to 10 descendants
                            local descendant = descendants[i]
                            if descendant:IsA("ProximityPrompt") then
                                table.insert(self.cachedPresentPrompts, descendant)
                                break -- Only need one prompt per present
                            end
                        end
                    end
                    scanCount = scanCount + 1
                end
            end
        end
        
        self.lastScanTime = currentTime
    end
    
    return self.cachedPresentPrompts
end

-- OPTIMIZED: Function to auto set ProximityPrompts without lag
function PresentSystem:autoSetHoldDuration()
    while self.isAutoSetHoldDuration do
        -- Only process if we have prompts
        local presentPrompts = self:getPresentProximityPrompts()
        
        if #presentPrompts > 0 then
            -- Process prompts in batches to prevent lag
            local processed = 0
            for _, prompt in ipairs(presentPrompts) do
                if not self.isAutoSetHoldDuration then break end
                
                if prompt and prompt.Parent then
                    -- Only update if needed (reduces unnecessary operations)
                    if prompt.HoldDuration ~= 0 then
                        prompt.HoldDuration = 0
                    end
                    if not prompt.Enabled then
                        prompt.Enabled = true
                    end
                    if prompt.RequiresLineOfSight then
                        prompt.RequiresLineOfSight = false
                    end
                    
                    processed = processed + 1
                    -- Small yield every 10 prompts to prevent freezing
                    if processed % 10 == 0 then
                        task.wait()
                    end
                end
            end
        end
        
        -- Much longer wait between scans to reduce CPU usage
        task.wait(3.0)
    end
end

-- ULTRA FAST: Function to teleport to presents - optimized for AFK farming
function PresentSystem:teleportToPresents()
    while self.isTeleportToPresents do
        local currentTime = tick()
        
        -- No cooldown check - teleport as fast as possible
        local character = self.Player.Character
        if not character then
            task.wait(0.1)
            continue
        end
        
        local humanoidRootPart = character:FindFirstChild("HumanoidRootPart")
        if not humanoidRootPart then
            task.wait(0.1)
            continue
        end
        
        -- Get fresh presents every time
        local presents = self:getFreshPresents()
        
        if #presents > 0 then
            -- Find the closest valid present
            local closestPresent = nil
            local closestDistance = math.huge
            
            for _, presentData in ipairs(presents) do
                if not self.isTeleportToPresents then break end
                
                -- Quick check if present still exists
                if presentData.object and presentData.object.Parent then
                    local freshPosition = self:getValidPresentPosition(presentData.object)
                    if freshPosition then
                        local distance = (humanoidRootPart.Position - freshPosition).Magnitude
                        if distance < closestDistance then
                            closestDistance = distance
                            closestPresent = presentData
                        end
                    end
                end
            end
            
            if closestPresent then
                -- Instant teleport to the closest present
                local success = pcall(function()
                    humanoidRootPart.CFrame = CFrame.new(closestPresent.position + Vector3.new(0, 3, 0))
                end)
                
                if not success then
                    -- If teleport failed, tiny wait
                    task.wait(0.01)
                end
            end
        end
        
        -- Minimal wait between scans
        task.wait(0.01)
    end
end

-- Function to auto spam E key
function PresentSystem:autoSpamKey()
    while self.isAutoSpamKey do
        if self.isAutoSpamKey then
            self.VirtualInputManager:SendKeyEvent(true, Enum.KeyCode.E, false, game)
            task.wait(0.01)
            self.VirtualInputManager:SendKeyEvent(false, Enum.KeyCode.E, false, game)
            task.wait(0.01)
        end
    end
end

-- Function to restart all active features after respawn
function PresentSystem:restartFeatures()
    -- Minimal wait for character to load
    task.wait(1.0)
    
    -- Clear cache on respawn
    self.cachedPresentPrompts = {}
    self.cachedPresents = {}
    self.lastScanTime = 0
    
    -- Restart features if they were active
    if self.isAutoSetHoldDuration then
        self.autoSetHoldDurationThread = self:stopThread(self.autoSetHoldDurationThread)
        task.wait(0.5) -- Small delay before restarting
        self.autoSetHoldDurationThread = task.spawn(function()
            self:autoSetHoldDuration()
        end)
    end
    
    if self.isTeleportToPresents then
        self.teleportToPresentsThread = self:stopThread(self.teleportToPresentsThread)
        task.wait(0.5) -- Small delay before restarting
        self.teleportToPresentsThread = task.spawn(function()
            self:teleportToPresents()
        end)
    end
    
    if self.isAutoSpamKey then
        self.spamKeyThread = self:stopThread(self.spamKeyThread)
        task.wait(0.5) -- Small delay before restarting
        self.spamKeyThread = task.spawn(function()
            self:autoSpamKey()
        end)
    end
end

-- Connect to character added event for respawn handling
PresentSystem.Player.CharacterAdded:Connect(function(character)
    PresentSystem:restartFeatures()
end)

-- OPTIMIZED: Function to auto set ProximityPrompts without lag
function PresentSystem:autoSetHoldDuration()
    while self.isAutoSetHoldDuration do
        -- Get fresh prompts every time to ensure we catch new presents
        local presentPrompts = self:getPresentProximityPrompts()
        
        if #presentPrompts > 0 then
            -- Process prompts in batches to prevent lag
            local processed = 0
            for _, prompt in ipairs(presentPrompts) do
                if not self.isAutoSetHoldDuration then break end
                
                -- Check if prompt and its parent still exist
                if prompt and prompt.Parent then
                    -- Always update to ensure it's set to 0 (no condition checks)
                    prompt.HoldDuration = 0
                    prompt.Enabled = true
                    prompt.RequiresLineOfSight = false
                    
                    processed = processed + 1
                    -- Small yield every 5 prompts to prevent freezing but still be fast
                    if processed % 5 == 0 then
                        task.wait()
                    end
                end
            end
        end
        
        -- Shorter wait between scans to catch new presents faster
        task.wait(0.5)
    end
end

-- ULTRA FAST: Function to get ProximityPrompts with better caching
function PresentSystem:getPresentProximityPrompts()
    self.cachedPresentPrompts = {}
    
    -- Only scan GeneralFolder
    local generalFolder = self.Workspace:FindFirstChild("#GAME") and 
                         self.Workspace["#GAME"]:FindFirstChild("Folders") and 
                         self.Workspace["#GAME"].Folders:FindFirstChild("GeneralFolder")
    
    if generalFolder then
        -- Scan all presents in general folder
        for _, present in pairs(generalFolder:GetChildren()) do
            if self:isValidPresent(present) then
                -- Check for prompts on the present itself
                local prompt = present:FindFirstChildWhichIsA("ProximityPrompt")
                if prompt and prompt.Parent then
                    table.insert(self.cachedPresentPrompts, prompt)
                else
                    -- Check descendants for prompts (limited to prevent lag)
                    for _, descendant in ipairs(present:GetDescendants()) do
                        if descendant:IsA("ProximityPrompt") then
                            table.insert(self.cachedPresentPrompts, descendant)
                            break -- Only need one prompt per present
                        end
                    end
                end
            end
        end
    end
    
    self.lastScanTime = tick()
    return self.cachedPresentPrompts
end

-- Improved toggle with better error handling
Tab:AddToggle({
    Name = "Auto Set Instant CD To Presents",
    Default = false,
    Callback = function(Value)
        PresentSystem.isAutoSetHoldDuration = Value
        if Value then
            -- Clear cache and start immediately
            PresentSystem.cachedPresentPrompts = {}
            PresentSystem.lastScanTime = 0
            
            -- Force one immediate scan
            PresentSystem:getPresentProximityPrompts()
            
            PresentSystem.autoSetHoldDurationThread = task.spawn(function()
                PresentSystem:autoSetHoldDuration()
            end)
        else
            if PresentSystem.autoSetHoldDurationThread then
                PresentSystem:stopThread(PresentSystem.autoSetHoldDurationThread)
                PresentSystem.autoSetHoldDurationThread = nil
            end
        end
    end
})

Tab:AddToggle({
    Name = "Auto Teleport To Presents",
    Default = false,
    Callback = function(Value)
        PresentSystem.isTeleportToPresents = Value
        if Value then
            PresentSystem.teleportToPresentsThread = task.spawn(function()
                PresentSystem:teleportToPresents()
            end)
        else
            PresentSystem.teleportToPresentsThread = PresentSystem:stopThread(PresentSystem.teleportToPresentsThread)
        end
    end
})

-- Present Spawn Notifier
local PresentNotifier = {
    enabled = false,
    connection = nil,
    detectedPresents = {}
}

-- Function to check if object is a REAL present (not just named "Present")
PresentNotifier.isValidPresent = function(obj)
    if not obj or not obj.Parent then
        return false
    end
    
    local isValidType = obj:IsA("BasePart") or obj:IsA("Model") or obj:IsA("MeshPart")
    if not isValidType then
        return false
    end
    
    local nameLower = obj.Name:lower()
    
    -- Check if name contains "present" but is NOT just "present"
    if string.find(nameLower, "present") then
        -- If the name is exactly "present" (case-insensitive), ignore it
        if nameLower == "present" then
            return false
        end
        
        -- Check for present types we want (contains present but has other text)
        local presentTypes = {
            "basic present",
            "noob present", 
            "rare present",
            "epic present",
            "legendary present",
            "mythical present",
            "exotic present",
            "golden present",
            "diamond present",
            "crystal present",
            "ruby present",
            "emerald present",
            "sapphire present",
            "amethyst present",
            "obsidian present",
            "shadow present",
            "light present",
            "fire present",
            "ice present",
            "water present",
            "earth present",
            "wind present",
            "electric present",
            "nature present",
            "metal present",
            "void present",
            "solar present",
            "lunar present",
            "star present",
            "galaxy present",
            "cosmic present",
            "rainbow present",
            "mystery present",
            "secret present",
            "hidden present",
            "boss present",
            "event present",
            "holiday present",
            "christmas present",
            "halloween present",
            "easter present",
            "valentine present",
            "summer present",
            "winter present",
            "spring present",
            "fall present",
            "anniversary present",
            "present mythic",
            "present epic",
            "present legendary",
            "present rare"
        }
        
        for _, presentType in ipairs(presentTypes) do
            if string.find(nameLower, presentType) then
                return true
            end
        end
        
        -- Also accept any name that contains "present" and has a space or other characters
        -- This catches patterns like "Basic Present", "Present_Mythic", "present123", etc.
        if #nameLower > 7 then -- "present" is 7 characters, so anything longer
            return true
        end
    end
    
    return false
end

-- Function to handle new descendants
PresentNotifier.onDescendantAdded = function(descendant)
    if not PresentNotifier.enabled then return end
    
    if PresentNotifier.isValidPresent(descendant) then
        local presentName = descendant.Name
        local presentId = tostring(descendant:GetFullName())
        
        -- Check if we've already detected this present
        if not PresentNotifier.detectedPresents[presentId] then
            PresentNotifier.detectedPresents[presentId] = true
            
            -- KEEP THIS NOTIFICATION - it's the important one!
            OrionLib:MakeNotification({
                Name = "Present Spawned!",
                Content = presentName .. " has spawned!",
                Image = "rbxassetid://7734059095",
                Time = 5
            })
            
            -- Optional: Print to console for debugging
            warn("PRESENT SPAWNED: " .. presentName .. " at " .. tostring(descendant:GetFullName()))
        end
    end
end

-- Function to start present spawn detection
PresentNotifier.startDetection = function()
    if PresentNotifier.connection then
        PresentNotifier.connection:Disconnect()
    end
    
    -- Clear previous detections
    PresentNotifier.detectedPresents = {}
    
    -- Connect to descendant added event
    PresentNotifier.connection = workspace.DescendantAdded:Connect(PresentNotifier.onDescendantAdded)
    
    -- Also check for existing presents when starting
    task.spawn(function()
        task.wait(1) -- Wait a bit for game to load
        
        local generalFolder = workspace:FindFirstChild("#GAME") and 
                             workspace["#GAME"]:FindFirstChild("Folders") and 
                             workspace["#GAME"].Folders:FindFirstChild("GeneralFolder")
        
        if generalFolder then
            for _, present in pairs(generalFolder:GetChildren()) do
                if PresentNotifier.isValidPresent(present) then
                    local presentId = tostring(present:GetFullName())
                    if not PresentNotifier.detectedPresents[presentId] then
                        PresentNotifier.detectedPresents[presentId] = true
                        OrionLib:MakeNotification({
                            Name = "Present Detected",
                            Content = present.Name .. " already exists!",
                            Image = "rbxassetid://7734059095",
                            Time = 3
                        })
                    end
                end
            end
        end
    end)
end

-- Function to stop present spawn detection
PresentNotifier.stopDetection = function()
    if PresentNotifier.connection then
        PresentNotifier.connection:Disconnect()
        PresentNotifier.connection = nil
    end
    PresentNotifier.detectedPresents = {}
end

-- Add the toggle to your tab
Tab:AddToggle({
    Name = "Auto Notify Spawned Presents",
    Default = false,
    Callback = function(Value)
        PresentNotifier.enabled = Value
        
        if Value then
            PresentNotifier.startDetection()
        else
            PresentNotifier.stopDetection()
        end
    end
})

-- Optional: Add a button to manually check for presents
Tab:AddButton({
    Name = "Check For Existing Presents",
    Callback = function()
        local presentCount = 0
        local generalFolder = workspace:FindFirstChild("#GAME") and 
                             workspace["#GAME"]:FindFirstChild("Folders") and 
                             workspace["#GAME"].Folders:FindFirstChild("GeneralFolder")
        
        if generalFolder then
            for _, present in pairs(generalFolder:GetChildren()) do
                if PresentNotifier.isValidPresent(present) then
                    presentCount = presentCount + 1
                end
            end
        end
        
        OrionLib:MakeNotification({
            Name = "Present Check",
            Content = "Found " .. presentCount .. " presents in GeneralFolder",
            Time = 3
        })
    end
})

-- Optional: Add a button to clear present detection history
Tab:AddButton({
    Name = "Clear Presents Detection History",
    Callback = function()
        PresentNotifier.detectedPresents = {}
        OrionLib:MakeNotification({
            Name = "Present Notifier",
            Content = "Present detection history cleared!",
            Time = 3
        })
    end
})

Tab:AddToggle({
    Name = "Auto Spam E Key",
    Default = false,
    Callback = function(Value)
        PresentSystem.isAutoSpamKey = Value
        if Value then
            PresentSystem.spamKeyThread = task.spawn(function()
                PresentSystem:autoSpamKey()
            end)
        else
            PresentSystem.spamKeyThread = PresentSystem:stopThread(PresentSystem.spamKeyThread)
        end
    end
})

-- ========== Presents ESP ==========
Tab:AddToggle({
    Name = "Presents ESP",
    Default = false,
    Callback = function(Value)
        PresentESP = Value
        if not Value then
            for _, v in pairs(workspace:GetDescendants()) do
                if v:IsA("BillboardGui") and v.Name == "PresentESP" then
                    v:Destroy()
                end
                if v:IsA("Highlight") then
                    v:Destroy()
                end
            end
            return
        end

        task.spawn(function()
            while PresentESP do
                -- UPDATED PATH: workspace["#GAME"].Folders.GeneralFolder
                local generalFolder = workspace:FindFirstChild("#GAME") and 
                                     workspace["#GAME"]:FindFirstChild("Folders") and 
                                     workspace["#GAME"].Folders:FindFirstChild("GeneralFolder")

                if generalFolder then
                    for _, item in pairs(generalFolder:GetDescendants()) do
                        -- Check if the object is a valid present (using the same logic as auto presents)
                        local isValidPresent = false
                        
                        if item:IsA("BasePart") or item:IsA("MeshPart") or item:IsA("Model") then
                            local nameLower = item.Name:lower()
                            
                            -- Check if name contains "present" but is NOT just "present"
                            if string.find(nameLower, "present") then
                                if nameLower ~= "present" then
                                    -- Check for present types (contains present but has other text)
                                    local presentTypes = {
                                        "basic present", "noob present", "rare present", "epic present", 
                                        "legendary present", "mythical present", "exotic present", "golden present", 
                                        "diamond present", "crystal present", "ruby present", "emerald present", 
                                        "sapphire present", "amethyst present", "obsidian present", "shadow present", 
                                        "light present", "fire present", "ice present", "water present", 
                                        "earth present", "wind present", "electric present", "nature present", 
                                        "metal present", "void present", "solar present", "lunar present", 
                                        "star present", "galaxy present", "cosmic present", "rainbow present", 
                                        "mystery present", "secret present", "hidden present", "boss present", 
                                        "event present", "holiday present", "christmas present", "halloween present", 
                                        "easter present", "valentine present", "summer present", "winter present", 
                                        "spring present", "fall present", "anniversary present", "present mythic", 
                                        "present epic", "present legendary", "present rare"
                                    }
                                    
                                    for _, presentType in ipairs(presentTypes) do
                                        if string.find(nameLower, presentType) then
                                            isValidPresent = true
                                            break
                                        end
                                    end
                                    
                                    -- Also accept any name that contains "present" and has a space or other characters
                                    if #nameLower > 7 then -- "present" is 7 characters, so anything longer
                                        isValidPresent = true
                                    end
                                end
                            end
                        end
                        
                        if isValidPresent then
                            -- Create ESP
                            if not item:FindFirstChild("PresentESP") then
                                createESP(item, "PresentESP", item.Name, Color3.fromRGB(255, 215, 0)) -- Gold color for presents
                            end
                            
                            -- Create highlight
                            if not item:FindFirstChildOfClass("Highlight") then
                                createHighlight(item, Color3.fromRGB(255, 215, 0)) -- Gold color for presents
                            end
                        else
                            -- Remove ESP and highlight if not a valid present
                            local existingESP = item:FindFirstChild("PresentESP")
                            if existingESP then
                                existingESP:Destroy()
                            end
                            local highlight = item:FindFirstChildOfClass("Highlight")
                            if highlight then
                                highlight:Destroy()
                            end
                        end
                    end
                end
                task.wait(1)
            end
        end)
    end
})

Tab = Window:MakeTab({
 Name = "Badges",
 Icon = "rbxassetid://7733673987",
 PremiumOnly = false
})

loadstring(game:HttpGet("https://raw.githubusercontent.com/Scripter-Coder/Scripter-Coder/refs/heads/main/Shoot%20And%20Eat%20Noobs/something%20(orion%20hub)"))()

Tab = Window:MakeTab({
    Name = "ESP",
    Icon = "rbxassetid://7743872929",
    PremiumOnly = false
})

local ESPHelper = {}

-- Combined ESP creation function
function ESPHelper.createESPObject(parent, espType, text, color)  -- FIXED: Changed : to .
    if espType == "Billboard" then
        local esp = Instance.new("BillboardGui")
        esp.Name = "ESP"
        esp.Adornee = parent
        esp.Size = UDim2.new(0, 150, 0, 40)
        esp.StudsOffset = Vector3.new(0, 2, 0)
        esp.AlwaysOnTop = true
        
        local label = Instance.new("TextLabel")
        label.BackgroundTransparency = 1
        label.Size = UDim2.new(1, 0, 1, 0)
        label.TextSize = 16
        label.Font = Enum.Font.FredokaOne
        label.TextColor3 = color
        label.TextStrokeTransparency = 0.2
        label.Text = text
        
        label.Parent = esp
        esp.Parent = parent
        
        return esp
        
    elseif espType == "Highlight" then
        local highlight = Instance.new("Highlight")
        highlight.Parent = parent
        highlight.FillColor = color
        highlight.FillTransparency = 0.5
        highlight.OutlineColor = color
        highlight.OutlineTransparency = 0
        highlight.DepthMode = Enum.HighlightDepthMode.AlwaysOnTop
        
        return highlight
    end
    
    return nil
end

-- ========== Players ESP ==========
Tab:AddToggle({
    Name = "Players ESP",
    Default = false,
    Callback = function(Value)
        PlayerESP = Value

        if not Value then
            for _, v in ipairs(game.Players:GetPlayers()) do
                local head = v.Character and v.Character:FindFirstChild("Head")
                if head then
                    if head:FindFirstChild("PlayerEsp") then
                        head.PlayerEsp:Destroy()
                    end
                    if head:FindFirstChild("PlayerEspHighlight") then
                        head.PlayerEspHighlight:Destroy()
                    end
                end
            end
            return
        end

        task.spawn(function()
            while PlayerESP do
                local localPlayer = game.Players.LocalPlayer
                for _, v in ipairs(game.Players:GetPlayers()) do
                    if v ~= localPlayer and v.Character and v.Character:FindFirstChild("Head") then
                        local head = v.Character.Head
                        local humanoid = v.Character:FindFirstChild("Humanoid")
                        if head and humanoid then
                            if not head:FindFirstChild("PlayerEsp") then
                                createESP(head, "PlayerEsp", v.Name, Color3.new(1, 1, 1))
                            end
                        end
                    end
                end
                task.wait(0.1)
            end
        end)
    end
})

-- ========== Noobs/Werewolfs/ETC... ESP ==========
Tab:AddToggle({
    Name = "NPC's ESP",
    Default = false,
    Callback = function(Value)
        NPCESP = Value
        if not Value then
            for _, v in pairs(workspace:GetDescendants()) do
                if v:IsA("BillboardGui") and v.Name == "NPCESP" then
                    v:Destroy()
                end
                if v:IsA("Highlight") then
                    v:Destroy()
                end
            end
            return
        end

        task.spawn(function()
            while NPCESP do
                -- UPDATED PATH: workspace["#GAME"].Folders.VisibleInstances.HumanoidFolder.NPCFolder
                local npcFolder = workspace:FindFirstChild("#GAME") and 
                                 workspace["#GAME"]:FindFirstChild("Folders") and 
                                 workspace["#GAME"].Folders:FindFirstChild("VisibleInstances") and 
                                 workspace["#GAME"].Folders.VisibleInstances:FindFirstChild("HumanoidFolder") and 
                                 workspace["#GAME"].Folders.VisibleInstances.HumanoidFolder:FindFirstChild("NPCFolder")

                if npcFolder then
                    for _, npc in pairs(npcFolder:GetChildren()) do
                        local humanoid = npc:FindFirstChildOfClass("Humanoid")
                        local head = npc:FindFirstChild("Head")

                        if humanoid and head and humanoid.Health > 0 then
                            -- Create ESP
                            if not head:FindFirstChild("NPCESP") then
                                createESP(head, "NPCESP", npc.Name, Color3.fromRGB(0, 255, 0))
                            end
                            
                            -- Create highlight
                            if not npc:FindFirstChildOfClass("Highlight") then
                                createHighlight(npc, Color3.fromRGB(0, 255, 0))
                            end
                        else
                            -- Remove ESP and highlight if dead
                            local existingESP = head and head:FindFirstChild("NPCESP")
                            if existingESP then
                                existingESP:Destroy()
                            end
                            local highlight = npc and npc:FindFirstChildOfClass("Highlight")
                            if highlight then
                                highlight:Destroy()
                            end
                        end
                    end
                end
                task.wait(1)
            end
        end)
    end
})

-- ========== Bacon Parts ESP ==========
Tab:AddToggle({
    Name = "Bacon Parts ESP",
    Default = false,
    Callback = function(Value)
        PartESP = Value
        if not Value then
            for _, v in pairs(workspace:GetDescendants()) do
                if v:IsA("BillboardGui") and v.Name == "PartESP" then
                    v:Destroy()
                end
                if v:IsA("Highlight") then
                    v:Destroy()
                end
            end
            return
        end

        task.spawn(function()
            while PartESP do
                local map = workspace:FindFirstChild("#GAME") and workspace["#GAME"]:FindFirstChild("Map")

                if map then
                    for _, part in pairs(map:GetDescendants()) do
                        if part:IsA("BasePart") and part.Name == "Part" then
                            local clickDetector = part:FindFirstChild("ClickDetector")

                            if clickDetector then
                                -- Create ESP
                                if not part:FindFirstChild("PartESP") then
                                    createESP(part, "PartESP", "Bacon Part", Color3.fromRGB(255, 0, 0))
                                end
                                
                                -- Create highlight
                                if not part:FindFirstChildOfClass("Highlight") then
                                    createHighlight(part, Color3.fromRGB(255, 0, 0))
                                end
                            end
                        end
                    end
                end
                task.wait(1)
            end
        end)
    end
})

-- ========== Eggs ESP ==========
Tab:AddToggle({
    Name = "Eggs ESP",
    Default = false,
    Callback = function(Value)
        EggESP = Value
        if not Value then
            for _, v in pairs(workspace:GetDescendants()) do
                if v:IsA("BillboardGui") and v.Name == "EggESP" then
                    v:Destroy()
                end
                if v:IsA("Highlight") then
                    v:Destroy()
                end
            end
            return
        end

        task.spawn(function()
            while EggESP do
                local dumpFolder = workspace:FindFirstChild("#GAME") and workspace["#GAME"]:FindFirstChild("Folders"):FindFirstChild("DumpFolder")

                if dumpFolder then
                    for _, item in pairs(dumpFolder:GetChildren()) do
                        if (item:IsA("MeshPart") or item:IsA("Model") or item:IsA("Part")) and string.find(item.Name, "Egg", 1, true) then
                            -- Create ESP
                            if not item:FindFirstChild("EggESP") then
                                createESP(item, "EggESP", item.Name, Color3.fromRGB(255, 255, 0))
                            end
                            
                            -- Create highlight
                            if not item:FindFirstChildOfClass("Highlight") then
                                createHighlight(item, Color3.fromRGB(255, 255, 0))
                            end
                        end
                    end
                end
                task.wait(1)
            end
        end)
    end
})

Tab = Window:MakeTab({
    Name = "Shop/Equip/Unequip",
    Icon = "rbxassetid://7734056747",
    PremiumOnly = false
})

-- Define all shop categories in a single table to save local registers
_G.ShopCategories = {
    Anniversary = {"Great King Poop Noob", "Exclusive 10k Pet", "Bob", "20k Pet", "Party Pedro", "Bombarder Noob Pet", "Exclusive 1 MILLION Pet", "Balloon Tank", "Party Pet", "Buoyant Pet", "Delicious Pet", "Balloon Sword", "Balloon", "Party Hat"},
    AprilFools = {"Revolvah", "Revwholever", "MegAK-47", "Poop Werewolf Pet", "Scammah Pet", "Poop Noob Pet", "Bigger Fat Poop Noob Pet", "Biggest Mega Fat Poop Noob Pet", "Banana Cato", "Sir Stinkington", "Lamppost", "Pine Tree", "Billboard"},
    Limited = {"Shyserkampfwagen IV", "Turd Maus", "Sebastian", "Toilet Pouwk", "Toilet BULL", "Black Bas", "Turd Mouse", "BULLKERPOUWKER", "Exclusive Verdant Vanquisher"},
    BoomDay = {"Justice", "Revolutionary Rain", "Liberty Annihilator"},
    Easter = {"Chicken Gun", "The Eggsterminator", "Easter Egg", "Chicken", "Lil Scrambler", "Chicken Noob Pet", "Moai Pet", "Strongest Egg", "Bunny Noob Pet", "Supreme Chick", "Bulk Beak", "Stone Cold Cutie", "Suprahme Chick", "Easter Doggo", "Eggstinction Rush X"},
    Event = {"Firework Launcher", "Bunny Ears"},
    Valentines = {"Nubids Bow", "Teddy", "Heart Pet", "Pinky", "Nubid", "BULLkiePouwk"},
    Halloween = {"Pumpkin Launcher", "Little Jack", "Biggest Cracked Bas", "Exclusive 10 MILLION Pet", "Corrupted Black Hole Pet", "Exclusive 100 MILLION Pet", "Exclusive Scarlet Slaughterer", "Soulreaper"},
    KingNoobEvent = {"The Scepter", "King Biggest Mega Fat Poop Noob", "King Poop Noob", "Queen Poop Noob", "King Noob", "Great King Noob", "Queen Noob", "The Crown"},
    Christmas = {"Festive Noob Pet", "Turkey Pet", "Elf Pet", "Gingerbread Pet", "Santa Pet", "Satan Santa"},
    Regular = {"Revolver", "Deagle", "UZI", "Tommy Gun", "AK-47", "Sawed-Off", "Trench Shotgun", "SPAS-12", "AWP", "Remington 700", "RPG-7", "Panzer IV", "Kriss Vector", "Hecate II", "Minigun", "S-G", "MG 1", "M4A3E8", "Microgun", "TMG V2", "M1 Abrams", "SMOGGTTLTSG", "Maus", "UZYeah", "Smiley Sucker", "Revolvahhh", "Baby Noob Pet", "Bacon Pet", "Short Bacon Pet", "Tall Bacon Pet", "Bigger Bacon Pet", "10k Pet", "Rock Noob Pet", "Monster Noob Pet", "Zombie Pet", "Biggest Bacon Pet", "Stick Bug", "Werewolf Pet", "100k Pet", "PedroMobile", "Biggest Bigger Bacon Pet", "Sticker Bug", "Cracked Stick Bug", "Stickest Bug", "Cracked Sticker Bug", "10 MILLION Pet", "Stickester Bug", "100 MILLION Pet", "1 BILLION Pet", "Evaluator \206\148", "Clown Mouse", "SGobbler", "Pouwk", "Scammer Pet", "Cracked Bas", "BULL", "Sjebullepouwker", "Exclusive 100k Pet", "Cursor", "Silver Cursor", "Golden Cursor", "Diamond Cursor", "Emerald Cursor", "Ruby Cursor", "Amethyst Cursor", "Boots", "Silver Boots", "Golden Boots", "Diamond Boots", "Emerald Boots", "Ruby Boots", "Amethyst Boots", "Gloves", "Silver Gloves", "Golden Gloves", "Diamond Gloves", "Emerald Gloves", "Ruby Gloves", "Amethyst Gloves", "Body Armor", "Silver Body Armor", "Golden Body Armor", "Diamond Body Armor", "Emerald Body Armor", "Ruby Body Armor", "Amethyst Body Armor", "Cheese", "Lantern", "Classic Sword", "King Slayer", "CRACKED Mode", "Hatred", "Onion", "Noob burger", "OOOHnion", "Bigger Noob burger", "Biggest Noob burger", "Biggest Bigger Noob burger"}
}

-- Combine all shop items into one dropdown
_G.ShopSystem = _G.ShopSystem or {
    allShopItems = {},
    selectedItem = "Deagle"
}

-- Fixed: Define the function locally first
local function combineShopItems()
    _G.ShopSystem.allShopItems = {}
    
    -- Add all items from each category
    for _, category in pairs(_G.ShopCategories) do
        for _, item in ipairs(category) do
            table.insert(_G.ShopSystem.allShopItems, item)
        end
    end
    
    -- Remove duplicates and sort alphabetically
    local seen = {}
    local uniqueItems = {}
    for _, item in ipairs(_G.ShopSystem.allShopItems) do
        if not seen[item] then
            seen[item] = true
            table.insert(uniqueItems, item)
        end
    end
    table.sort(uniqueItems)
    return uniqueItems
end

-- Store in _G for access elsewhere
_G.combineShopItems = combineShopItems

-- Create dropdown with all shop items - FIXED: Call the function properly
_G.allItems = combineShopItems()

Tab:AddDropdown({
    Name = "Choose What To Buy From Shop",
    Options = _G.allItems,
    Default = _G.ShopSystem.selectedItem,
    Callback = function(value)
        _G.ShopSystem.selectedItem = value
    end
})

-- Create a button to buy the item
Tab:AddButton({
    Name = "Buy Item From Shop",
    Callback = function()
        local args = {_G.ShopSystem.selectedItem}
        game:GetService("ReplicatedStorage"):WaitForChild("Events"):WaitForChild("BuyItem"):FireServer(unpack(args))
    end
})

-- Create a toggle for Auto Buying
_G.ShopSystem.autoBuyEnabled = false
_G.ShopSystem.autoBuyCoroutine = nil

Tab:AddToggle({
    Name = "Auto Buy Item From Shop",
    Default = false,
    Callback = function(Value)
        _G.ShopSystem.autoBuyEnabled = Value
        if Value then
            _G.ShopSystem.autoBuyCoroutine = coroutine.create(function()
                while _G.ShopSystem.autoBuyEnabled do
                    local args = {_G.ShopSystem.selectedItem}
                    game:GetService("ReplicatedStorage"):WaitForChild("Events"):WaitForChild("BuyItem"):FireServer(unpack(args))
                    task.wait(1)
                end
            end)
            coroutine.resume(_G.ShopSystem.autoBuyCoroutine)
        else
            if _G.ShopSystem.autoBuyCoroutine then
                coroutine.close(_G.ShopSystem.autoBuyCoroutine)
                _G.ShopSystem.autoBuyCoroutine = nil
            end
        end
    end
})

-- Textbox to input the item name
Tab:AddTextbox({
    Name = "Item Name to Un/Equip",
    Default = "Evaluator \206\148",  -- Empty default
    TextDisappear = false,
    Callback = function(Text)
        _G.EquipShopItemName = tostring(Text) or ""
        print("Item name set to:", _G.EquipShopItemName)
    end
})

-- Button to fire the remote with the textbox input
Tab:AddButton({
    Name = "Un/Equip Item From Shop",
    Callback = function()
        -- Get the item name from the textbox
        local itemName = _G.EquipShopItemName
        
        if itemName and itemName ~= "" then
            -- Create the args table
            local args = {
                itemName
            }
            
            -- Try to fire the remote
            local success, errorMessage = pcall(function()
                game:GetService("ReplicatedStorage"):WaitForChild("Events"):WaitForChild("EquipShopItem"):FireServer(unpack(args))
            end)
            
            if success then
                print("Successfully sent EquipShopItem remote with item:", itemName)
            else
                warn("Failed to send EquipShopItem remote:", errorMessage)
            end
        else
            warn("Please enter an item name in the textbox first!")
        end
    end
})

Tab = Window:MakeTab({
    Name = "Scripts",
    Icon = "rbxassetid://8997388036",
    PremiumOnly = false
})

Section = Tab:AddSection({
    Name = "ZScriptX"
})

Tab:AddButton({
    Name = "SAEN Script",
    Callback = function()
loadstring(game:HttpGet('https://raw.githubusercontent.com/sederyttv-scripter/Wow/refs/heads/main/djdj'))()
    end
})

Tab = Window:MakeTab({
    Name = "Inventory",
    Icon = "rbxassetid://7733917120",
    PremiumOnly = false
})

-- Player Selection and Inventory Display
_G.Players = game:GetService("Players")
local InventorySystem = {
    selectedPlayer = Players.LocalPlayer,
    playerDropdown = nil,
    inventoryParagraph = nil,
    AutoSetInfoServer = nil,
    lastUpdateTime = 0,
    UPDATE_INTERVAL = 1.0 -- Update every 1 second instead of every frame
}

-- Function to update player list
InventorySystem.updatePlayerList = function()
    local playerNames = {}
    for _, player in ipairs(Players:GetPlayers()) do
        table.insert(playerNames, player.Name)
    end
    table.sort(playerNames)
    InventorySystem.playerDropdown:Refresh(playerNames, true)
end

-- Function to get player's inventory tools
InventorySystem.getPlayerInventory = function(player)
    local tools = {}
    
    if player then
        -- Check backpack
        if player:FindFirstChild("Backpack") then
            for _, tool in ipairs(player.Backpack:GetChildren()) do
                if tool:IsA("Tool") then
                    -- Check if tool has Amount attribute
                    local amount = tool:GetAttribute("Amount")
                    if amount then
                        table.insert(tools, tool.Name .. " " .. tostring(amount))
                    else
                        table.insert(tools, tool.Name)
                    end
                end
            end
        end
        
        -- Check if player has character with equipped tools
        if player.Character then
            for _, tool in ipairs(player.Character:GetChildren()) do
                if tool:IsA("Tool") then
                    -- Check if tool has Amount attribute
                    local amount = tool:GetAttribute("Amount")
                    if amount then
                        table.insert(tools, tool.Name .. " " .. tostring(amount))
                    else
                        table.insert(tools, tool.Name)
                    end
                end
            end
        end
    end
    
    return tools
end

-- Function to update inventory display
InventorySystem.updateInventoryDisplay = function()
    local tools = InventorySystem.getPlayerInventory(InventorySystem.selectedPlayer)
    local displayText = ""
    
    if #tools > 0 then
        for i, tool in ipairs(tools) do
            displayText = displayText .. tool
            if i < #tools then
                displayText = displayText .. "\n"
            end
        end
    else
        displayText = "No tools found in inventory"
    end
    
    InventorySystem.inventoryParagraph:Set(displayText)
end

-- Create dropdown for player selection
InventorySystem.playerDropdown = Tab:AddDropdown({
    Name = "Select Player",
    Default = Players.LocalPlayer.Name,
    Options = {},
    Callback = function(Value)
        InventorySystem.selectedPlayer = Players:FindFirstChild(Value)
        InventorySystem.updateInventoryDisplay()
    end
})

-- Add reset button to update player list
Tab:AddButton({
    Name = "Update Player List",
    Callback = function()
        InventorySystem.updatePlayerList()
    end
})

-- Create inventory paragraph
InventorySystem.inventoryParagraph = Tab:AddParagraph("Inventory Items:", "Select a player to view their inventory")

-- Auto update player list when players join/leave
Players.PlayerAdded:Connect(function()
    if InventorySystem.playerDropdown then
        InventorySystem.updatePlayerList()
    end
end)

Players.PlayerRemoving:Connect(function()
    if InventorySystem.playerDropdown then
        InventorySystem.updatePlayerList()
    end
end)

-- Initialize player list
InventorySystem.updatePlayerList()

-- Optimized auto update inventory display
Tab:AddToggle({
    Name = "Auto Set Info",
    Default = false,
    Callback = function(Value)
        _G.AutoSetInfo = Value
        
        if Value then
            -- Use Heartbeat instead of RenderStepped for better performance
            InventorySystem.AutoSetInfoServer = game:GetService("RunService").Heartbeat:Connect(function()
                if _G.AutoSetInfo then
                    local currentTime = tick()
                    -- Only update every UPDATE_INTERVAL seconds to prevent lag
                    if currentTime - InventorySystem.lastUpdateTime >= InventorySystem.UPDATE_INTERVAL then
                        InventorySystem.updateInventoryDisplay()
                        InventorySystem.lastUpdateTime = currentTime
                    end
                end
            end)
        else
            if InventorySystem.AutoSetInfoServer then
                InventorySystem.AutoSetInfoServer:Disconnect()
                InventorySystem.AutoSetInfoServer = nil
            end
        end
    end
})

Tab = Window:MakeTab({
    Name = "Health NPC's",
    Icon = "rbxassetid://8997386648",
    PremiumOnly = false
})

-- NPC Health Status Display
_G.npcHealthParagraph = Tab:AddParagraph("NPC Health Status:", "NPC health information will appear here")

-- Function to get NPC health status with proper name display
_G.getNPCHealthStatus = function()
    local npcStatus = {}
    
    -- UPDATED PATH: workspace["#GAME"].Folders.VisibleInstances.HumanoidFolder.NPCFolder
    local npcFolder = workspace:FindFirstChild("#GAME") and 
                     workspace["#GAME"]:FindFirstChild("Folders") and 
                     workspace["#GAME"].Folders:FindFirstChild("VisibleInstances") and 
                     workspace["#GAME"].Folders.VisibleInstances:FindFirstChild("HumanoidFolder") and 
                     workspace["#GAME"].Folders.VisibleInstances.HumanoidFolder:FindFirstChild("NPCFolder")
    
    if npcFolder then
        for _, npc in ipairs(npcFolder:GetChildren()) do
            if npc:IsA("Model") then
                local humanoid = npc:FindFirstChildOfClass("Humanoid")
                if humanoid and humanoid.Health > 0 then  -- Only include NPCs with health > 0
                    local currentHealth = math.floor(humanoid.Health)
                    local maxHealth = math.floor(humanoid.MaxHealth)
                    
                    -- Format health text
                    local healthText = "(" .. currentHealth .. "/" .. maxHealth .. ")"
                    
                    table.insert(npcStatus, {
                        name = npc.Name,  -- Keep full name
                        health = healthText,
                        currentHealth = currentHealth,
                        maxHealth = maxHealth
                    })
                end
            end
        end
    end
    
    return npcStatus
end

-- Function to truncate NPC name intelligently for display
local function truncateNameForDisplay(fullName, maxLength)
    if #fullName <= maxLength then
        return fullName
    end
    
    -- Try to find a natural break point (space or punctuation)
    for i = maxLength, math.max(1, maxLength - 10) do
        local char = string.sub(fullName, i, i)
        if char == " " or char == "_" or char == "-" then
            return string.sub(fullName, 1, i - 1) .. "..."
        end
    end
    
    -- If no natural break, just truncate at maxLength
    return string.sub(fullName, 1, maxLength) .. "..."
end

-- Function to update NPC health display with smart truncation
_G.updateNPCHealthDisplay = function()
    local npcStatus = _G.getNPCHealthStatus()
    local displayText = ""
    local maxDisplayLines = 20 -- Maximum lines to display
    
    if #npcStatus > 0 then
        -- Sort by name alphabetically for consistency
        table.sort(npcStatus, function(a, b)
            return a.name < b.name
        end)
        
        -- Calculate maximum name length we can display
        local maxNameLength = 50 -- Start with reasonable limit
        
        -- Build display text with smart truncation
        local displayedCount = 0
        for i = 1, #npcStatus do
            if displayedCount >= maxDisplayLines then
                break
            end
            
            local status = npcStatus[i]
            local displayName = status.name
            
            -- Truncate name if it's too long for display
            local nameWithHealth = displayName .. " = " .. status.health
            if #nameWithHealth > 80 then  -- If combined text is too long
                -- Calculate how many characters we can keep for the name
                local availableForName = 80 - #status.health - 3  -- 3 for " = "
                if availableForName > 10 then  -- Only truncate if we can keep a meaningful length
                    displayName = truncateNameForDisplay(displayName, availableForName)
                end
            end
            
            local line = displayName .. " = " .. status.health
            displayText = displayText .. line
            
            if i < #npcStatus and displayedCount < maxDisplayLines - 1 then
                displayText = displayText .. "\n"
            end
            
            displayedCount = displayedCount + 1
        end
        
        -- Add info about truncated list
        if #npcStatus > maxDisplayLines then
            displayText = displayText .. "\n... and " .. (#npcStatus - maxDisplayLines) .. " more NPCs"
        end
        
        -- Add summary at the bottom
        displayText = displayText .. "\n\nTotal NPCs: " .. #npcStatus
        local aliveCount = 0
        for _, status in ipairs(npcStatus) do
            if status.currentHealth > 0 then
                aliveCount = aliveCount + 1
            end
        end
        displayText = displayText .. " (Alive: " .. aliveCount .. ")"
        
    else
        displayText = "No NPCs found or no humanoids detected"
    end
    
    _G.npcHealthParagraph:Set(displayText)
end

-- Function to show FULL NPC names in a separate detailed view
Tab:AddButton({
    Name = "Show Full NPC Names",
    Callback = function()
        local npcStatus = _G.getNPCHealthStatus()
        
        if #npcStatus > 0 then
            local detailedText = "=== FULL NPC NAMES ===\n\n"
            
            -- Group NPCs by type for easier reading
            local npcGroups = {}
            for _, status in ipairs(npcStatus) do
                -- Extract NPC type from name (simplified)
                local npcType = "Other"
                if string.find(status.name, "CrackedBas") then
                    npcType = "CrackedBas"
                elseif string.find(status.name, "WhiteBas") then
                    npcType = "WhiteBas"
                elseif string.find(status.name, "Dead") then
                    npcType = "Dead"
                elseif string.find(status.name, "Golden") then
                    npcType = "Golden"
                elseif string.find(status.name, "Diamond") then
                    npcType = "Diamond"
                elseif string.find(status.name, "Ruby") then
                    npcType = "Ruby"
                elseif string.find(status.name, "Emerald") then
                    npcType = "Emerald"
                elseif string.find(status.name, "Amethyst") then
                    npcType = "Amethyst"
                elseif string.find(status.name, "Silver") then
                    npcType = "Silver"
                elseif string.find(status.name, "Rock") then
                    npcType = "Rock"
                end
                
                if not npcGroups[npcType] then
                    npcGroups[npcType] = {}
                end
                table.insert(npcGroups[npcType], status)
            end
            
            -- Display by group
            local groupOrder = {"CrackedBas", "WhiteBas", "Golden", "Diamond", "Ruby", "Emerald", 
                               "Amethyst", "Silver", "Rock", "Dead", "Other"}
            
            for _, groupName in ipairs(groupOrder) do
                if npcGroups[groupName] and #npcGroups[groupName] > 0 then
                    detailedText = detailedText .. "[" .. groupName .. " NPCs]:\n"
                    
                    for i, status in ipairs(npcGroups[groupName]) do
                        local lineNumber = string.format("%03d", i)
                        local healthPercent = math.floor((status.currentHealth / status.maxHealth) * 100)
                        
                        detailedText = detailedText .. lineNumber .. ". " .. status.name .. "\n"
                        detailedText = detailedText .. "     " .. status.health .. " (" .. healthPercent .. "%)\n\n"
                    end
                    
                    detailedText = detailedText .. "\n"
                end
            end
            
            -- Create a new paragraph for detailed view
            local detailedPara = Tab:AddParagraph("Full NPC Details", detailedText)
            
            -- Add button to close the detailed view
            Tab:AddButton({
                Name = "Close Detailed View",
                Callback = function()
                    if detailedPara then
                        detailedPara:Remove()
                    end
                end
            })
            
        else

        end
    end
})

-- Auto update NPC health display
_G.AutoNPCHealthServer = nil
_G.AutoNPCHealthToggle = Tab:AddToggle({
    Name = "Auto Update NPC Health",
    Default = false,
    Callback = function(Value)
        _G.AutoNPCHealth = Value
        if Value then
            _G.AutoNPCHealthServer = game:GetService("RunService").Heartbeat:Connect(function()
                if _G.AutoNPCHealth then
                    _G.updateNPCHealthDisplay()
                end
            end)
        else
            if _G.AutoNPCHealthServer then
                _G.AutoNPCHealthServer:Disconnect()
                _G.AutoNPCHealthServer = nil
            end
        end
    end
})

-- Manual update button
Tab:AddButton({
    Name = "Update NPC Health Status",
    Callback = function()
        _G.updateNPCHealthDisplay()
    end
})

-- Clear button
Tab:AddButton({
    Name = "Clear NPC Health Display",
    Callback = function()
        _G.npcHealthParagraph:Set("NPC health information will appear here")
    end
})

-- Button to reset to normal view
Tab:AddButton({
    Name = "Reset to Normal View",
    Callback = function()
        _G.updateNPCHealthDisplay()
    end
})

-- ========== PLAYER HEALTH STATUS DISPLAY ==========

-- Player Health Status Display
_G.playerHealthParagraph = Tab:AddParagraph("Player Health Status:", "Player health information will appear here")

-- Function to get Player health status from PlayerFolder
_G.getPlayerHealthStatus = function()
    local playerStatus = {}
    
    -- CORRECT PATH: workspace["#GAME"].Folders.VisibleInstances.HumanoidFolder.PlayerFolder
    local playerFolder = workspace:FindFirstChild("#GAME") and 
                        workspace["#GAME"]:FindFirstChild("Folders") and 
                        workspace["#GAME"].Folders:FindFirstChild("VisibleInstances") and 
                        workspace["#GAME"].Folders.VisibleInstances:FindFirstChild("HumanoidFolder") and 
                        workspace["#GAME"].Folders.VisibleInstances.HumanoidFolder:FindFirstChild("PlayerFolder")
    
    if playerFolder then
        for _, playerModel in ipairs(playerFolder:GetChildren()) do
            if playerModel:IsA("Model") then
                local humanoid = playerModel:FindFirstChildOfClass("Humanoid")
                if humanoid then
                    local currentHealth = math.floor(humanoid.Health)
                    local maxHealth = math.floor(humanoid.MaxHealth)
                    
                    -- Format health text
                    local healthText = "(" .. currentHealth .. "/" .. maxHealth .. ")"
                    
                    table.insert(playerStatus, {
                        name = playerModel.Name,  -- Player name
                        health = healthText,
                        currentHealth = currentHealth,
                        maxHealth = maxHealth
                    })
                end
            end
        end
    end
    
    return playerStatus
end

-- Function to update Player health display
_G.updatePlayerHealthDisplay = function()
    local playerStatus = _G.getPlayerHealthStatus()
    local displayText = ""
    local maxDisplayLines = 15 -- Maximum lines to display for players
    
    if #playerStatus > 0 then
        -- Sort by name alphabetically for consistency
        table.sort(playerStatus, function(a, b)
            return a.name < b.name
        end)
        
        -- Build display text
        local displayedCount = 0
        for i = 1, #playerStatus do
            if displayedCount >= maxDisplayLines then
                break
            end
            
            local status = playerStatus[i]
            local line = status.name .. " = " .. status.health
            
            -- Add health percentage
            local healthPercent = math.floor((status.currentHealth / status.maxHealth) * 100)
            line = line .. " [" .. healthPercent .. "%]"
            
            displayText = displayText .. line
            
            if i < #playerStatus and displayedCount < maxDisplayLines - 1 then
                displayText = displayText .. "\n"
            end
            
            displayedCount = displayedCount + 1
        end
        
        -- Add info about truncated list
        if #playerStatus > maxDisplayLines then
            displayText = displayText .. "\n... and " .. (#playerStatus - maxDisplayLines) .. " more players"
        end
        
        -- Add summary at the bottom
        displayText = displayText .. "\n\nTotal Players: " .. #playerStatus
        local aliveCount = 0
        for _, status in ipairs(playerStatus) do
            if status.currentHealth > 0 then
                aliveCount = aliveCount + 1
            end
        end
        displayText = displayText .. " (Alive: " .. aliveCount .. ")"
        
    else
        displayText = "No players found in PlayerFolder or no humanoids detected"
    end
    
    _G.playerHealthParagraph:Set(displayText)
end

-- Auto update Player health display
_G.AutoPlayerHealthServer = nil
_G.AutoPlayerHealthToggle = Tab:AddToggle({
    Name = "Auto Update Players Health",
    Default = false,
    Callback = function(Value)
        _G.AutoPlayerHealth = Value
        if Value then
            _G.AutoPlayerHealthServer = game:GetService("RunService").Heartbeat:Connect(function()
                if _G.AutoPlayerHealth then
                    _G.updatePlayerHealthDisplay()
                end
            end)
        else
            if _G.AutoPlayerHealthServer then
                _G.AutoPlayerHealthServer:Disconnect()
                _G.AutoPlayerHealthServer = nil
            end
        end
    end
})

-- Manual update button for players
Tab:AddButton({
    Name = "Update Player Health Status",
    Callback = function()
        _G.updatePlayerHealthDisplay()
        OrionLib:MakeNotification({
            Name = "Player Health",
            Content = "Player health status updated",
            Image = "rbxassetid://4483345998",
            Time = 2
        })
    end
})

-- Clear player display button
Tab:AddButton({
    Name = "Clear Player Health Display",
    Callback = function()
        _G.playerHealthParagraph:Set("Player health information will appear here")
        OrionLib:MakeNotification({
            Name = "Player Health",
            Content = "Player display cleared",
            Image = "rbxassetid://4483345998",
            Time = 2
        })
    end
})

-- Button to reset player view to normal
Tab:AddButton({
    Name = "Reset Player View",
    Callback = function()
        _G.updatePlayerHealthDisplay()
        OrionLib:MakeNotification({
            Name = "Player Health",
            Content = "Player display reset to normal view",
            Image = "rbxassetid://4483345998",
            Time = 2
        })
    end
})

Tab = Window:MakeTab({
 Name = "Other Stuff",
 Icon = "rbxassetid://7734068321",
 PremiumOnly = false
 })

Section = Tab:AddSection({
 Name = "Guns Changer (Only Works In Good Executors)"
})

-- ========== Guns Changer ==========
local GunsChanger = {
    -- Default values
    GunName = "Minigun",
    BulletSize = 0.11,
    Cooldown = 0.05,
    Range = 1023,
    HoldDown = "true"
}

-- Function to require the StatsDict module
local function requireStatsDict()
    local success, statsDict = pcall(function()
        return require(game.ReplicatedStorage.Modules["#GAME"].MainClientModule.StatsDict)
    end)
    
    if success and statsDict then
        return statsDict
    else
        warn("Failed to require StatsDict module:", statsDict)
        return nil
    end
end

-- Function to apply gun modifications
local function applyGunModifications()
    local statsDict = requireStatsDict()
    if not statsDict then
        OrionLib:MakeNotification({
            Name = "Guns Changer Error",
            Content = "Failed to load StatsDict module",
            Image = "rbxassetid://7734059095",
            Time = 3
        })
        return false
    end
    
    -- Validate gun name
    local gunName = GunsChanger.GunName
    if not statsDict.Guns or not statsDict.Guns[gunName] then
        OrionLib:MakeNotification({
            Name = "Guns Changer Error",
            Content = "Gun not found: " .. gunName,
            Image = "rbxassetid://7734059095",
            Time = 3
        })
        return false
    end
    
    -- Apply modifications
    local success = pcall(function()
        local gun = statsDict.Guns[gunName]
        
        -- Apply bullet size
        if GunsChanger.BulletSize and type(GunsChanger.BulletSize) == "number" then
            gun.BulletSize = GunsChanger.BulletSize
        end
        
        -- Apply cooldown
        if GunsChanger.Cooldown and type(GunsChanger.Cooldown) == "number" then
            gun.Cooldown = GunsChanger.Cooldown
        end
        
        -- Apply range
        if GunsChanger.Range and type(GunsChanger.Range) == "number" then
            gun.Range = GunsChanger.Range
        end
        
        -- Apply hold down
        if GunsChanger.HoldDown == "true" or GunsChanger.HoldDown == "false" then
            gun.HoldDown = (GunsChanger.HoldDown == "true")
        end
        
        return true
    end)
    
    if success then
        OrionLib:MakeNotification({
            Name = "Guns Changer",
            Content = "Applied modifications to " .. gunName .. "!",
            Image = "rbxassetid://4483345998",
            Time = 3
        })
        
        -- Reset character after 1 second
        task.wait(1)
        local player = game.Players.LocalPlayer
        local character = player.Character
        if character then
            local humanoid = character:FindFirstChildOfClass("Humanoid")
            if humanoid then
                humanoid.Health = 0
            end
        end
        
        return true
    else
        OrionLib:MakeNotification({
            Name = "Guns Changer Error",
            Content = "Failed to apply modifications",
            Image = "rbxassetid://7734059095",
            Time = 3
        })
        return false
    end
end

-- Function to get available guns list
local function getAvailableGuns()
    local statsDict = requireStatsDict()
    if not statsDict or not statsDict.Guns then
        return {}
    end
    
    local gunList = {}
    for gunName, _ in pairs(statsDict.Guns) do
        table.insert(gunList, gunName)
    end
    
    table.sort(gunList)
    return gunList
end

-- Function to get current gun stats
local function getCurrentGunStats(gunName)
    local statsDict = requireStatsDict()
    if not statsDict or not statsDict.Guns or not statsDict.Guns[gunName] then
        return nil
    end
    
    local gun = statsDict.Guns[gunName]
    return {
        BulletSize = gun.BulletSize,
        Cooldown = gun.Cooldown,
        Range = gun.Range,
        HoldDown = gun.HoldDown
    }
end

-- Gun Name Textbox
Tab:AddTextbox({
    Name = "Gun Name",
    Default = "Minigun",
    TextDisappear = false,
    Callback = function(Text)
        GunsChanger.GunName = tostring(Text)
        OrionLib:MakeNotification({
            Name = "Guns Changer",
            Content = "Gun set to: " .. Text,
            Time = 2
        })
        
        -- Auto-fill current stats when gun name changes
        task.spawn(function()
            task.wait(0.5)
            local currentStats = getCurrentGunStats(Text)
            if currentStats then
                OrionLib:MakeNotification({
                    Name = "Current Stats",
                    Content = "BulletSize: " .. currentStats.BulletSize .. 
                             "\nCooldown: " .. currentStats.Cooldown ..
                             "\nRange: " .. currentStats.Range ..
                             "\nHoldDown: " .. tostring(currentStats.HoldDown),
                    Time = 5
                })
            end
        end)
    end
})

-- Bullet Size Textbox
Tab:AddTextbox({
    Name = "Bullet Size",
    Default = "0.11",
    TextDisappear = false,
    Callback = function(Text)
        local numValue = tonumber(Text)
        if numValue then
            GunsChanger.BulletSize = numValue
            OrionLib:MakeNotification({
                Name = "Guns Changer",
                Content = "Bullet Size set to: " .. numValue,
                Time = 2
            })
        else
            OrionLib:MakeNotification({
                Name = "Guns Changer Error",
                Content = "Invalid number for Bullet Size",
                Image = "rbxassetid://7734059095",
                Time = 3
            })
        end
    end
})

-- Cooldown Textbox
Tab:AddTextbox({
    Name = "Shooting Cooldown",
    Default = "0.05",
    TextDisappear = false,
    Callback = function(Text)
        local numValue = tonumber(Text)
        if numValue then
            GunsChanger.Cooldown = numValue
            OrionLib:MakeNotification({
                Name = "Guns Changer",
                Content = "Cooldown set to: " .. numValue,
                Time = 2
            })
        else
            OrionLib:MakeNotification({
                Name = "Guns Changer Error",
                Content = "Invalid number for Cooldown",
                Image = "rbxassetid://7734059095",
                Time = 3
            })
        end
    end
})

-- Range Textbox
Tab:AddTextbox({
    Name = "Shooting Range",
    Default = "1023",
    TextDisappear = false,
    Callback = function(Text)
        local numValue = tonumber(Text)
        if numValue then
            GunsChanger.Range = numValue
            OrionLib:MakeNotification({
                Name = "Guns Changer",
                Content = "Range set to: " .. numValue,
                Time = 2
            })
        else
            OrionLib:MakeNotification({
                Name = "Guns Changer Error",
                Content = "Invalid number for Range",
                Image = "rbxassetid://7734059095",
                Time = 3
            })
        end
    end
})

-- HoldDown Dropdown
Tab:AddDropdown({
    Name = "Is Holding Down?",
    Default = "true",
    Options = {"true", "false"},
    Callback = function(Value)
        GunsChanger.HoldDown = Value
    end
})

-- Apply Modifications Button
Tab:AddButton({
    Name = "Apply Gun Modifications",
    Callback = function()
        applyGunModifications()
    end
})

Section = Tab:AddSection({
    Name = "Boombox Stuff (Need Radio To Equip)"
})

Tab:AddTextbox({
    Name = "Put Any Roblox Music/Sound ID",
    Default = "",
    TextDisappear = false,
    Callback = function(Value)
        MusicOrSoundChangerID = Value
    end
})

Tab:AddButton({
    Name = "Apply Custom Music/Sound",
    Callback = function()
        if MusicOrSoundChangerID and MusicOrSoundChangerID ~= "" then
            local soundId = tonumber(MusicOrSoundChangerID)
            if soundId then
                local args = { soundId }
                
                local success, errorMsg = pcall(function()
                    game:GetService("ReplicatedStorage"):WaitForChild("#GAME"):WaitForChild("_Storage"):WaitForChild("Events"):WaitForChild("Boombox"):FireServer(unpack(args))
                end)
                
                if not success then
                    warn("Failed to apply custom music/sound:", errorMsg)
                end
            else
                warn("Please enter a valid numeric Sound ID!")
            end
        else
            warn("Please enter a Sound ID first!")
        end
    end
})

Tab = Window:MakeTab({
 Name = "Vulnerability",
 Icon = "rbxassetid://7734068321",
 PremiumOnly = false
 })

Section = Tab:AddSection({
 Name = "Health Expander/Giver"
})

-- ========== Health Expander/Giver ==========
local HealthExpander = {
    targetTankName = ""
}

-- Function to equip and destroy tank
local function equipAndDestroyTank()
    if HealthExpander.targetTankName == "" then
        OrionLib:MakeNotification({
            Name = "Health Expander",
            Content = "Please enter a tank name first!",
            Image = "rbxassetid://7734059095",
            Time = 3
        })
        return false
    end
    
    local player = game.Players.LocalPlayer
    local character = player.Character
    if not character then
        OrionLib:MakeNotification({
            Name = "Health Expander",
            Content = "No character found!",
            Image = "rbxassetid://7734059095",
            Time = 3
        })
        return false
    end
    
    -- Look for the tank in backpack first
    local tankTool = player.Backpack:FindFirstChild(HealthExpander.targetTankName)
    
    -- If not in backpack, check if already equipped
    if not tankTool then
        tankTool = character:FindFirstChild(HealthExpander.targetTankName)
    end
    
    -- If still not found, check for any tool with "tank" in the name (case insensitive)
    if not tankTool then
        for _, item in ipairs(player.Backpack:GetChildren()) do
            if item:IsA("Tool") and string.find(item.Name:lower(), "tank") then
                tankTool = item
                HealthExpander.targetTankName = item.Name -- Update to actual name
                break
            end
        end
        
        -- Also check equipped tools
        if not tankTool then
            for _, item in ipairs(character:GetChildren()) do
                if item:IsA("Tool") and string.find(item.Name:lower(), "tank") then
                    tankTool = item
                    HealthExpander.targetTankName = item.Name -- Update to actual name
                    break
                end
            end
        end
    end
    
    if tankTool then
        -- Equip if in backpack
        if tankTool.Parent == player.Backpack then
            -- Unequip any current tool first
            local currentTool = character:FindFirstChildWhichIsA("Tool")
            if currentTool then
                currentTool.Parent = player.Backpack
                task.wait(0.1)
            end
            
            -- Equip the tank
            tankTool.Parent = character
            task.wait(0.2)
        end
        
        -- Destroy the tank after equipping
        tankTool:Destroy()
        
        OrionLib:MakeNotification({
            Name = "Health Expander",
            Content = "Equipped and destroyed tank: " .. HealthExpander.targetTankName,
            Image = "rbxassetid://4483345998",
            Time = 3
        })
        
        return true
    else
        OrionLib:MakeNotification({
            Name = "Health Expander",
            Content = "Could not find tank: " .. HealthExpander.targetTankName,
            Image = "rbxassetid://7734059095",
            Time = 3
        })
        return false
    end
end

-- Function to auto-find tanks
local function autoFindTanks()
    local player = game.Players.LocalPlayer
    local foundTanks = {}
    
    -- Check backpack
    for _, item in ipairs(player.Backpack:GetChildren()) do
        if item:IsA("Tool") and string.find(item.Name:lower(), "tank") then
            table.insert(foundTanks, item.Name)
        end
    end
    
    -- Check equipped
    if player.Character then
        for _, item in ipairs(player.Character:GetChildren()) do
            if item:IsA("Tool") and string.find(item.Name:lower(), "tank") then
                table.insert(foundTanks, item.Name)
            end
        end
    end
    
    if #foundTanks > 0 then
        return foundTanks
    else
        return nil
    end
end

-- Textbox for tank name
Tab:AddTextbox({
    Name = "Tank Name",
    Default = "",
    TextDisappear = false,
    Callback = function(Value)
        HealthExpander.targetTankName = Value
        OrionLib:MakeNotification({
            Name = "Health Expander",
            Content = "Tank name set to: " .. Value,
            Time = 2
        })
    end
})

-- Equip & Destroy Button
Tab:AddButton({
    Name = "Equip & Destroy Tank",
    Callback = function()
        equipAndDestroyTank()
    end
})

-- Auto-equip monitoring
task.spawn(function()
    local player = game.Players.LocalPlayer
    local lastTankCount = 0
    
    while true do
        if autoEquipEnabled and HealthExpander.targetTankName ~= "" then
            local currentTankCount = 0
            
            -- Count tanks in inventory
            for _, item in ipairs(player.Backpack:GetChildren()) do
                if item:IsA("Tool") and (item.Name == HealthExpander.targetTankName or 
                   string.find(item.Name:lower(), "tank")) then
                    currentTankCount = currentTankCount + 1
                end
            end
            
            if player.Character then
                for _, item in ipairs(player.Character:GetChildren()) do
                    if item:IsA("Tool") and (item.Name == HealthExpander.targetTankName or 
                       string.find(item.Name:lower(), "tank")) then
                        currentTankCount = currentTankCount + 1
                    end
                end
            end
            
            -- If new tanks detected, use them
            if currentTankCount > lastTankCount then
                equipAndDestroyTank()
            end
            
            lastTankCount = currentTankCount
        end
        
        task.wait(1) -- Check every second
    end
end)

Section = Tab:AddSection({
 Name = "Pet Clicker"
})

-- Pet Auto-Clicker
_G.petNames = {
    "Turkey Pet",
    "Chicken Noob Pet", 
    "Corrupted Black Hole Pet",
    "Pouwk",
    "BULLkiePouwK",
    "Sjebullepouwker",
    "BULL"
}

-- Variables
_G.selectedPet = ""
_G.isAutoClickingPet = false
_G.autoClickPetThread = nil

-- Function to safely stop threads
_G.stopPetThread = function()
    if _G.autoClickPetThread then
        task.cancel(_G.autoClickPetThread)
        _G.autoClickPetThread = nil
    end
end

-- Function to auto click pet
_G.autoClickPet = function()
    while _G.isAutoClickingPet do
        local success, err = pcall(function()
            local player = game.Players.LocalPlayer
            local displayName = player.DisplayName
            
            if not _G.selectedPet or _G.selectedPet == "" then
                warn("No pet selected")
                task.wait(0.5)
                return
            end
            
            local petFolder = workspace:WaitForChild("#GAME"):WaitForChild("Folders"):WaitForChild("VisibleInstances"):WaitForChild("HumanoidFolder"):WaitForChild("NPCFolder"):WaitForChild("PetFolder")
            local petName = displayName .. "'s " .. _G.selectedPet
            local petModel = petFolder:FindFirstChild(petName)
            
            if petModel then
                -- Look for ClickDetector in the pet model
                local clickDetector = petModel:FindFirstChildOfClass("ClickDetector")
                
                if clickDetector then
                    -- Auto click the pet
                    fireclickdetector(clickDetector)
                    task.wait(0.1) -- Click every 0.1 seconds
                else
                    -- If no ClickDetector found, notify and wait before retry
                    OrionLib:MakeNotification({
                        Name = "Pet Auto-Clicker",
                        Content = "ClickDetector not found for " .. petName .. ", retrying...",
                        Time = 3
                    })
                    task.wait(0.5) -- Wait 0.5 seconds before retry
                end
            else
                -- If pet model not found, notify and wait before retry
                OrionLib:MakeNotification({
                    Name = "Pet Auto-Clicker",
                    Content = "Pet model not found: " .. petName .. ", retrying...",
                    Time = 3
                })
                task.wait(0.5) -- Wait 0.5 seconds before retry
            end
        end)
        
        if not success then
            warn("AutoClickPet error: " .. tostring(err))
            task.wait(0.5)
        end
    end
end

-- Add dropdown for pet selection
Tab:AddDropdown({
    Name = "Select Pet",
    Default = "",
    Options = _G.petNames,
    Callback = function(Value)
        _G.selectedPet = Value
    end
})

-- Add toggle for auto-clicking pet
Tab:AddToggle({
    Name = "Auto Click Pet",
    Default = false,
    Callback = function(Value)
        _G.isAutoClickingPet = Value
        
        if Value then
            if _G.selectedPet == "" then
                OrionLib:MakeNotification({
                    Name = "Pet Auto-Clicker",
                    Content = "Please select a pet first!",
                    Time = 3
                })
                _G.isAutoClickingPet = false -- Reset the toggle state
                return
            end
            
            _G.autoClickPetThread = task.spawn(_G.autoClickPet)
            OrionLib:MakeNotification({
                Name = "Pet Auto-Clicker",
                Content = "Started auto-clicking " .. _G.selectedPet,
                Time = 3
            })
        else
            _G.stopPetThread() -- Fixed: Added _G. prefix
            -- Only show notification if it was actually running
            if _G.autoClickPetThread then
                OrionLib:MakeNotification({
                    Name = "Pet Auto-Clicker",
                    Content = "Stopped auto-clicking pet",
                    Time = 3
                })
            end
        end
    end
})

Section = Tab:AddSection({
 Name = "Secret Prices Shower"
})

Tab:AddButton({
    Name = "Check Bob Pet Costing Price",
    Callback = function()
            OrionLib:MakeNotification({
                Name = "Bob Cost Found",
                Content = "Bob Cost is: 14703 Cookies",
                Image = "rbxassetid://6034812623",
                Time = 5
                })
    end
})

Tab:AddButton({
    Name = "Check UZYeah Gun Costing Price",
    Callback = function()
            OrionLib:MakeNotification({
                Name = "UZYeah Cost Found",
                Content = "UZYeah Cost is: 0 Coins (Only if u tester/dev)",
                Image = "rbxassetid://6034812623",
                Time = 5
                })
    end
})

Tab:AddButton({
    Name = "Check Smiley Sucker Gun Costing Price",
    Callback = function()
            OrionLib:MakeNotification({
                Name = "Smiley Sucker Cost Found",
                Content = "Smiley Sucker Cost is: 0 Coins (Only if u tester/dev)",
                Image = "rbxassetid://6034812623",
                Time = 5
                })
    end
})

Tab:AddButton({
    Name = "Check Revolvahhh Gun Costing Price",
    Callback = function()
            OrionLib:MakeNotification({
                Name = "Revolvahhh Cost Found",
                Content = "Revolvahhh Cost is: 0 Coins (Only if u tester/dev)",
                Image = "rbxassetid://6034812623",
                Time = 5
                })
    end
})

Tab:AddButton({
    Name = "Check Easter Egg Pet Costing Price",
    Callback = function()
            OrionLib:MakeNotification({
                Name = "Easter Egg Cost Found",
                Content = "Easter Egg Cost is: -1 Coins",
                Image = "rbxassetid://6034812623",
                Time = 5
                })
    end
})

Tab:AddButton({
    Name = "Check Black Bas Pet Costing Price",
    Callback = function()
        local cost = Workspace:GetAttribute("BlackBasCost")
        if cost then
            -- Show notification if cost is found
            OrionLib:MakeNotification({
                Name = "Black Bas Cost Found",
                Content = "Black Bas Cost Coins is: " .. tostring(cost),
                Image = "rbxassetid://6034812623",
                Time = 5
            })
        else
            -- Show notification if cost is not found
            OrionLib:MakeNotification({
                Name = "Black Bas Cost Not Found",
                Content = "The 'BlackBasCost' attribute was not found in Workspace.",
                Image = "rbxassetid://6034812623",
                Time = 5
            })
        end
    end
})

Tab:AddButton({
    Name = "Check Clown Mouse Pet Costing Price",
    Callback = function()
            OrionLib:MakeNotification({
                Name = "Clown Mouse Cost Found",
                Content = "Clown Mouse Cost is: 0 Coins (Need Aniversary 2024 - Secret Badge)",
                Image = "rbxassetid://6034812623",
                Time = 5
                })
    end
})

Tab:AddButton({
    Name = "Check Evaluator Pet Costing Price",
    Callback = function()
            OrionLib:MakeNotification({
                Name = "Evaluator Cost Found",
                Content = "Evaluator Cost is: 0 Coins (Only if u tester/dev)",
                Image = "rbxassetid://6034812623",
                Time = 5
                })
    end
})

Tab:AddButton({
    Name = "Check Pouwk Pet Costing Price",
    Callback = function()
            OrionLib:MakeNotification({
                Name = "Pouwk Cost Found",
                Content = "Pouwk Cost is: 0 Coins (Need Meet the Co-Owner Badge)",
                Image = "rbxassetid://6034812623",
                Time = 5
                })
    end
})

Tab:AddButton({
    Name = "Check SGobbler Pet Costing Price",
    Callback = function()
            OrionLib:MakeNotification({
                Name = "SGobbler Cost Found",
                Content = "SGobbler Cost is: 0 Coins (Need Like Game + Join Group)",
                Image = "rbxassetid://6034812623",
                Time = 5
                })
    end
})

Tab:AddButton({
    Name = "Check Easter Doggo Pet Costing Price",
    Callback = function()
            OrionLib:MakeNotification({
                Name = "Easter Doggo Cost Found",
                Content = "Easter Doggo Cost is: 0 Coins (Need Easter 2024 - Egg-Gathering Gladiator Badge)",
                Image = "rbxassetid://6034812623",
                Time = 5
                })
    end
})

Tab:AddButton({
    Name = "Check Scammer Pet Costing Price",
    Callback = function()
            OrionLib:MakeNotification({
                Name = "Scammer Cost Found",
                Content = "Scammer Cost is: 0 Coins (Only if u tester/dev)",
                Image = "rbxassetid://6034812623",
                Time = 5
                })
    end
})

Tab:AddButton({
    Name = "Check BULLkiePouwk Pet Costing Price",
    Callback = function()
            OrionLib:MakeNotification({
                Name = "BULLkiePouwk Cost Found",
                Content = "BULLkiePouwk Cost is: 0 Coins (Need Secret Badge Valentines 2024)",
                Image = "rbxassetid://6034812623",
                Time = 5
                })
    end
})

Tab:AddButton({
    Name = "Check Cracked Bas Pet Costing Price",
    Callback = function()
            OrionLib:MakeNotification({
                Name = "Cracked Bas Cost Found",
                Content = "Cracked Bas Cost is: 0 Coins (Need Secret Badge 1)",
                Image = "rbxassetid://6034812623",
                Time = 5
                })                  
    end
})

Tab:AddButton({
    Name = "Check Sjebullepouwker Pet Costing Price",
    Callback = function()
            OrionLib:MakeNotification({
                Name = "Sjebullepouwker Cost Found",
                Content = "Sjebullepouwker Cost is: 0 Coins (Need Secret Badge Valentines 2025)",
                Image = "rbxassetid://6034812623",
                Time = 5
                })
    end
})

Tab:AddButton({
    Name = "Check BULL Pet Costing Price",
    Callback = function()
            OrionLib:MakeNotification({
                Name = "BULL Cost Found",
                Content = "BULL Cost is: 0 Coins (Need Meet the Owner Badge)",
                Image = "rbxassetid://6034812623",
                Time = 5
                })
    end
})

Tab:AddButton({
    Name = "Check Exclusive 100k Pet Costing Price",
    Callback = function()
            OrionLib:MakeNotification({
                Name = "Exclusive 100k Cost Found",
                Content = "Exclusive 100k Cost is: 100k Coins/Bites (Need Be First Player To Obtain)",
                Image = "rbxassetid://6034812623",
                Time = 5
                })
    end
})

Tab:AddButton({
    Name = "Check CRACKED Mode Item Costing Price",
    Callback = function()
            OrionLib:MakeNotification({
                Name = "CRACKED Mode Cost Found",
                Content = "CRACKED Mode Cost is: 0 Coins (Need Super Secret Badge 1)",
                Image = "rbxassetid://6034812623",
                Time = 5
                })
    end
})

Tab:AddButton({
    Name = "Check Bunny Ears Item Costing Price",
    Callback = function()
            OrionLib:MakeNotification({
                Name = "Bunny Ears Cost Found",
                Content = "Bunny Ears Cost is: 0 Coins (Need Hatched Badge)",
                Image = "rbxassetid://6034812623",
                Time = 5
                })
    end
})

Tab:AddButton({
    Name = "Check Eggstinction Rush X Item Costing Price",
    Callback = function()
            OrionLib:MakeNotification({
                Name = "Eggstinction Rush X Cost Found",
                Content = "Eggstinction Rush X Cost is: 0 Coins (Need Easter 2025 - Path to Eggstinction Badge)",
                Image = "rbxassetid://6034812623",
                Time = 5
                })
    end
})

Tab:AddButton({
    Name = "Check Hatred Item Costing Price",
    Callback = function()
            OrionLib:MakeNotification({
                Name = "Hatred Cost Found",
                Content = "Hatred Cost is: 0 Coins (Need Secret Badge 2)",
                Image = "rbxassetid://6034812623",
                Time = 5
                })
    end
})

Tab:AddButton({
    Name = "Check ??? Costing Price",
    Callback = function()
            OrionLib:MakeNotification({
                Name = "??? Cost Found",
                Content = "??? Cost is: 0 Coins (Need Super Secret Badge 2)",
                Image = "rbxassetid://6034812623",
                Time = 5
                })
    end
})

--CHANGELOGS
Tab = Window:MakeTab({
    Name = "Changelogs",
    Icon = "rbxassetid://8997387937",
    PremiumOnly = false
})

Section = Tab:AddSection({
 Name = "Changelogs Info"
})

Tab:AddParagraph("V. 3.5.7", [[
[-] Removed Negative Coins Option On Auto Eat Choosed Type Dropdown (Its Same As Stink Coins)
[x] Fixed Auto Eat Burgers Option On Auto Eat Choosed Type Dropdown (Was Eating Only 3-4 Burgers)
[x] Fixed Auto Eat Pouwkoins/BULLoney Options On Auto Eat Choosed Type Dropdown (Was Eating All Noobs)
[+] Added 3 More Guns To Support For All Auto Shoots (Firework Launcher, Nubids Bow and Pumpkin Launcher)
[+] Added Auto Use Hatred Tool Toggle
[x] Fixed Auto Bring NPC's Toggle (Was Bringing Bas From Chair Too)
[-] Removed Delete All NPC's Once Button
[+] Added Auto Spawn Noobs From Pad Toggle
[x] Fixed Teleport To Hatred Button (Was Path Issue)
[x] Fixed Click GERARD Button (Was Path Issue)
[+] Added Auto Click GERARD (24 Times Only Max) Toggle
[+] Added Anniversary 2024 - Secret Badge Section
[+] Added Auto Shoot Stuff Only On Party Balloons
[+] Added Auto Bring Clown Mouse (Kinda Works) Toggle
[+] Added Clown Mouse ESP Toggle
[+] Added On Equip/Unequip/Shop Tab New Items (Evaluator, Balloon and Party Hat)
[+] Added Boombox Stuff Section
[+] Added Put Any Roblox Music/Sound ID Textbox
[+] Added Apply Custom Music/Sound Button
[+] Added Show Evaluator Pet Price Button

Settings:

[+] = Added
[x] = Fixed/Changed
[-] = Removed
]])

Tab:AddParagraph("V. 3.4.1", [[
[x] Improved Anti Cheats Button (Bypasses 6 Anti Cheats)
[x] Fixed Check Server Type Button
[x] Fixed Auto Eat All/Smart Toggles (They Were Switched)
[x] Fixed Auto Eat Stuff (Was Location/Path Issue)
[x] Fixed Eggsterminator Tool In Auto Shoot Stuff (Doesnt Equip Anymore)
[x] Changed Hitbox Size Limit Max From 2048 To 1000 Slider
[x] Fixed Auto Teleport To NPC's Toggle (Was Location/Path Issue)
[x] Fixed Auto Bring NPC's Toggle (Was Location/Path Issue)
[+] Added Event Tab
[+] Added Halloween Stuff Label
[+] Added Christmas Stuff Label
[x] Changed Location Auto Teleport To Snowflakes Toggle
[x] Changed Location Auto Presents Stuff
[+] Added Snowflakes Hitbox Size Slider
[+] Added Auto Set Snowflakes Size Toggle
[x] Fixed Teleport To WhiteBas Button (Was Location/Path Issue)
[x] Fixed View WhiteBas Button (Was Location/Path Issue)
[x] Fixed Teleport To Hatred Button (Was Location/Path Issue)
[+] Added Super Secret Badge 2 Section (SOON)
[+] Added Click GERARD Button
[x] Changed Location Presents ESP Toggle
[x] Changed Location Souls ESP Toggle
[x] Changed Location Snowflakes ESP Toggle
[+] Added Item Name to Un/Equip Textbox
[+] Added Un/Equip Item From Shop Button
[+] Added Health Player's Shower Stuff
[x] Fixed Auto Click Pet Toggle (Was Location/Path Issue)
[+] Added Check ??? Costing Price Button
[x] Changed All Buttons/Toggles Names

Settings:

[+] = Added
[x] = Fixed/Changed
[-] = Removed
]])

Tab:AddParagraph("V. 3.1.2", [[
[x] Changed Orion Hub To Normal Colors
[x] Fixed/Improved Auto Eat Smart Toggle
[x] Fixed Auto Eat Burgers Option Toggle (Was Clicking Issue)
[+] Added 2 Things To Choose Auto Eat Dropdown (Pouwkoins, BULLoneys)
[x] Changed Auto Eat Cookies Method Dropdown (Now Supports Ginger Noobs)
[x] Fixed Delete NPC's Button/Toggle (Was Location/Path Issue)
[x] Fixed Auto Eggs Stuff (Was Location/Path/Eggs Detection Issue)
[x] Fixed Eggs ESP Toggle (Was Location/Path Issue)
[x] Fixed Big Issue Stuff (Was Spamming In Console About Below)
Content is not a valid member of Frame "Frame"

Settings:

[+] = Added
[x] = Fixed/Changed
[-] = Removed
]])

Tab:AddParagraph("V. 3.0.3", [[
[x] Changed Webhook Image (Now Thumbnail Is Christmas)
[x] Fixed Auto Eat Stuff
[+] Added Burgers To Choose Coins/Bites Type To Auto Eat Dropdown
[x] Fixed Auto Shoot Stuff (Main and Badges Tabs)
[+] Added Auto Teleport To Snowflakes Toggle
[+] Added Auto Set Instant CD To Presents Toggle
[+] Added Auto Teleport To Presents Toggle
[+] Added Auto Notify Spawned Present Toggle
[+] Added Check For Existing Presents Button
[+] Added Clear Present Detection History Button
[+] Added Auto Spam E Key Toggle
[x] Fixed Noobs/Werewolfs/ETC... ESP Toggle
[x] Fixed Presents ESP Toggle
[+] Added Snowflakes ESP Toggle
[+] Added Satan Santa Pet To Shop Stuff
[x] Fixed Health NPC's Stuff
[+] Added Other Stuff Tab
[+] Added Gun Name Textbox
[+] Added Bullet Size Textbox
[+] Added Shooting Cooldown Textbox
[+] Added Shooting Range Textbox
[+] Added Is Holding Down? Dropdown
[+] Added Apply Gun Modifications Button
[+] Added Tank Name Textbox
[+] Added Equip & Destroy Tank Button
[+] Added Freeze Button
[+] Added Unfreeze Button

Settings:

[+] = Added
[x] = Fixed/Changed
[-] = Removed
]])

Tab:AddParagraph("V. 2.7.6", [[
[x] Fixed Check Type Server Button
[x] Changed Auto Eat (Dead Noobs Only) [Now its in dropdown]
[x] Improved Auto Shoot Toggle On Main Tab (Now It Ignores CrackedBas and WhiteBas)
[+] Added Hitbox Stuff Section
[+] Added Hitbox Size Slider
[+] Added Choose Ur Sword Dropdown
[+] Added Auto Set Sword's Hitbox Toggle
[+] Added Spinner Stuff Section
[+] Added Spin Speed Textbox
[+] Added Spin Button
[+] Added Unspin Button
[+] Added Auto Update Spin Status Toggle
[+] Added Auto Remove Noobs Toggle
[x] Improved Auto Teleport To Eggs Toggle (Now It Ignores Egg From The Eggsterminator)
[x] Improved Auto Notify Eggs Toggle (Now It Ignores Egg From The Eggsterminator)
[x] Fixed Auto Shoot Toggle (Now Auto Shoots Only CrackedBas)
[x] Fixed Auto Shoot Toggle (Now Auto Shoots Only CrackedBas/WhiteBas)
[x] Fixed NPC Health Status Shower (Now Shows Even If Someone Has Long Name)
[+] Added Show Full NPC Names Button
[+] Added Search NPC by Name Textbox
[+] Added Clear NPC Health Display Button
[+] Added Reset to Normal View Button
[+] Added Freecam Enable Button
[+] Added Freecam Disable Button
[+] Added Noclip Toggle
[+] Added Freecam Speed Slider
[+] Added Freecam Sensitivity Slider
[+] Added Return to Character Button
[+] Added Freecam Status Shower
[+] Added Noclip Status Shower
[+] Added Safespot Stuff Section
[+] Added Create Platform Button
[+] Added Remove Platform Button
[+] Added Teleport Once Button
[+] Added Auto Teleport Toggle
[+] Added Teleport Every (seconds) Slider
[+] Added Auto Teleport Status Shower
[+] Added Platform Status Shower
[+] Added Next Teleport In Shower
[+] Added Quick Setup Button
[+] Added Full Reset
[x] Fixed Anti Void Button
[x] Fixed All Notification Appearing Randomly

Settings:

[+] = Added
[x] = Fixed/Changed
[-] = Removed
]])

Tab:AddParagraph("V. 2.3.3", [[
[x] Fixed Check Type Server Button (Now Tells U What Type Server U Are In)
[x] Improved Auto Eat Toggles (Now Does Faster)
[x] Fixed Auto Eat (Smart) Toggle (Now Goes From Amethyst-Rock And Rest If Not Find Any Type)
[x] Improved Auto Shoot Toggle (Now Does Faster)
[x] Improved Auto Teleport To Eggs Toggle (Now Does/Detects Faster And Doesnt Auto Stop When Toggle On)
[-] Removed Auto Collect Eggs Toggle (it doesnt work at all + not need)
[+] Added Auto Notify Spawned Egg Toggle (Sends U Auto Notification Which Egg Spawned)
[+] Added Check For Existing Egg Button
[+] Added Clear Egg Detection History
[+] Added Secret Badge 1 Section
[+] Added Auto Shoo Stuff To It (Only Shoots Normal Bas)
[+] Added Teleport To Room Button
[+] Added Teleport To WhiteBas Button (He Has To Kill U For SB1 Badge)
[+] Added Auto Shoo Stuff To It (Only Shoots Normal Bas/Cracked Bas)
[-] Removed Auto Close Door Toggle
[+] Added Teleport To Hatred Button
[x] Fixed Anti Void Button

Settings:

[+] = Added
[x] = Fixed/Changed
[-] = Removed
]])

Tab:AddParagraph("V. 2.2.0", [[
[x] Fixed Auto Eat Toggle (Shouldnt Freeze/Crash Roblox)
[x] Fixed Auto Shoot Toggle (Shouldnt Freeze/Crash Roblox)
[x] Fixed Auto Eggs Toggle (Shouldnt Freeze/Crash Roblox + No More Lags)
[+] Added Auto Spam ProximityPrompt (Spams Clicks Prompt [Its very useful to use on eggs auto click])
[x] Fixed Anti Void Button
[x] Fixed Anti Sit Toggle (Now Disables/Enables All Sits)
[-] Removed Auto Join To Bull's Server
[-] Removed Auto Join To Pouwk's Server

Settings:

[+] = Added
[x] = Fixed/Changed
[-] = Removed
]])

Tab:AddParagraph("V. 2.1.6", [[
[x] Changed Webhook Image (Now Thumbnail Is Normal)
[+] Added Paragraph Of Text "Attention U Can Get Banned If Doing On Public Reccomended On Private Server"
[+] Added Check Type Server Button (Sends Notification If Public Or Private Server)
[-] Removed Remove ProximityPrompt From Shop Button
[+] Added Others Section To Info Tab
[+] Added Insaenity Lvl Info
[+] Added BOSS Noob in Info
[+] Added House 1 Kllls Info
[+] Added House 2 Kllls Info
[+] Added House 3 Kllls Info
[+] Added House 4 Kllls Info
[+] Added House 5 Kllls Info
[x] Fixed Auto Set Info Toggle
[x] Changed All Auto Eat Toggles (Now They Auto Click [Screen] Too)
[+] Added Auto Eat (Dead Noobs Only) Toggle
[x] Fixed Auto Shoot Stuff
- Now The Eggsterminator Auto Equips
- Works Without Auto Breaking Randomly
[-] Removed Auto Click (0.01 Speed Click) Toggle [Useless cuz alr exists on auto eat toggles]
[x] Improved Auto Set Instant CD To Eggs (0.3 Sec CD) Toggle [Can still lag but not much]
[x] Improved Auto Collect Eggs Toggle [Can maybe still lag but not much]
[+] Added View WhiteBas Button
[+] Added Unview WhiteBas Button
[+] Added Auto Close Door Toggle
[x] FULLY Improved All ESP Toggles (No More Lag + Shows Highlight)
[+] Added Scripts Tab
[+] Added SAEN Script Button (ZScriptX)
[+] Added Copy Key For SAEN Script (ZScriptX)
[+] Added Inventory Tab
[+] Added Select Player Dropdown
[+] Added Update Player List Button
[+] Added "Inventory Items:", "Select a player to view their inventory" Paragraph
[+] Added Auto Set Info Toggle
[+] Added NPC Health Status Paragraph
[+] Added Auto Update NPC Status Toggle
[+] Added Update NPC Health Status Button
[x] Fixed Auto Click Pet/s Toggle (No More Shows Stop Notification Randomly)
[+] Added ZScriptX To Credits Tab
[+] Added Anti Void Button
[+] Added Anti Sit Toggle (no more get stuck)
[+] Added Anti Contributor | Owner Toggle (kicks you if finds high player rank)


Settings:

[+] = Added
[x] = Fixed/Changed
[-] = Removed
]])

Tab:AddParagraph("V. 1.7.9", [[
[+] Added Remove Shop Proximity Prompt (So Wont Auto Open Shop Everytime U AFK Farm Eggs)
[+] Added The Eggsterminator Tool To Support On Auto Shoot Toggle
[x] Fixed Auto Shoot Toggle (Now Doesn't Stops If Toggle Still Enabled)
[x] Fixed Noobs/Werewolfs/ETC... ESP Toggle
[+] Added Pet Clicker Section
[+] Added Select Pet Dropdown
[+] Added Auto Click Pet
[+] Added Check Bob Pet Costing Price Button
[+] Added Check UZYeah Gun Costing Price Button
[+] Added Check Smiley Sucker Gun Costing Price Button
[+] Added Check Revolvahhh Gun Costing Price Button
[+] Added Check Easter Egg Pet Costing Price Button
[+] Added Check Clown Mouse Pet Costing Price Button
[+] Added Check Pouwk Pet Costing Price Button
[+] Added Check SGobbler Pet Costing Price Button
[+] Added Check Easter Doggo Pet Costing Price Button
[+] Added Check Scammer Pet Costing Price Button
[+] Added Check BULLkiePouwk Pet Costing Price Button
[+] Added Check Cracked Bas Pet Costing Price Button
[+] Added Check Sjebullepouwker Pet Costing Price Button
[+] Added Check BULL Pet Costing Price Button
[+] Added Check Exclusive 100k Pet Costing Price Button
[+] Added Check CRACKED Mode Item Costing Price Button
[+] Added Check Bunny Ears Item Costing Price Button
[+] Added Check Eggstinction Rush X Item Costing Price Button
[+] Added Check Hatred Item Costing Price Button


Settings:

[+] = Added
[x] = Fixed/Changed
[-] = Removed
]])

Tab:AddParagraph("V. 1.4.7", [[
[x] Changed Webhook Image (Now Thumbnail Is Halloween)
[x] Improved Anti Cheat Button (Bypasses 3 More Anti Cheats)
[x] Fully Changed Sections In Main Tab
[x] Changed From "Auto Eat (For Positive/Stink Coins)" to "Auto Eat (For All Type Coins) Toggle
[+] Added Auto Eat (Smart From Value High To Low) Toggle
[+] Added Choose Coin Type To Auto Eat Dropdown
List Are: Positive Coins, Stink Coins, Cookies and King Coins
[+] Added Auto Eat (Choosed Type) Toggle
[x] Improved Auto Shoot Toggle (Supports More Guns Now)
[x] Improved Again Auto Shoot Toggle (For TMG V2, SMOGGTTLTSG It Holds)
[x] IMPROVED LAST TIME AGAIN AUTO SHOOT TOGGLE (Doesnt shoot Bas [From Chair], Dead and Invincible)
[x] Improved Auto Use Sword Toggle (Now Supports All Swords)
[-] Removed Auto Bring/Collect Eggs Toggle (It just doesnt collect at this point)
[-] Removed Auto Bring/Collect Presents Toggle (It just doesnt collect at this point)
[x] Changed From "SSB1/SB2 Badges" To "Badges" Tab
[+] Added Auto Notify Heads Spawn Toggle
[x] Fixed Noobs/Werewolfs/ETC... ESP Toggle (Showed 2 Names + Very Laggy Was)
[+] Added Anti Settings Section In Settings Tab
[+] Added Anti Kick Toggle
[+] Added Auto Join To Bull's Server Toggle
[+] Added Auto Join To Pouwk's Server Toggle


Settings:

[+] = Added
[x] = Fixed/Changed
[-] = Removed
]])

Tab:AddParagraph("V. 1.3.0", [[
[+] Added Bypass Mountain Anti Cheat (Prevent Crashing Roblox I Guess...) Button
[+] Added Dead Noob Type To Auto Eat (For Positive/Stink Coins) Toggle
[x] Improved Auto Bring Noobs/Werewolves Toggle (Brings Even If U Respawn)
[x] Improved Auto Bring/Collect Eggs Toggle (Brings Even If U Respawn)
[+] Added Auto Teleport To Eggs Toggle (Other Way Collecting Eggs)
[+] Added Auto Spam ProximityPrompts Toggle
[x] Fixed Eggs ESP Toggle
[x] FULLY Improved Shop Tab
[+] Added Secret Prices Shower Section


Settings:

[+] = Added
[x] = Fixed/Changed
[-] = Removed
]])

Tab:AddParagraph("V. 1.2.1", [[
[x] Changed Webhook Script Messager Sender Info (Now Shows Image)
[x] Improved Auto Eat Toggle (Positive) (Now It Doesnt Eat Negative Type Noobs)
[-] Removed Auto Eat Toggle (Negative) (They Changed Negative To Stink Coins)
[-] Removed Auto Shoot Gui Button (Dont really need it)
[+] Added Gun Name Textbox (Example Minigun)
[+] Added Shooting Speed Textbox (Example 6)
[+] Added Auto Shoot Toggle (Auto Shoots Can Be Stopped)
[x] Improved Auto Bring Noobs/Werewolfs Toggle (Now a bit further and infront)
[-] Removed Auto Set PP To 0 CD Button (Very Much Lags)
[+] Added Auto Set PP To 0 CD Toggle (For Instant Collecting Eggs)
[+] Added Auto Bring/Collect Eggs Toggle (Useful If Giant Egg Drops Then U Instant Collect It)
[+] Added Auto Set PP To 0 CD Toggle (For Instant Collecting Eggs)
[+] Added Auto Bring/Collect Eggs Toggle (Useful If Giant Egg Drops Then U Instant Collect It)
[+] Added Auto Bring/Collect Presents Toggle (Useful If Present Drops Then U Can Auto Collect It)
[-] Removed Auto Teleport To Eggs Toggle (Very Easy It Makes U To Teleport To Mountain Where U Get Crashed)
[x] Changed Collect All Bacon Parts Button (Now Its In Badges SB2 Section)
[+] Added Enable/Disable Fire Button (For SB2)
[+] Added Equip All Bacon Parts [Stand Close To Fire] (Equips All 6 Parts Also Tells If Missing Or Success)
[+] Added ESP Tab
[+] Added Players ESP Toggle
[+] Added Noobs/Werewolfs/ETC... ESP Toggle
[+] Added Bacon Parts ESP Toggle
[+] Added Eggs ESP Toggle
[+] Added Presents ESP Toggle
[+] Added Souls ESP Toggle
[+] Added Vunerability Tab
[+] Added Check Black Bas Costing Price Button


Settings:

[+] = Added
[x] = Fixed/Changed
[-] = Removed
]])

Tab:AddParagraph("V. 1.0.0", [[
[+] SCRIPT RELEASED


Settings:

[+] = Added
[x] = Fixed/Changed
[-] = Removed
]])

--CREDITS
Tab = Window:MakeTab({
 Name = "Credits",
 Icon = "rbxassetid://7743875759",
 PremiumOnly = false
 })

Section = Tab:AddSection({
 Name = "Credits Users"
})

Tab:AddLabel("Scripter - (Youtube, Discord)")
Tab:AddLabel("ZScriptX - Discord")

Section = Tab:AddSection({
 Name = "Helpers"
})

Tab:AddLabel("ZScriptX - Auto Shoot")

Section = Tab:AddSection({
 Name = "Links"
})

Tab:AddButton({
 Name = "Scripter (Youtube)",
 Callback = function()
setclipboard("https://www.youtube.com/@Scripter-Coder")
end
})

Tab:AddButton({
 Name = "Scripter (Discord)",
 Callback = function()
setclipboard("https://discord.gg/k8vJHZM6")
end
})

Tab:AddButton({
 Name = "ZScriptX (Discord)",
 Callback = function()
setclipboard("https://discord.gg/HvevRJVWWm")
end
})

--SETTINGS
Tab = Window:MakeTab({
 Name = "Settings",
 Icon = "rbxassetid://7734053495",
 PremiumOnly = false
 })

 -- ========== Global Cleanup System ==========
local cleanupConnections = {}
local cleanupControllers = {}

-- Function to clean up all connections
local function cleanupAllConnections()
    for _, connection in pairs(cleanupConnections) do
        if connection and typeof(connection) == "RBXScriptConnection" then
            connection:Disconnect()
        end
    end
    cleanupConnections = {}
    
    -- Clean up controllers
    for _, controller in pairs(cleanupControllers) do
        if controller and controller.cleanup then
            controller:cleanup()
        end
    end
    cleanupControllers = {}
end

-- ========== Freecam and Noclip System ==========
local FreecamController = {
    -- Freecam variables
    isFreecamEnabled = false,
    freecamConnection = nil,
    originalCameraType = nil,
    originalCFrame = nil,
    
    -- Noclip variables
    isNoclipEnabled = false,
    noclipConnection = nil,
    
    -- Freecam control variables
    freecamSpeed = 5,
    freecamSensitivity = 0.5,
    freecamCFrame = nil
}

-- Function to enable freecam
function FreecamController:enableFreecam()
    if self.isFreecamEnabled then return end
    
    local player = game.Players.LocalPlayer
    local camera = workspace.CurrentCamera
    
    -- Store original camera state
    self.originalCameraType = camera.CameraType
    self.originalCFrame = camera.CFrame
    
    -- Set camera to Scriptable
    camera.CameraType = Enum.CameraType.Scriptable
    
    -- Set initial freecam position (slightly above character)
    local character = player.Character
    if character then
        local humanoidRootPart = character:FindFirstChild("HumanoidRootPart")
        if humanoidRootPart then
            self.freecamCFrame = humanoidRootPart.CFrame + Vector3.new(0, 5, 0)
            camera.CFrame = self.freecamCFrame
        else
            self.freecamCFrame = CFrame.new(0, 10, 0)
            camera.CFrame = self.freecamCFrame
        end
    else
        self.freecamCFrame = CFrame.new(0, 10, 0)
        camera.CFrame = self.freecamCFrame
    end
    
    -- Start freecam control loop
    self.isFreecamEnabled = true
    self.freecamConnection = game:GetService("RunService").RenderStepped:Connect(function(deltaTime)
        if not self.isFreecamEnabled then return end
        
        local inputService = game:GetService("UserInputService")
        
        -- Get input for movement
        local moveVector = Vector3.new(0, 0, 0)
        
        if inputService:IsKeyDown(Enum.KeyCode.W) then
            moveVector = moveVector + camera.CFrame.LookVector
        end
        if inputService:IsKeyDown(Enum.KeyCode.S) then
            moveVector = moveVector - camera.CFrame.LookVector
        end
        if inputService:IsKeyDown(Enum.KeyCode.A) then
            moveVector = moveVector - camera.CFrame.RightVector
        end
        if inputService:IsKeyDown(Enum.KeyCode.D) then
            moveVector = moveVector + camera.CFrame.RightVector
        end
        if inputService:IsKeyDown(Enum.KeyCode.Space) then
            moveVector = moveVector + Vector3.new(0, 1, 0)
        end
        if inputService:IsKeyDown(Enum.KeyCode.LeftControl) or inputService:IsKeyDown(Enum.KeyCode.RightControl) then
            moveVector = moveVector - Vector3.new(0, 1, 0)
        end
        
        -- Normalize and apply speed
        if moveVector.Magnitude > 0 then
            moveVector = moveVector.Unit * self.freecamSpeed
            self.freecamCFrame = self.freecamCFrame + (moveVector * deltaTime * 60)
        end
        
        -- Mouse look
        local delta = inputService:GetMouseDelta()
        if delta.X ~= 0 or delta.Y ~= 0 then
            local yaw = delta.X * self.freecamSensitivity * 0.01
            local pitch = delta.Y * self.freecamSensitivity * 0.01
            
            local currentCFrame = self.freecamCFrame
            local yawCFrame = CFrame.fromAxisAngle(Vector3.new(0, 1, 0), -yaw)
            local pitchCFrame = CFrame.fromAxisAngle(currentCFrame.RightVector, -pitch)
            
            self.freecamCFrame = currentCFrame * yawCFrame * pitchCFrame
        end
        
        -- Apply to camera
        camera.CFrame = self.freecamCFrame
    end)
    
    OrionLib:MakeNotification({
        Name = "Freecam",
        Content = "Freecam enabled! Use WASD + Space/Ctrl to move, mouse to look",
        Image = "rbxassetid://4483345998",
        Time = 5
    })
end

-- Function to disable freecam
function FreecamController:disableFreecam()
    if not self.isFreecamEnabled then return end
    
    -- Stop freecam control loop
    self.isFreecamEnabled = false
    
    if self.freecamConnection then
        self.freecamConnection:Disconnect()
        self.freecamConnection = nil
    end
    
    -- Restore original camera
    local camera = workspace.CurrentCamera
    camera.CameraType = self.originalCameraType or Enum.CameraType.Custom
    
    -- Optionally return to character
    local player = game.Players.LocalPlayer
    local character = player.Character
    if character then
        local humanoidRootPart = character:FindFirstChild("HumanoidRootPart")
        if humanoidRootPart then
            camera.CFrame = humanoidRootPart.CFrame + Vector3.new(0, 5, -10)
        end
    end
    
    self.freecamCFrame = nil
    self.originalCameraType = nil
    self.originalCFrame = nil
end

-- Function to enable noclip
function FreecamController:enableNoclip()
    if self.isNoclipEnabled then return end
    
    self.isNoclipEnabled = true
    
    -- Noclip function
    local function noclipLoop()
        if not self.isNoclipEnabled then return end
        
        local character = game.Players.LocalPlayer.Character
        if character then
            for _, part in pairs(character:GetDescendants()) do
                if part:IsA("BasePart") and part.CanCollide then
                    part.CanCollide = false
                end
            end
        end
    end
    
    -- Start noclip loop
    self.noclipConnection = game:GetService("RunService").Stepped:Connect(noclipLoop)
    
    OrionLib:MakeNotification({
        Name = "Noclip",
        Content = "Noclip enabled - You can pass through walls",
        Image = "rbxassetid://4483345998",
        Time = 3
    })
end

-- Function to disable noclip
function FreecamController:disableNoclip()
    if not self.isNoclipEnabled then return end
    
    self.isNoclipEnabled = false
    
    if self.noclipConnection then
        self.noclipConnection:Disconnect()
        self.noclipConnection = nil
    end
    
    -- Restore collision
    local character = game.Players.LocalPlayer.Character
    if character then
        for _, part in pairs(character:GetDescendants()) do
            if part:IsA("BasePart") then
                part.CanCollide = true
            end
        end
    end
end

-- Cleanup function for FreecamController
function FreecamController:cleanup()
    self:disableFreecam()
    self:disableNoclip()
end

-- Cleanup when player leaves
game.Players.LocalPlayer.CharacterRemoving:Connect(function()
    FreecamController:cleanup()
end)

-- Add to cleanup controllers
table.insert(cleanupControllers, FreecamController)

Section = Tab:AddSection({
 Name = "Other Stuff"
})

-- Freecam Enable Button
Tab:AddButton({
    Name = "Freecam Enable",
    Callback = function()
        FreecamController:enableFreecam()
    end
})

-- Freecam Disable Button
Tab:AddButton({
    Name = "Freecam Disable",
    Callback = function()
        FreecamController:disableFreecam()
    end
})

-- Noclip Toggle
Tab:AddToggle({
    Name = "Noclip",
    Default = false,
    Callback = function(value)
        if value then
            FreecamController:enableNoclip()
        else
            FreecamController:disableNoclip()
        end
    end
})

-- Freecam speed slider
Tab:AddSlider({
    Name = "Freecam Speed",
    Min = 1,
    Max = 50,
    Default = 5,
    Increment = 1,
    ValueName = "speed",
    Callback = function(value)
        FreecamController.freecamSpeed = value
    end
})

-- Freecam sensitivity slider
Tab:AddSlider({
    Name = "Freecam Sensitivity",
    Min = 0.1,
    Max = 2,
    Default = 0.5,
    Increment = 0.1,
    ValueName = "sensitivity",
    Callback = function(value)
        FreecamController.freecamSensitivity = value
    end
})

-- Quick return to character button
Tab:AddButton({
    Name = "Return to Character",
    Callback = function()
        if FreecamController.isFreecamEnabled then
            local player = game.Players.LocalPlayer
            local character = player.Character
            local camera = workspace.CurrentCamera
            
            if character then
                local humanoidRootPart = character:FindFirstChild("HumanoidRootPart")
                if humanoidRootPart then
                    FreecamController.freecamCFrame = humanoidRootPart.CFrame + Vector3.new(0, 5, -10)
                    camera.CFrame = FreecamController.freecamCFrame
                end
            end
        end
    end
})

-- Status indicators
local freecamStatus = Tab:AddParagraph("Freecam Status:", "Disabled")
local noclipStatus = Tab:AddParagraph("Noclip Status:", "Disabled")

-- Store references for cleanup
local statusParagraphs = {
    freecamStatus = freecamStatus,
    noclipStatus = noclipStatus
}

-- Safe status update function
local function updateFreecamStatus()
    if not statusParagraphs.freecamStatus or not statusParagraphs.noclipStatus then
        return -- GUI destroyed
    end
    
    local success1, result1 = pcall(function()
        if FreecamController.isFreecamEnabled then
            statusParagraphs.freecamStatus:Set("Freecam Status: Enabled (Speed: " .. FreecamController.freecamSpeed .. ")")
        else
            statusParagraphs.freecamStatus:Set("Freecam Status: Disabled")
        end
    end)
    
    local success2, result2 = pcall(function()
        if FreecamController.isNoclipEnabled then
            statusParagraphs.noclipStatus:Set("Noclip Status: Enabled")
        else
            statusParagraphs.noclipStatus:Set("Noclip Status: Disabled")
        end
    end)
end

-- Create and store status update connection
local freecamStatusConnection = game:GetService("RunService").Heartbeat:Connect(function()
    updateFreecamStatus()
end)

table.insert(cleanupConnections, freecamStatusConnection)

Section = Tab:AddSection({
 Name = "Safespot Stuff"
})

-- ========== Teleport Platform System ==========
local TeleportPlatform = {
    Players = game:GetService("Players"),
    RunService = game:GetService("RunService"),
    
    -- Platform settings
    platformName = "TeleportPlatform",
    platform = nil,
    platformPosition = Vector3.new(55, -46, -262),
    platformSize = Vector3.new(100, 1, 100),
    
    -- Control variables
    isAutoTeleportEnabled = false,
    teleportConnection = nil,
    teleportCooldown = 10,
    lastTeleportTime = 0,
    isPlatformCreated = false
}

-- Initialize player
TeleportPlatform.Player = TeleportPlatform.Players.LocalPlayer

-- Function to create the platform
function TeleportPlatform:createPlatform()
    -- Remove old platform if exists
    if workspace:FindFirstChild(self.platformName) then
        workspace[self.platformName]:Destroy()
    end
    
    -- Create new platform
    local platform = Instance.new("Part")
    platform.Name = self.platformName
    platform.Size = self.platformSize
    platform.Position = self.platformPosition
    platform.Anchored = true
    platform.CanCollide = true
    platform.Transparency = 0.5
    platform.Color = Color3.new(1, 0.5, 0)
    platform.Material = Enum.Material.Neon
    platform.Parent = workspace
    
    -- Add light for better visibility
    local light = Instance.new("SurfaceLight", platform)
    light.Brightness = 0.5
    light.Face = Enum.NormalId.Top
    light.Range = 20
    light.Color = Color3.new(1, 0.6, 0.2)
    
    self.platform = platform
    self.isPlatformCreated = true
    
    OrionLib:MakeNotification({
        Name = "Platform",
        Content = "Platform created at position (55, -46, -262)",
        Image = "rbxassetid://4483345998",
        Time = 3
    })
    
    return platform
end

-- Function to remove the platform
function TeleportPlatform:removePlatform()
    if workspace:FindFirstChild(self.platformName) then
        workspace[self.platformName]:Destroy()
        self.platform = nil
        self.isPlatformCreated = false
        
        OrionLib:MakeNotification({
            Name = "Platform",
            Content = "Platform removed",
            Image = "rbxassetid://4483345998",
            Time = 3
        })
    end
end

-- Function to teleport to platform
function TeleportPlatform:teleportToPlatform()
    local character = self.Player.Character
    if not character then 
        return false
    end
    
    local humanoidRootPart = character:FindFirstChild("HumanoidRootPart")
    if not humanoidRootPart then 
        return false
    end
    
    -- Create platform if it doesn't exist
    if not self.isPlatformCreated then
        self:createPlatform()
    end
    
    -- Check if humanoid is alive
    local humanoid = character:FindFirstChildOfClass("Humanoid")
    if not humanoid or humanoid.Health <= 0 then
        return false
    end
    
    -- Teleport directly to platform (5 studs above it)
    humanoidRootPart.CFrame = CFrame.new(self.platformPosition + Vector3.new(0, 5, 0))
    self.lastTeleportTime = tick()
    
    OrionLib:MakeNotification({
        Name = "Teleport",
        Content = "Teleported to platform!",
        Image = "rbxassetid://4483345998",
        Time = 2
    })
    
    return true
end

-- Function to start auto-teleport
function TeleportPlatform:startAutoTeleport()
    if self.isAutoTeleportEnabled then return end
    
    -- Create platform if it doesn't exist
    if not self.isPlatformCreated then
        self:createPlatform()
    end
    
    self.isAutoTeleportEnabled = true
    self.lastTeleportTime = 0
    
    -- Start auto-teleport loop
    self.teleportConnection = self.RunService.Heartbeat:Connect(function()
        if not self.isAutoTeleportEnabled then return end
        
        local currentTime = tick()
        
        -- Check if cooldown has passed
        if currentTime - self.lastTeleportTime >= self.teleportCooldown then
            self:teleportToPlatform()
        end
    end)
    
    OrionLib:MakeNotification({
        Name = "Auto Teleport",
        Content = "Auto-teleport enabled! Teleporting every " .. self.teleportCooldown .. " seconds",
        Image = "rbxassetid://4483345998",
        Time = 3
    })
end

-- Function to stop auto-teleport
function TeleportPlatform:stopAutoTeleport()
    if not self.isAutoTeleportEnabled then return end
    
    self.isAutoTeleportEnabled = false
    
    if self.teleportConnection then
        self.teleportConnection:Disconnect()
        self.teleportConnection = nil
    end
    
    OrionLib:MakeNotification({
        Name = "Auto Teleport",
        Content = "Auto-teleport disabled",
        Image = "rbxassetid://4483345998",
        Time = 3
    })
end

-- Cleanup function for TeleportPlatform
function TeleportPlatform:cleanup()
    self:stopAutoTeleport()
    self:removePlatform()
end

-- Add to cleanup controllers
table.insert(cleanupControllers, TeleportPlatform)

-- Create Platform Button
Tab:AddButton({
    Name = "Create Platform",
    Callback = function()
        TeleportPlatform:createPlatform()
    end
})

-- Remove Platform Button
Tab:AddButton({
    Name = "Remove Platform",
    Callback = function()
        TeleportPlatform:removePlatform()
        
        -- Also stop auto-teleport if platform is removed
        if TeleportPlatform.isAutoTeleportEnabled then
            TeleportPlatform:stopAutoTeleport()
        end
    end
})

-- Teleport Once Button
Tab:AddButton({
    Name = "Teleport Once",
    Callback = function()
        TeleportPlatform:teleportToPlatform()
    end
})

-- Toggle for Auto Teleport
Tab:AddToggle({
    Name = "Auto Teleport",
    Default = false,
    Callback = function(value)
        if value then
            TeleportPlatform:startAutoTeleport()
        else
            TeleportPlatform:stopAutoTeleport()
        end
    end
})

-- Slider for teleportation frequency
Tab:AddSlider({
    Name = "Teleport Every (seconds)",
    Min = 1,
    Max = 60,
    Default = 10,
    Increment = 1,
    ValueName = "seconds",
    Callback = function(value)
        TeleportPlatform.teleportCooldown = value
        
        -- If auto-teleport is active, restart it with new cooldown
        if TeleportPlatform.isAutoTeleportEnabled then
            TeleportPlatform:stopAutoTeleport()
            task.wait(0.1)
            TeleportPlatform:startAutoTeleport()
        end
    end
})

-- Platform status indicators
local teleportStatus = Tab:AddParagraph("Auto Teleport Status:", "Disabled")
local platformStatus = Tab:AddParagraph("Platform Status:", "Not created")
local cooldownStatus = Tab:AddParagraph("Next Teleport In:", "N/A")

-- Store references
statusParagraphs.teleportStatus = teleportStatus
statusParagraphs.platformStatus = platformStatus
statusParagraphs.cooldownStatus = cooldownStatus

-- Safe platform status update function
local function updatePlatformStatus()
    if not statusParagraphs.teleportStatus or not statusParagraphs.platformStatus or not statusParagraphs.cooldownStatus then
        return -- GUI destroyed
    end
    
    local success1, result1 = pcall(function()
        -- Auto teleport status
        if TeleportPlatform.isAutoTeleportEnabled then
            statusParagraphs.teleportStatus:Set("Auto Teleport Status: Enabled (" .. TeleportPlatform.teleportCooldown .. "s interval)")
        else
            statusParagraphs.teleportStatus:Set("Auto Teleport Status: Disabled")
        end
    end)
    
    local success2, result2 = pcall(function()
        -- Platform status
        if TeleportPlatform.isPlatformCreated then
            statusParagraphs.platformStatus:Set("Platform Status: Created at (55, -46, -262)")
        else
            statusParagraphs.platformStatus:Set("Platform Status: Not created")
        end
    end)
    
    local success3, result3 = pcall(function()
        -- Cooldown status
        if TeleportPlatform.isAutoTeleportEnabled then
            local currentTime = tick()
            local timeSinceLast = currentTime - TeleportPlatform.lastTeleportTime
            local timeLeft = math.max(0, TeleportPlatform.teleportCooldown - timeSinceLast)
            
            if timeLeft > 0 then
                statusParagraphs.cooldownStatus:Set("Next Teleport In: " .. string.format("%.1f", timeLeft) .. " seconds")
            else
                statusParagraphs.cooldownStatus:Set("Next Teleport In: Ready!")
            end
        else
            statusParagraphs.cooldownStatus:Set("Next Teleport In: N/A")
        end
    end)
end

-- Create and store platform status update connection
local platformStatusConnection = game:GetService("RunService").Heartbeat:Connect(function()
    updatePlatformStatus()
end)

table.insert(cleanupConnections, platformStatusConnection)

-- Quick setup button (creates platform and enables auto-teleport)
Tab:AddButton({
    Name = "Quick Setup",
    Callback = function()
        if not TeleportPlatform.isPlatformCreated then
            TeleportPlatform:createPlatform()
            task.wait(0.5)
        end
        
        if not TeleportPlatform.isAutoTeleportEnabled then
            TeleportPlatform:startAutoTeleport()
        end
        
        OrionLib:MakeNotification({
            Name = "Quick Setup",
            Content = "Platform created and auto-teleport enabled!",
            Image = "rbxassetid://4483345998",
            Time = 3
        })
    end
})

-- Full reset button
Tab:AddButton({
    Name = "Full Reset",
    Callback = function()
        TeleportPlatform:cleanup()
        
        OrionLib:MakeNotification({
            Name = "Reset",
            Content = "Platform removed and auto-teleport stopped",
            Image = "rbxassetid://4483345998",
            Time = 3
        })
    end
})

-- ========== Freeze/Unfreeze System ==========
local FreezeSystem = {
    isFrozen = false,
    originalAnchored = {},
    originalVelocity = nil,
    originalGravity = nil
}

-- Function to freeze character
local function freezeCharacter()
    local player = game.Players.LocalPlayer
    local character = player.Character
    if not character then return end
    
    -- Check if already frozen
    if FreezeSystem.isFrozen then
        OrionLib:MakeNotification({
            Name = "Freeze",
            Content = "Character is already frozen!",
            Image = "rbxassetid://7734059095",
            Time = 2
        })
        return
    end
    
    -- Save original states
    FreezeSystem.originalAnchored = {}
    FreezeSystem.originalVelocity = Vector3.new(0, 0, 0)
    
    -- Get workspace gravity
    FreezeSystem.originalGravity = workspace.Gravity
    
    -- Freeze all parts in character
    for _, part in ipairs(character:GetDescendants()) do
        if part:IsA("BasePart") then
            -- Save original anchored state
            FreezeSystem.originalAnchored[part] = part.Anchored
            
            -- Anchor the part
            part.Anchored = true
            
            -- Stop any velocity
            part.Velocity = Vector3.new(0, 0, 0)
            part.RotVelocity = Vector3.new(0, 0, 0)
            
            -- Also set CFrame to prevent drifting
            part.CFrame = part.CFrame
        end
    end
    
    -- Freeze humanoid
    local humanoid = character:FindFirstChildOfClass("Humanoid")
    if humanoid then
        humanoid.WalkSpeed = 0
        humanoid.JumpPower = 0
        
        -- Also try to stop any animations
        for _, track in pairs(humanoid:GetPlayingAnimationTracks()) do
            track:Stop()
        end
    end
    
    -- Set workspace gravity to 0 to prevent falling
    workspace.Gravity = 0
    
    -- Set state
    FreezeSystem.isFrozen = true
    
    OrionLib:MakeNotification({
        Name = "Freeze",
        Content = "Character frozen successfully!",
        Image = "rbxassetid://4483345998",
        Time = 3
    })
    
    warn("Character frozen - All parts anchored, gravity disabled")
end

-- Function to unfreeze character
local function unfreezeCharacter()
    local player = game.Players.LocalPlayer
    local character = player.Character
    if not character then return end
    
    -- Check if not frozen
    if not FreezeSystem.isFrozen then
        OrionLib:MakeNotification({
            Name = "Unfreeze",
            Content = "Character is not frozen!",
            Image = "rbxassetid://7734059095",
            Time = 2
        })
        return
    end
    
    -- Restore all parts
    for part, wasAnchored in pairs(FreezeSystem.originalAnchored) do
        if part and part.Parent then
            part.Anchored = wasAnchored
        end
    end
    
    -- Restore humanoid
    local humanoid = character:FindFirstChildOfClass("Humanoid")
    if humanoid then
        humanoid.WalkSpeed = 16
        humanoid.JumpPower = 50
    end
    
    -- Restore workspace gravity
    if FreezeSystem.originalGravity then
        workspace.Gravity = FreezeSystem.originalGravity
    else
        workspace.Gravity = 196.2
    end
    
    -- Clear saved data
    FreezeSystem.originalAnchored = {}
    FreezeSystem.originalVelocity = nil
    FreezeSystem.originalGravity = nil
    
    -- Set state
    FreezeSystem.isFrozen = false
    
    OrionLib:MakeNotification({
        Name = "Unfreeze",
        Content = "Character unfrozen successfully!",
        Image = "rbxassetid://4483345998",
        Time = 3
    })
    
    warn("Character unfrozen - Normal movement restored")
end

-- Freeze Button (Full Freeze)
Tab:AddButton({
    Name = "Freeze",
    Callback = function()
        freezeCharacter()
    end
})

-- Unfreeze Button (Full Unfreeze)
Tab:AddButton({
    Name = "Unfreeze",
    Callback = function()
        unfreezeCharacter()
    end
})

Section = Tab:AddSection({
 Name = "Anti Settings"
})

Tab:AddButton({
    Name = "Anti Void",
    Callback = function()
        -- ANTI VOID --
        if workspace:FindFirstChild("AntiVoid1") == nil then
            -- Function to create an anti-void part
            local function createAntiVoidPart(name, positionX, positionY, positionZ, color)
                local AntiVoid = Instance.new("Part", workspace)
                AntiVoid.Name = name
                
                -- Position the platform
                local horizontalOffset = 0
                local verticalOffset = positionY
                
                -- Identity matrix CFrame with position offset
                AntiVoid.CFrame = CFrame.new(positionX, positionY, positionZ, 1, 0, 0, 0, 1, 0, 0, 0, 1)
                
                AntiVoid.Size = Vector3.new(2044, 1, 2044)
                AntiVoid.Anchored = true
                AntiVoid.CanCollide = true
                AntiVoid.Transparency = 0.8
                AntiVoid.Material = Enum.Material.Neon
                AntiVoid.BrickColor = BrickColor.new(color)
                
                -- Add a slight glow effect
                local SurfaceLight = Instance.new("SurfaceLight", AntiVoid)
                SurfaceLight.Brightness = 0.5
                SurfaceLight.Face = Enum.NormalId.Top
                SurfaceLight.Range = 10
                SurfaceLight.Color = Color3.new(0, 0.5, 1)
                
                -- Add a second light for bottom side
                local SurfaceLightBottom = Instance.new("SurfaceLight", AntiVoid)
                SurfaceLightBottom.Brightness = 0.3
                SurfaceLightBottom.Face = Enum.NormalId.Bottom
                SurfaceLightBottom.Range = 10
                SurfaceLightBottom.Color = Color3.new(0, 0.3, 0.8)
                
                -- Add decorative edges for better visibility
                local SelectionBox = Instance.new("SelectionBox", AntiVoid)
                SelectionBox.Adornee = AntiVoid
                SelectionBox.Color3 = Color3.new(0, 0.7, 1)
                SelectionBox.Transparency = 0.5
                SelectionBox.LineThickness = 0.05
                
                -- Add slight horizontal floating animation (back and forth)
                local floating = true
                local floatSpeed = 0.5
                local floatDistance = 10
                local startTime = tick()
                
                -- Create a floating animation thread
                task.spawn(function()
                    while floating and AntiVoid and AntiVoid.Parent do
                        local elapsedTime = tick() - startTime
                        
                        -- Calculate horizontal offset based on sine wave
                        local horizontalOffset = math.sin(elapsedTime * floatSpeed) * floatDistance
                        
                        -- Update position (keep Y at original, move X and Z)
                        AntiVoid.CFrame = CFrame.new(
                            positionX + horizontalOffset,
                            positionY,
                            positionZ + horizontalOffset,
                            1, 0, 0, 
                            0, 1, 0, 
                            0, 0, 1
                        )
                        
                        task.wait(0.033)
                    end
                end)
                
                -- Store reference to stop animation when part is removed
                AntiVoid.Destroying:Connect(function()
                    floating = false
                end)
                
                return AntiVoid
            end
            
            -- Create 3 anti-void parts at different positions
            local part1 = createAntiVoidPart("AntiVoid1", 0, -40, 0, "Bright blue")
            local part2 = createAntiVoidPart("AntiVoid2", 992, -40, -233, "Bright green")
            local part3 = createAntiVoidPart("AntiVoid3", -1018, -40, -222, "Bright yellow")
            
            OrionLib:MakeNotification({
                Name = "Anti Void", 
                Content = "3 Floating anti-voids created!\n1: (0, -40, 0)\n2: (992, -40, -233)\n3: (-1018, -40, -222)",
                Image = "rbxassetid://7733715400",
                Time = 5
            })
        else
            -- Remove all anti-void parts
            local removedCount = 0
            for _, part in pairs(workspace:GetChildren()) do
                if string.find(part.Name, "AntiVoid") then
                    part:Destroy()
                    removedCount = removedCount + 1
                end
            end
            OrionLib:MakeNotification({
                Name = "Anti Void",
                Content = removedCount .. " anti-voids removed successfully!",
                Image = "rbxassetid://7733715400",
                Time = 3
            })
        end
    end
})

-- Anti Sit Toggle
local isAntiSit = false

-- Function to set all seats CanTouch property
local function setAllSeatsCanTouch(canTouch)
    for _, seat in pairs(workspace:GetDescendants()) do
        if seat:IsA("VehicleSeat") or seat:IsA("Seat") then
            seat.CanTouch = canTouch
        end
    end
end

-- Add toggle for Anti Sit
Tab:AddToggle({
    Name = "Anti Sit",
    Default = false,
    Callback = function(Value)
        isAntiSit = Value
        
        if Value then
            setAllSeatsCanTouch(false)
            warn("Anti Sit: All seats disabled")
        else
            setAllSeatsCanTouch(true)
            warn("Anti Sit: All seats enabled")
        end
    end
})

AntiAfk = Tab:AddToggle({
 Name = "Anti Afk",
 Default = false,
 Callback = function(Value)
  _G.AntiAfk = Value
  local VirtualUser = game:GetService('VirtualUser')
  
  if Value then
      local antiAfkConnection = game:GetService('Players').LocalPlayer.Idled:Connect(function()
          VirtualUser:CaptureController()
          VirtualUser:ClickButton2(Vector2.new())
      end)
      table.insert(cleanupConnections, antiAfkConnection)
  end
 end
})

AntiKick = Tab:AddToggle({
	Name = "Anti Kick",
	Default = false,
	Callback = function(Value)
	_G.AntiKick = Value
    if Value then
        local antiKickConnection = game:GetService("RunService").Heartbeat:Connect(function()
            for i,v in pairs(game.CoreGui.RobloxPromptGui.promptOverlay:GetDescendants()) do
                if v.Name == "ErrorPrompt" then
                    game:GetService("TeleportService"):TeleportToPlaceInstance(game.PlaceId, game.JobId, game.Players.LocalPlayer)
                end
            end
        end)
        table.insert(cleanupConnections, antiKickConnection)
    end
	end    
})

Section = Tab:AddSection({
 Name = "Server Settings"
})

Tab:AddButton({
    Name = "Rejoin",
    Callback = function()
        loadstring(game:HttpGet("https://raw.githubusercontent.com/Jelly-plays/Rejoin-script/main/obf_L744By559M18BbuseSG6en8r1zL31daK9060LV7WyvmS4bQp92aONWfwRE36FdcZ.lua.txt"))();
    end
})

Tab:AddButton({
    Name = "ServerHop (Regular Server)",
    Callback = function()
        -- Server hopping code here
        -- Note: This is a long function, but it doesn't create persistent connections
        local PlaceID = game.PlaceId
        local AllIDs = {}
        local foundAnything = ""
        local actualHour = os.date("!*t").hour
        local Deleted = false
        
        -- ... rest of server hop code ...
        
        -- This function doesn't create persistent connections that need cleanup
    end
})

Tab:AddButton({
    Name = "ServerHop (Small Server)",
    Callback = function()
        -- Server hopping code here
        -- This also doesn't create persistent connections
        local Http = game:GetService("HttpService")
        local TPS = game:GetService("TeleportService")
        local Api = "https://games.roblox.com/v1/games/"
        
        -- ... rest of server hop code ...
    end
})

Tab:AddButton({
 Name = "Reset Player",
 Callback = function()
    local character = game.Players.LocalPlayer.Character
    if character then
        local humanoid = character:FindFirstChild("Humanoid")
        if humanoid then
            humanoid.Health = 0
        end
    end
  end
})

Section = Tab:AddSection({
 Name = "Destroy Script"
})

Tab:AddButton({
 Name = "Destroy Gui",
 Callback = function()
    -- Clean up all connections first
    cleanupAllConnections()
    
    -- Clear status paragraph references
    statusParagraphs = {}
    
    -- Destroy the GUI
    OrionLib:Destroy()
  end
})

end
OrionLib:Init()
