--Start Of Script
local MarketplaceService = game:GetService("MarketplaceService")
local placeInfo = MarketplaceService:GetProductInfo(game.PlaceId)
local gameName = placeInfo.Name

-- Fluent UI Library
local Fluent = loadstring(game:HttpGet("https://github.com/dawid-scripts/Fluent/releases/latest/download/main.lua"))()
local SaveManager = loadstring(game:HttpGet("https://raw.githubusercontent.com/dawid-scripts/Fluent/master/Addons/SaveManager.lua"))()
local InterfaceManager = loadstring(game:HttpGet("https://raw.githubusercontent.com/dawid-scripts/Fluent/master/Addons/InterfaceManager.lua"))()

local Window = Fluent:CreateWindow({
    Title = gameName .. " Hub (Scripter Hub) V. 2.3.3",
    SubTitle = "by Scripter",
    TabWidth = 160,
    Size = UDim2.fromOffset(580, 460),
    Acrylic = true,
    Theme = "Dark",
    MinimizeKey = Enum.KeyCode.LeftControl
})

--If SAEN Then
if game.PlaceId == 14410213941 or game.PlaceId == 14667049509 then

local Tabs = {
    Welcome = Window:AddTab({Title = "Welcome", Icon = "home"}),
    Info = Window:AddTab({Title = "Info", Icon = "info"}),
    Main = Window:AddTab({Title = "Main", Icon = "settings"}),
    Badges = Window:AddTab({Title = "Badges", Icon = "award"}),
    ESP = Window:AddTab({Title = "ESP", Icon = "eye"}),
    Shop = Window:AddTab({Title = "Shop", Icon = "shopping-cart"}),
    Scripts = Window:AddTab({Title = "Scripts", Icon = "code"}),
    Inventory = Window:AddTab({Title = "Inventory", Icon = "package"}),
    HealthNPC = Window:AddTab({Title = "Health NPC's", Icon = "heart"}),
    Vulnerability = Window:AddTab({Title = "Vulnerability", Icon = "shield"}),
    Changelogs = Window:AddTab({Title = "Changelogs", Icon = "file-text"}),
    Credits = Window:AddTab({Title = "Credits", Icon = "users"}),
    Settings = Window:AddTab({Title = "Settings", Icon = "settings"})
}

Fluent:Notify({
    Title = "From Scripter",
    Content = "GoodLuck!",
    SubContent = "Enjoy the script",
    Duration = 3
})

-- ========== WELCOME TAB ==========
local WelcomeTab = Tabs.Welcome
local player = game.Players.LocalPlayer

WelcomeTab:AddParagraph({
    Title = "Hello " .. player.Name .. "!",
    Content = "Welcome to the hub!"
})

WelcomeTab:AddButton({
    Title = "Bypass Anti Cheat",
    Description = "Prevent Crashing Roblox I Guess...",
    Callback = function()
        local success = pcall(function()
            if workspace:FindFirstChild("#GAME") then
                if workspace["#GAME"]:FindFirstChild("Map") then
                    if workspace["#GAME"].Map:FindFirstChild("_Other") then
                        if workspace["#GAME"].Map._Other:FindFirstChild("MountainWedge") then
                            workspace["#GAME"].Map._Other.MountainWedge:Destroy()
                        end
                        if workspace["#GAME"].Map._Other:FindFirstChild("Touch/TargetParts") then
                            if workspace["#GAME"].Map._Other["Touch/TargetParts"]:FindFirstChild("MountainPart") then
                                workspace["#GAME"].Map._Other["Touch/TargetParts"].MountainPart:Destroy()
                            end
                        end
                        if workspace["#GAME"].Map._Other:FindFirstChild("Mountain") then
                            workspace["#GAME"].Map._Other.Mountain:Destroy()
                        end
                    end
                end
            end
            
            if game:GetService("CorePackages"):FindFirstChild("Workspace") then
                local packages = game:GetService("CorePackages").Workspace:FindFirstChild("Packages")
                if packages then
                    local flag = packages:FindFirstChild("_Index") and packages._Index:FindFirstChild("AvatarExperienceFlags")
                    if flag and flag.AvatarExperienceFlags:FindFirstChild("FFlagAXSlotsDesktopCrashFix") then
                        flag.AvatarExperienceFlags.FFlagAXSlotsDesktopCrashFix:Destroy()
                    end
                end
            end
            
            if ReplicatedStorage:FindFirstChild("Events") and ReplicatedStorage.Events:FindFirstChild("AntiSpeed") then
                ReplicatedStorage.Events.AntiSpeed:Destroy()
            end
        end)
        
        if success then
            Fluent:Notify({
                Title = "Anti-Cheat Bypassed",
                Content = "Anti-cheat measures have been disabled",
                Duration = 3
            })
        else
            Fluent:Notify({
                Title = "Error",
                Content = "Failed to bypass anti-cheat",
                Duration = 3
            })
        end
    end
})

WelcomeTab:AddParagraph({
    Title = "Note:",
    Content = "Use in private server if u dont wanna get caught and getting banned!"
})

WelcomeTab:AddButton({
    Title = "Check Type Server",
    Description = "Check if you're in public or private server",
    Callback = function()
        local function detectServerType()
            -- Method 1: Direct property check
            if game.PrivateServerId ~= "" then
                if game.PrivateServerOwnerId ~= 0 then
                    return "Private Server"
                else
                    return "VIP Server"
                end
            end
            
            -- Method 2: Check via Players service
            local players = game:GetService("Players")
            if players:GetAttribute("PrivateServer") then
                return "Private Server"
            end
            
            -- Method 3: Check job ID pattern (private servers often have longer job IDs)
            local jobId = game.JobId
            if jobId and #jobId > 20 then  -- Private server job IDs are typically longer
                return "Private Server"
            end
            
            return "Public Server"
        end
        
        local serverType = detectServerType()
        
        Fluent:Notify({
            Title = "Server Type",
            Content = "You are on a " .. serverType,
            Duration = 5
        })
    end
})

-- ========== INFO TAB ==========
local InfoTab = Tabs.Info

InfoTab:AddParagraph({
    Title = "Currency/Leaderstats",
    Content = ""
})

local coinsLabel = InfoTab:AddParagraph({
    Title = "Check Coins",
    Content = "[ "..game:GetService("Players").LocalPlayer.leaderstats.Coins.Value.." ]"
})

local bitesLabel = InfoTab:AddParagraph({
    Title = "Check Bites", 
    Content = "[ "..game:GetService("Players").LocalPlayer.leaderstats.Bites.Value.." ]"
})

InfoTab:AddParagraph({
    Title = "Others",
    Content = ""
})

-- Function to safely get text from SurfaceGui
local function getSafeText(part)
    local success, result = pcall(function()
        if part and part:FindFirstChild("SurfaceGui") and part.SurfaceGui:FindFirstChild("TextLabel") then
            return part.SurfaceGui.TextLabel.Text
        end
        return "N/A"
    end)
    return success and result or "N/A"
end

local insaenityLabel = InfoTab:AddParagraph({
    Title = "Insaenity Lvl",
    Content = "[ "..getSafeText(workspace["#GAME"].Map._Other.InsaenityTracker.LVL).." ]"
})

local bossTimerLabel = InfoTab:AddParagraph({
    Title = "BOSS Noob in",
    Content = "[ "..getSafeText(workspace["#GAME"].Map._Other.BOSS_Timer).." ]"
})

local house1Label = InfoTab:AddParagraph({
    Title = "House 1 Kills",
    Content = "[ "..getSafeText(workspace["#GAME"].Map._Other.HouseTrackers["1"].Count).." ]"
})

local house2Label = InfoTab:AddParagraph({
    Title = "House 2 Kills",
    Content = "[ "..getSafeText(workspace["#GAME"].Map._Other.HouseTrackers["2"].Count).." ]"
})

local house3Label = InfoTab:AddParagraph({
    Title = "House 3 Kills",
    Content = "[ "..getSafeText(workspace["#GAME"].Map._Other.HouseTrackers["3"].Count).." ]"
})

local house4Label = InfoTab:AddParagraph({
    Title = "House 4 Kills",
    Content = "[ "..getSafeText(workspace["#GAME"].Map._Other.HouseTrackers["4"].Count).." ]"
})

local house5Label = InfoTab:AddParagraph({
    Title = "House 5 Kills",
    Content = "[ "..getSafeText(workspace["#GAME"].Map._Other.HouseTrackers["5"].Count).." ]"
})

InfoTab:AddParagraph({
    Title = "Universal",
    Content = ""
})

local placeNameLabel = InfoTab:AddParagraph({
    Title = "Place Name",
    Content = "[ "..gameName.." ]"
})

local placeIdLabel = InfoTab:AddParagraph({
    Title = "Place Id",
    Content = "[ "..game.PlaceId.." ]"
})

local clientVersionLabel = InfoTab:AddParagraph({
    Title = "Client Version",
    Content = "[ "..game:GetService("CoreGui").RobloxGui.SettingsClippingShield.SettingsShield.VersionContainer.ClientVersionLabel.Text.." ]"
})

local serverVersionLabel = InfoTab:AddParagraph({
    Title = "Server Version",
    Content = "[ "..game:GetService("CoreGui").RobloxGui.SettingsClippingShield.SettingsShield.VersionContainer.ServerVersionLabel.Text.." ]"
})

local serverChannelLabel = InfoTab:AddParagraph({
    Title = "Server Channel",
    Content = "[ "..game:GetService("CoreGui").RobloxGui.SettingsClippingShield.SettingsShield.VersionContainer.ServerChannelLabel.Text.." ]"
})

local placeVersionLabel = InfoTab:AddParagraph({
    Title = "Place Version",
    Content = "[ "..game:GetService("CoreGui").RobloxGui.SettingsClippingShield.SettingsShield.VersionContainer.PlaceVersionLabel.Text.." ]"
})

local clientCoreLabel = InfoTab:AddParagraph({
    Title = "Client CoreScript Version",
    Content = "[ "..game:GetService("CoreGui").RobloxGui.SettingsClippingShield.SettingsShield.VersionContainer.CoreScriptVersionLabel.Text.." ]"
})

local autoSetInfoToggle = InfoTab:AddToggle("AutoSetInfoToggle", {
    Title = "Auto Set Info",
    Description = "Automatically update all info labels",
    Default = false,
    Callback = function(Value)
        if Value then
            while task.wait(0.5) and Value do
                coinsLabel:SetDesc("[ "..game:GetService("Players").LocalPlayer.leaderstats.Coins.Value.." ]")
                bitesLabel:SetDesc("[ "..game:GetService("Players").LocalPlayer.leaderstats.Bites.Value.." ]")
                insaenityLabel:SetDesc("[ "..getSafeText(workspace["#GAME"].Map._Other.InsaenityTracker.LVL).." ]")
                bossTimerLabel:SetDesc("[ "..getSafeText(workspace["#GAME"].Map._Other.BOSS_Timer).." ]")
                house1Label:SetDesc("[ "..getSafeText(workspace["#GAME"].Map._Other.HouseTrackers["1"].Count).." ]")
                house2Label:SetDesc("[ "..getSafeText(workspace["#GAME"].Map._Other.HouseTrackers["2"].Count).." ]")
                house3Label:SetDesc("[ "..getSafeText(workspace["#GAME"].Map._Other.HouseTrackers["3"].Count).." ]")
                house4Label:SetDesc("[ "..getSafeText(workspace["#GAME"].Map._Other.HouseTrackers["4"].Count).." ]")
                house5Label:SetDesc("[ "..getSafeText(workspace["#GAME"].Map._Other.HouseTrackers["5"].Count).." ]")
                placeNameLabel:SetDesc("[ "..gameName.." ]")
                placeIdLabel:SetDesc("[ "..game.PlaceId.." ]")
                clientVersionLabel:SetDesc("[ "..game:GetService("CoreGui").RobloxGui.SettingsClippingShield.SettingsShield.VersionContainer.ClientVersionLabel.Text.." ]")
                serverVersionLabel:SetDesc("[ "..game:GetService("CoreGui").RobloxGui.SettingsClippingShield.SettingsShield.VersionContainer.ServerVersionLabel.Text.." ]")
                serverChannelLabel:SetDesc("[ "..game:GetService("CoreGui").RobloxGui.SettingsClippingShield.SettingsShield.VersionContainer.ServerChannelLabel.Text.." ]")
                placeVersionLabel:SetDesc("[ "..game:GetService("CoreGui").RobloxGui.SettingsClippingShield.SettingsShield.VersionContainer.PlaceVersionLabel.Text.." ]")
                clientCoreLabel:SetDesc("[ "..game:GetService("CoreGui").RobloxGui.SettingsClippingShield.SettingsShield.VersionContainer.CoreScriptVersionLabel.Text.." ]")
            end
        end
    end
})

-- ========== MAIN TAB ==========
local MainTab = Tabs.Main

MainTab:AddParagraph({
    Title = "Auto Eat Feature",
    Content = ""
})

local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local RunService = game:GetService("RunService")
local Workspace = game:GetService("Workspace")

local LocalPlayer = Players.LocalPlayer
if not LocalPlayer then
    Players.PlayerAdded:Wait()
    LocalPlayer = Players.LocalPlayer
end

local Camera = Workspace.CurrentCamera

-- Performance optimization variables
local PERFORMANCE_THRESHOLD = 0.033
local lastPerformanceCheck = 0
local frameCount = 0
local currentFPS = 60
local lastActionTime = 0
local ACTION_COOLDOWN = 0.01 -- Minimum time between attacks

-- Wait for game folders with timeout
local gameFolder = Workspace:WaitForChild("#GAME", 10)
local foldersFolder = gameFolder and gameFolder:WaitForChild("Folders", 5)
local humanoidFolder = foldersFolder and foldersFolder:WaitForChild("HumanoidFolder", 5)
local mainFolder = humanoidFolder and humanoidFolder:WaitForChild("NPCFolder", 5)

local eventsFolder = ReplicatedStorage:WaitForChild("Events", 10)
local remote = eventsFolder and eventsFolder:WaitForChild("MainAttack", 5)
local clickRemote = eventsFolder and eventsFolder:WaitForChild("Click", 5)

if not mainFolder then
    warn("Auto Attack: Could not find NPCFolder at expected path.")
    return
end
if not remote then
    warn("Auto Attack: Could not find MainAttack RemoteEvent.")
    return
end
if not clickRemote then
    warn("Auto Attack: Could not find Click RemoteEvent.")
    return
end

-- Toggle states
local isActiveAll = false
local isActiveSmart = false
local isActiveChoosed = false
local isActiveDeadNoobs = false
local selectedCoinType = "Positive Coins"
-- Auto-click variables
local isAutoClicking = false
local autoClickConnection = nil

-- Priority lists
local priorityNames1 = { "Amethyst", "Ruby", "Emerald", "Diamond", "Golden", "Silver", "Rock" }
local priorityNames2 = { "Werewolf", "Berend", "Dead" }

-- Coin type filters
local stinkCoinNames = { "Turd", "Nasty", "Raffie", "Sigmabloxian" }
local cookieNames = { "Party", "Buoyant", "Delicious", "Primo" }

-- Priority lists in order from highest to lowest priority
local priorityNames = {
    "Amethyst",  -- 1 (Highest)
    "Ruby",      -- 2
    "Emerald",   -- 3
    "Diamond",   -- 4
    "Golden",    -- 5
    "Silver",    -- 6
    "Rock",      -- 7
    "Werewolf"   -- 8 (Lowest)
}

local function getSmartPriorityTarget(npcList)
    if not npcList or #npcList == 0 then return nil end
    
    -- First pass: Find NPCs in exact priority order (highest to lowest)
    for _, priorityName in ipairs(priorityNames) do
        for _, npc in ipairs(npcList) do
            -- Check if NPC name contains the priority name (like "Amethyst Noob" contains "Amethyst")
            if string.find(npc.Name, priorityName, 1, true) then
                return npc
            end
        end
    end
    
    -- Second pass: If no priority targets found, return any available target
    if #npcList > 0 then
        return npcList[math.random(1, #npcList)]
    end

    return nil
end

-- Performance monitoring function
local function checkPerformance()
    frameCount = frameCount + 1
    local currentTime = tick()
    
    if currentTime - lastPerformanceCheck >= 1 then
        currentFPS = frameCount
        frameCount = 0
        lastPerformanceCheck = currentTime
        
        if currentFPS < 25 then
            return false
        end
    end
    return true
end

-- Optimized function to start auto-clicking
local function startAutoClick()
    if autoClickConnection then
        autoClickConnection:Disconnect()
        autoClickConnection = nil
    end
    
    isAutoClicking = true
    autoClickConnection = RunService.Heartbeat:Connect(function()
        if not checkPerformance() then
            task.wait(0.01)
            return
        end
        clickRemote:FireServer()
        task.wait(0.01) -- Reduced frequency
    end)
end

-- Function to stop auto-clicking
local function stopAutoClick()
    isAutoClicking = false
    if autoClickConnection then
        autoClickConnection:Disconnect()
        autoClickConnection = nil
    end
end

MainTab:AddToggle("AutoEatAllToggle", {
    Title = "Auto Eat (For All Type Coins)",
    Description = "Automatically eat all types of coins",
    Default = false,
    Callback = function(Value)
        isActiveAll = Value
        if Value then
            startAutoClick()
        elseif not (isActiveSmart or isActiveChoosed or isActiveDeadNoobs) then
            stopAutoClick()
        end
    end
})

MainTab:AddToggle("AutoEatSmartToggle", {
    Title = "Auto Eat (Smart From Value High To Low)",
    Description = "Smart eating based on coin value",
    Default = false,
    Callback = function(Value)
        isActiveSmart = Value
        if Value then
            startAutoClick()
        elseif not (isActiveAll or isActiveChoosed or isActiveDeadNoobs) then
            stopAutoClick()
        end
    end
})

local coinTypeDropdown = MainTab:AddDropdown("CoinTypeDropdown", {
    Title = "Choose Coin Type To Auto Eat",
    Description = "Select which type of coins to auto eat",
    Values = {"Positive Coins", "Stink Coins", "Cookies", "King Coins"},
    Default = "Positive Coins",
    Multi = false,
    Callback = function(Value)
        selectedCoinType = Value
    end
})

MainTab:AddToggle("AutoEatChoosedToggle", {
    Title = "Auto Eat (Choosed Type)",
    Description = "Auto eat selected coin type",
    Default = false,
    Callback = function(Value)
        isActiveChoosed = Value
        if Value then
            startAutoClick()
        elseif not (isActiveAll or isActiveSmart or isActiveDeadNoobs) then
            stopAutoClick()
        end
    end
})

MainTab:AddToggle("AutoEatDeadToggle", {
    Title = "Auto Eat (Dead Noobs Only)",
    Description = "Only eat dead noobs",
    Default = false,
    Callback = function(Value)
        isActiveDeadNoobs = Value
        if Value then
            startAutoClick()
        elseif not (isActiveAll or isActiveSmart or isActiveChoosed) then
            stopAutoClick()
        end
    end
})

-- Cache for NPC lists to reduce scanning
local cachedDeadNPCs = {}
local cachedDeadNoobs = {}
local lastNPCCacheTime = 0
local NPC_CACHE_INTERVAL = 0.02 -- Update cache every 2 seconds

-- Optimized function to get dead NPCs with caching
local function getDeadNPCs()
    local currentTime = tick()
    
    -- Return cached result if still valid
    if #cachedDeadNPCs > 0 and (currentTime - lastNPCCacheTime) < NPC_CACHE_INTERVAL then
        return cachedDeadNPCs
    end
    
    local deadList = {}
    if not mainFolder then 
        cachedDeadNPCs = deadList
        return deadList 
    end

    -- Use pcall to prevent errors from breaking the scan
    local success = pcall(function()
        local foldersToCheck = {mainFolder}
        
        -- Add the specific path you mentioned
        local specificPath = Workspace:FindFirstChild("#GAME") and Workspace["#GAME"]:FindFirstChild("Folders") and Workspace["#GAME"].Folders:FindFirstChild("HumanoidFolder") and Workspace["#GAME"].Folders.HumanoidFolder:FindFirstChild("NPCFolder")
        if specificPath and specificPath ~= mainFolder then
            table.insert(foldersToCheck, specificPath)
        end

        for _, folder in ipairs(foldersToCheck) do
            local npcs = folder:GetChildren()
            for i = 1, #npcs do
                local npc = npcs[i]
                if npc:IsA("Model") then
                    local humanoid = npc:FindFirstChildOfClass("Humanoid")
                    -- Check if Humanoid exists AND (Health is 0 or less OR its name contains "Dead")
                    if humanoid and (humanoid.Health <= 0 or string.find(npc.Name, "Dead", 1, true) or string.find(humanoid.Name, "Dead", 1, true)) then
                        table.insert(deadList, npc)
                    end
                end
                
                -- Yield every 20 NPCs to prevent freezing
                if i % 20 == 0 then
                    task.wait()
                end
            end
        end
    end)
    
    if not success then
        warn("Error scanning for dead NPCs")
    end
    
    cachedDeadNPCs = deadList
    lastNPCCacheTime = currentTime
    return deadList
end

-- Optimized function to get dead noob NPCs with caching
local function getDeadNoobNPCs()
    local currentTime = tick()
    
    -- Return cached result if still valid
    if #cachedDeadNoobs > 0 and (currentTime - lastNPCCacheTime) < NPC_CACHE_INTERVAL then
        return cachedDeadNoobs
    end
    
    local deadNoobList = {}
    if not mainFolder then 
        cachedDeadNoobs = deadNoobList
        return deadNoobList 
    end

    local success = pcall(function()
        local foldersToCheck = {mainFolder}
        
        local specificPath = Workspace:FindFirstChild("#GAME") and Workspace["#GAME"]:FindFirstChild("Folders") and Workspace["#GAME"].Folders:FindFirstChild("HumanoidFolder") and Workspace["#GAME"].Folders.HumanoidFolder:FindFirstChild("NPCFolder")
        if specificPath and specificPath ~= mainFolder then
            table.insert(foldersToCheck, specificPath)
        end

        for _, folder in ipairs(foldersToCheck) do
            local npcs = folder:GetChildren()
            for i = 1, #npcs do
                local npc = npcs[i]
                if npc:IsA("Model") then
                    local humanoid = npc:FindFirstChildOfClass("Humanoid")
                    -- Only target NPCs with "Dead" in their name (case insensitive)
                    if humanoid and (string.find(npc.Name:lower(), "dead", 1, true)) then
                        table.insert(deadNoobList, npc)
                    end
                end
                
                -- Yield every 20 NPCs to prevent freezing
                if i % 20 == 0 then
                    task.wait()
                end
            end
        end
    end)
    
    if not success then
        warn("Error scanning for dead noob NPCs")
    end
    
    cachedDeadNoobs = deadNoobList
    lastNPCCacheTime = currentTime
    return deadNoobList
end

local function getPriorityTarget(npcList)
    if not npcList or #npcList == 0 then return nil end
    
    local function findByPriority(list, keywords)
        for _, keyword in ipairs(keywords) do
            for _, npc in ipairs(list) do
                if npc.Name:find(keyword, 1, true) then
                    return npc
                end
            end
        end
        return nil
    end

    local target = findByPriority(npcList, priorityNames1)
    if target then return target end

    target = findByPriority(npcList, priorityNames2)
    if target then return target end

    if #npcList > 0 then
        return npcList[math.random(1, #npcList)]
    end

    return nil
end

local function getSmartPriorityTarget(npcList)
    if not npcList or #npcList == 0 then return nil end
    
    local function findByPriority(list, keywords)
        for _, keyword in ipairs(keywords) do
            for _, npc in ipairs(list) do
                if npc.Name:find(keyword, 1, true) then
                    return npc
                end
            end
        end
        return nil
    end

    -- Check high priority names first
    local target = findByPriority(npcList, priorityNames1)
    if target then return target end

    target = findByPriority(npcList, priorityNames2)
    if target then return target end

    -- If no priority targets found, return any available target
    if #npcList > 0 then
        return npcList[math.random(1, #npcList)]
    end

    return nil
end

local function getChoosedTypeTarget(npcList, coinType)
    if not npcList or #npcList == 0 then return nil end
    
    if coinType == "Positive Coins" then
        -- Eat everything except stink coins
        for _, npc in ipairs(npcList) do
            local isStinkCoin = false
            for _, stinkName in ipairs(stinkCoinNames) do
                if npc.Name:find(stinkName, 1, true) then
                    isStinkCoin = true
                    break
                end
            end
            if not isStinkCoin then
                return npc
            end
        end
        
    elseif coinType == "Stink Coins" then
        -- Eat only stink coins
        for _, npc in ipairs(npcList) do
            for _, stinkName in ipairs(stinkCoinNames) do
                if npc.Name:find(stinkName, 1, true) then
                    return npc
                end
            end
        end
        
    elseif coinType == "Cookies" then
        -- Eat only cookies
        for _, npc in ipairs(npcList) do
            for _, cookieName in ipairs(cookieNames) do
                if npc.Name:find(cookieName, 1, true) then
                    return npc
                end
            end
        end
        
    elseif coinType == "King Coins" then
        -- Eat only BOSS types
        for _, npc in ipairs(npcList) do
            if npc.Name:find("BOSS", 1, true) then
                return npc
            end
        end
    end
    
    return nil
end

local function getDeadNoobTarget(npcList)
    if not npcList or #npcList == 0 then return nil end
    
    if #npcList > 0 then
        return npcList[math.random(1, #npcList)]
    end
    return nil
end

-- Optimized function to get valid body parts
local function getValidBodyParts(model)
    local validParts = {}
    
    local success = pcall(function()
        for _, part in ipairs(model:GetDescendants()) do
            if part:IsA("BasePart") then
                local isGettingEaten = part:GetAttribute("IsGettingEaten")
                if not isGettingEaten then
                    table.insert(validParts, part)
                end
            end
            
            -- Limit scanning to prevent freezing
            if #validParts >= 5 then
                break
            end
        end
    end)
    
    return validParts
end

local USE_DEVIATION = true
local MAX_DEVIATION_STUDS = 0.5

-- Optimized attack function with rate limiting
local function attackTarget(targetNpc)
    local currentTime = tick()
    
    -- Rate limiting
    if currentTime - lastActionTime < ACTION_COOLDOWN then
        return
    end
    
    if not targetNpc or not targetNpc.Parent then return end

    local validParts = getValidBodyParts(targetNpc)
    if #validParts == 0 then
        return
    end

    local bodyPart = validParts[math.random(1, #validParts)]

    local origin = Camera.CFrame.Position
    local targetPosition = bodyPart.Position

    if USE_DEVIATION and MAX_DEVIATION_STUDS > 0 then
        local offsetX = (math.random() - 0.5) * 2 * MAX_DEVIATION_STUDS
        local offsetY = (math.random() - 0.5) * 2 * MAX_DEVIATION_STUDS
        local offsetZ = (math.random() - 0.5) * 2 * MAX_DEVIATION_STUDS
        targetPosition = targetPosition + Vector3.new(offsetX, offsetY, offsetZ)
    end

    local direction = (targetPosition - origin).Unit

    if direction.X ~= direction.X or direction.Y ~= direction.Y or direction.Z ~= direction.Z then
        direction = Camera.CFrame.LookVector
    end

    local args = {
        [1] = {
            ["AN"] = "Eat",
            ["D"] = direction,
            ["O"] = origin,
            ["FBP"] = bodyPart
        }
    }
    
    local success = pcall(function()
        remote:FireServer(unpack(args))
    end)
    
    if success then
        lastActionTime = currentTime
    end
end

-- Main optimized heartbeat loop
local lastScanTime = 0
local SCAN_INTERVAL = 0.01 -- Scan every 0.5 seconds instead of every frame

RunService.Heartbeat:Connect(function()
    -- Performance check
    if not checkPerformance() then
        task.wait(0.01)
        return
    end
    
    local currentTime = tick()
    
    -- Only scan for NPCs at intervals to reduce CPU usage
    if currentTime - lastScanTime < SCAN_INTERVAL then
        return
    end
    
    lastScanTime = currentTime

    -- Auto Eat (Dead Noobs Only) - Separate check only for dead noobs
    if isActiveDeadNoobs then
        local deadNoobList = getDeadNoobNPCs()
        if #deadNoobList > 0 then
            local targetNpc = getDeadNoobTarget(deadNoobList)
            if targetNpc then
                attackTarget(targetNpc)
                return
            end
        end
    end

    -- For other modes, use the regular dead NPC list
    local deadNPCList = getDeadNPCs()
    if #deadNPCList == 0 then return end

    -- Auto Eat (For All Type Coins)
    if isActiveAll then
        local targetNpc = getPriorityTarget(deadNPCList)
        if targetNpc then
            attackTarget(targetNpc)
            return
        end
    end

    -- Auto Eat (Smart From Value High To Low)
    if isActiveSmart then
        local targetNpc = getSmartPriorityTarget(deadNPCList)
        if targetNpc then
            attackTarget(targetNpc)
            return
        end
    end

    -- Auto Eat (Choosed Type)
    if isActiveChoosed then
        local targetNpc = getChoosedTypeTarget(deadNPCList, selectedCoinType)
        if targetNpc then
            attackTarget(targetNpc)
            return
        end
    end
end)

-- Memory cleanup function
local function cleanupMemory()
    cachedDeadNPCs = {}
    cachedDeadNoobs = {}
    collectgarbage()
end

-- Schedule periodic memory cleanup
task.spawn(function()
    while true do
        task.wait(30)
        cleanupMemory()
    end
end)

MainTab:AddParagraph({
    Title = "Auto Shoot Feature",
    Content = ""
})

local ReplicatedStorage = game:GetService("ReplicatedStorage")
local RunService = game:GetService("RunService")
local Players = game:GetService("Players")
local Player = Players.LocalPlayer

-- Safe function to get character
local function getCharacter()
    local success, character = pcall(function()
        return Player.Character
    end)
    return success and character or nil
end

-- Safe shooting function
local function FireAttack(target, gunName)
    local success, err = pcall(function()
        local character = getCharacter()
        if not character then return end
        
        local gunTool = character:FindFirstChild(gunName) or Player.Backpack:FindFirstChild(gunName)
        if not gunTool then return end
        
        -- Equip tool if in backpack
        if gunTool.Parent == Player.Backpack then
            gunTool.Parent = character
            task.wait(0.1)
        end
        
        local head = target:FindFirstChild("Head")
        if not head then return end
        
        local primaryPart = character:FindFirstChild("HumanoidRootPart") or character.PrimaryPart
        if not primaryPart then return end
        
        local mainAttackEvent = ReplicatedStorage:WaitForChild("Events"):WaitForChild("MainAttack")
        
        local args = {{
            FD = head.Position,
            SD = Vector3.new(),
            FO = primaryPart.Position + Vector3.new(0, 1.5, 0),
            T = gunTool,
            AN = gunName,
            H = head,
            BM = 22.15,
            RP = primaryPart.Position,
            HP = head.Position,
            SP = head.Position
        }}
        
        mainAttackEvent:FireServer(unpack(args))
    end)
    
    if not success then
        warn("FireAttack error: " .. tostring(err))
    end
end

-- Safe function to find nearest target
local function findNearestTarget(character, maxDistance)
    local nearestTarget = nil
    local nearestDistance = maxDistance or 1000
    
    local success, err = pcall(function()
        if not character or not character.PrimaryPart then return end
        
        local npcFolder = workspace:FindFirstChild("#GAME") and 
                         workspace["#GAME"]:FindFirstChild("Folders") and 
                         workspace["#GAME"].Folders:FindFirstChild("HumanoidFolder") and 
                         workspace["#GAME"].Folders.HumanoidFolder:FindFirstChild("NPCFolder")
        
        if not npcFolder then return end
        
        for _, npc in ipairs(npcFolder:GetChildren()) do
            if npc:IsA("Model") then
                local humanoid = npc:FindFirstChildOfClass("Humanoid")
                local head = npc:FindFirstChild("Head")
                
                if humanoid and head and humanoid.Health > 0 then
                    -- Skip dead and invincible NPCs
                    if string.find(npc.Name:lower(), "dead") or string.find(npc.Name:lower(), "invincible") then
                        continue
                    end
                    
                    local dist = (character.PrimaryPart.Position - head.Position).Magnitude
                    if dist <= nearestDistance then
                        nearestDistance = dist
                        nearestTarget = npc
                    end
                end
            end
        end
    end)
    
    return nearestTarget
end

-- Function to find specific NPCs (CrackedBas, WhiteBas)
local function findSpecificNPCs(npcNames)
    local targets = {}
    local npcFolder = workspace:FindFirstChild("#GAME") and 
                     workspace["#GAME"]:FindFirstChild("Folders") and 
                     workspace["#GAME"].Folders:FindFirstChild("HumanoidFolder") and 
                     workspace["#GAME"].Folders.HumanoidFolder:FindFirstChild("NPCFolder")
    
    if npcFolder then
        for _, npcName in ipairs(npcNames) do
            local npc = npcFolder:FindFirstChild(npcName)
            if npc and npc:IsA("Model") then
                local humanoid = npc:FindFirstChildOfClass("Humanoid")
                local head = npc:FindFirstChild("Head")
                if humanoid and head and humanoid.Health > 0 then
                    table.insert(targets, npc)
                end
            end
        end
    end
    
    return targets
end

-- Connect to character added event
Player.CharacterAdded:Connect(onCharacterRespawn)

_G.MainGunName = "Minigun"
_G.MainShootingSpeed = 6
_G.MainAutoShootEnabled = false
_G.MainMaxDistance = 1000
_G.MainAutoShootConnection = nil

-- List of NPC names to ignore in Main Tab
local IGNORE_NPC_NAMES = {
    "Dead",
    "Invincible", 
    "CrackedBas",
    "WhiteBas"
}

-- Function to check if NPC should be ignored
local function shouldIgnoreNPC(npc)
    if not npc or not npc.Name then
        return true
    end
    
    local npcName = npc.Name:lower()
    
    -- Check if NPC name contains any of the ignore words
    for _, ignoreName in ipairs(IGNORE_NPC_NAMES) do
        if string.find(npcName, ignoreName:lower(), 1, true) then
            return true
        end
    end
    
    return false
end

-- Updated function to find nearest target that ignores specific NPCs
local function findNearestTargetMain(character, maxDistance)
    local nearestTarget = nil
    local nearestDistance = maxDistance or 1000
    
    local success, err = pcall(function()
        if not character or not character.PrimaryPart then return end
        
        local npcFolder = workspace:FindFirstChild("#GAME") and 
                         workspace["#GAME"]:FindFirstChild("Folders") and 
                         workspace["#GAME"].Folders:FindFirstChild("HumanoidFolder") and 
                         workspace["#GAME"].Folders.HumanoidFolder:FindFirstChild("NPCFolder")
        
        if not npcFolder then return end
        
        for _, npc in ipairs(npcFolder:GetChildren()) do
            if npc:IsA("Model") then
                -- Check if NPC should be ignored
                if shouldIgnoreNPC(npc) then
                    continue  -- Skip this NPC
                end
                
                local humanoid = npc:FindFirstChildOfClass("Humanoid")
                local head = npc:FindFirstChild("Head")
                
                if humanoid and head and humanoid.Health > 0 then
                    local dist = (character.PrimaryPart.Position - head.Position).Magnitude
                    if dist <= nearestDistance then
                        nearestDistance = dist
                        nearestTarget = npc
                    end
                end
            end
        end
    end)
    
    return nearestTarget
end

MainTab:AddInput("MainGunNameInput", {
    Title = "Gun Name",
    Default = "Minigun",
    Placeholder = "Enter gun name",
    Numeric = false,
    Finished = false,
    Callback = function(Text)
        _G.MainGunName = Text or "Minigun"
    end
})

MainTab:AddInput("MainShootingSpeedInput", {
    Title = "Shooting Speed",
    Default = "6",
    Placeholder = "Enter shooting speed",
    Numeric = true,
    Finished = false,
    Callback = function(Text)
        _G.MainShootingSpeed = math.clamp(tonumber(Text) or 6, 1, 60)
    end
})

MainTab:AddInput("MainMaxDistanceInput", {
    Title = "Max Distance",
    Default = "1000",
    Placeholder = "Enter max distance",
    Numeric = true,
    Finished = false,
    Callback = function(Text)
        _G.MainMaxDistance = math.clamp(tonumber(Text) or 1000, 10, 5000)
    end
})

MainTab:AddToggle("MainAutoShootToggle", {
    Title = "Auto Shoot",
    Description = "Automatically shoot at targets (Ignores: Dead, Invincible, CrackedBas, WhiteBas)",
    Default = false,
    Callback = function(Value)
        _G.MainAutoShootEnabled = Value
        
        if Value then
            -- Stop any existing connection
            if _G.MainAutoShootConnection then
                _G.MainAutoShootConnection:Disconnect()
                _G.MainAutoShootConnection = nil
            end
            
            -- Start new auto shoot
            _G.MainAutoShootConnection = RunService.Heartbeat:Connect(function()
                if not _G.MainAutoShootEnabled then 
                    if _G.MainAutoShootConnection then
                        _G.MainAutoShootConnection:Disconnect()
                        _G.MainAutoShootConnection = nil
                    end
                    return 
                end
                
                local character = getCharacter()
                if not character or not character.PrimaryPart then return end
                
                -- Use the new function that ignores specific NPCs
                local nearestTarget = findNearestTargetMain(character, _G.MainMaxDistance)
                if nearestTarget then
                    FireAttack(nearestTarget, _G.MainGunName)
                end
                
                task.wait(0.1 / _G.MainShootingSpeed)
            end)
            
            Fluent:Notify({
                Title = "Auto Shoot",
                Content = "Auto shoot enabled (Ignoring: Dead, Invincible, CrackedBas, WhiteBas)",
                Duration = 3
            })
        else
            if _G.MainAutoShootConnection then
                _G.MainAutoShootConnection:Disconnect()
                _G.MainAutoShootConnection = nil
            end
            Fluent:Notify({
                Title = "Auto Shoot",
                Content = "Auto shoot disabled",
                Duration = 3
            })
        end
    end
})

MainTab:AddParagraph({
    Title = "Rest/Others Feature",
    Content = ""
})

-- Auto Teleport Implementation
local isTeleporting = false
local teleportConnection

MainTab:AddToggle("AutoTeleportToggle", {
    Title = "Auto Teleport To Noobs/Werewolfs",
    Description = "Automatically teleport to nearby targets",
    Default = false,
    Callback = function(Value)
        isTeleporting = Value
        if Value then
            teleportConnection = RunService.Heartbeat:Connect(function()
                if not isTeleporting then return end
                
                local character = game.Players.LocalPlayer.Character
                if not character then return end
                
                local humanoidRootPart = character:FindFirstChild("HumanoidRootPart")
                if not humanoidRootPart then return end
                
                local npcFolder = workspace:FindFirstChild("#GAME") and workspace["#GAME"]:FindFirstChild("Folders") and 
                                 workspace["#GAME"].Folders:FindFirstChild("HumanoidFolder") and 
                                 workspace["#GAME"].Folders.HumanoidFolder:FindFirstChild("NPCFolder")
                
                if not npcFolder then return end
                
                local npcs = {}
                for _, npc in ipairs(npcFolder:GetChildren()) do
                    if npc:IsA("Model") and npc:FindFirstChild("HumanoidRootPart") then
                        table.insert(npcs, npc)
                    end
                end
                
                if #npcs > 0 then
                    local randomNPC = npcs[math.random(1, #npcs)]
                    local npcPosition = randomNPC.HumanoidRootPart.Position
                    humanoidRootPart.CFrame = CFrame.new(npcPosition + Vector3.new(0, 5, 0))
                end
            end)
            Fluent:Notify({
                Title = "Auto Teleport",
                Content = "Auto teleport enabled",
                Duration = 3
            })
        else
            if teleportConnection then
                teleportConnection:Disconnect()
                teleportConnection = nil
            end
            Fluent:Notify({
                Title = "Auto Teleport",
                Content = "Auto teleport disabled",
                Duration = 3
            })
        end
    end
})

-- Auto Use Sword Implementation
local isUsingSword = false
local swordConnection
local swordList = {
    "Balloon Sword", "Classic Sword", "Lamppost", "King Slayer", "Pine Tree", "Soulreaper", "Billboard"
}

MainTab:AddToggle("AutoSwordToggle", {
    Title = "Auto Use Sword (Auto Equips)",
    Description = "Automatically use sword weapons",
    Default = false,
    Callback = function(Value)
        isUsingSword = Value
        if Value then
            swordConnection = RunService.Heartbeat:Connect(function()
                if not isUsingSword then return end
                
                local player = game.Players.LocalPlayer
                local character = player.Character
                if not character then return end
                
                local foundSword = nil
                for _, swordName in ipairs(swordList) do
                    local sword = character:FindFirstChild(swordName) or player.Backpack:FindFirstChild(swordName)
                    if sword then
                        foundSword = sword
                        break
                    end
                end
                
                if foundSword then
                    if foundSword.Parent == player.Backpack then
                        foundSword.Parent = character
                    end
                    
                    if foundSword:IsA("Tool") then
                        foundSword:Activate()
                    end
                end
            end)
            Fluent:Notify({
                Title = "Auto Sword",
                Content = "Auto sword enabled",
                Duration = 3
            })
        else
            if swordConnection then
                swordConnection:Disconnect()
                swordConnection = nil
            end
            Fluent:Notify({
                Title = "Auto Sword",
                Content = "Auto sword disabled",
                Duration = 3
            })
        end
    end
})

-- Auto Bring Implementation
local isBringing = false
local bringConnection

MainTab:AddToggle("AutoBringToggle", {
    Title = "Auto Bring Noobs/Werewolves",
    Description = "Automatically bring targets to you",
    Default = false,
    Callback = function(Value)
        isBringing = Value
        if Value then
            bringConnection = RunService.Heartbeat:Connect(function()
                if not isBringing then return end
                
                local character = game.Players.LocalPlayer.Character
                if not character then return end
                
                local humanoidRootPart = character:FindFirstChild("HumanoidRootPart")
                if not humanoidRootPart then return end
                
                local npcFolder = workspace:FindFirstChild("#GAME") and workspace["#GAME"]:FindFirstChild("Folders") and 
                                 workspace["#GAME"].Folders:FindFirstChild("HumanoidFolder") and 
                                 workspace["#GAME"].Folders.HumanoidFolder:FindFirstChild("NPCFolder")
                
                if not npcFolder then return end
                
                for _, npc in ipairs(npcFolder:GetChildren()) do
                    if npc:IsA("Model") and npc:FindFirstChild("HumanoidRootPart") then
                        local direction = humanoidRootPart.CFrame.LookVector
                        local newPosition = humanoidRootPart.Position + direction * 10
                        npc:SetPrimaryPartCFrame(CFrame.new(newPosition))
                    end
                end
            end)
            Fluent:Notify({
                Title = "Auto Bring",
                Content = "Auto bring enabled",
                Duration = 3
            })
        else
            if bringConnection then
                bringConnection:Disconnect()
                bringConnection = nil
            end
            Fluent:Notify({
                Title = "Auto Bring",
                Content = "Auto bring disabled",
                Duration = 3
            })
        end
    end
})

MainTab:AddParagraph({
    Title = "Auto Teleport/Collect/Click Stuff",
    Content = ""
})

-- Egg Collection System (Optimized for Auto Teleport)
local EggSystem = {
    Workspace = game:GetService("Workspace"),
    Players = game:GetService("Players"),
    RunService = game:GetService("RunService"),
    VirtualInputManager = game:GetService("VirtualInputManager"),
    
    Player = nil,
    
    -- Feature toggles
    isAutoSetHoldDuration = false,
    isTeleportToEggs = false,
    isAutoSpamKey = false,
    
    -- Threads
    autoSetHoldDurationThread = nil,
    teleportToEggsThread = nil,
    spamKeyThread = nil,
    
    -- Performance optimization
    cachedEggPrompts = {},
    cachedEggs = {},
    lastScanTime = 0,
    SCAN_INTERVAL = 0.1, -- Faster scanning
    lastTeleportTime = 0,
    TELEPORT_COOLDOWN = 0.01, -- Very fast cooldown
    lastPromptTime = 0,
    PROMPT_COOLDOWN = 0.5,
    
    -- Performance monitoring
    frameCount = 0,
    lastFPSUpdate = tick(),
    currentFPS = 60
}

-- Initialize
EggSystem.Player = EggSystem.Players.LocalPlayer

-- Function to monitor FPS and adjust performance
function EggSystem:monitorPerformance()
    self.frameCount = self.frameCount + 1
    local currentTime = tick()
    
    if currentTime - self.lastFPSUpdate >= 1 then
        self.currentFPS = self.frameCount
        self.frameCount = 0
        self.lastFPSUpdate = currentTime
        
        if self.currentFPS < 30 then
            self.SCAN_INTERVAL = 0.5
            self.TELEPORT_COOLDOWN = 0.02
        else
            self.SCAN_INTERVAL = 0.1
            self.TELEPORT_COOLDOWN = 0.01
        end
    end
end

-- Function to safely stop threads
function EggSystem:stopThread(thread)
    if thread then
        task.cancel(thread)
        return nil
    end
    return nil
end

-- Function to check if object is an Egg and still exists
function EggSystem:isEgg(obj)
    if not obj or not obj.Parent then
        return false
    end
    
    local isValidType = obj:IsA("BasePart") or obj:IsA("Model") or obj:IsA("MeshPart")
    if not isValidType then
        return false
    end
    
    -- Check if name contains "Egg" (case insensitive)
    return string.find(obj.Name:lower(), "egg")
end

-- Function to get valid egg position (checks if egg still exists)
function EggSystem:getValidEggPosition(egg)
    if not egg or not egg.Parent then
        return nil
    end
    
    local success, position = pcall(function()
        if egg:IsA("Model") then
            if egg.PrimaryPart and egg.PrimaryPart.Parent then
                return egg.PrimaryPart.Position
            else
                local firstPart = egg:FindFirstChildWhichIsA("BasePart")
                if firstPart and firstPart.Parent then
                    return firstPart.Position
                end
            end
        else
            -- MeshPart or BasePart
            if egg.Parent then
                return egg.Position
            end
        end
        return nil
    end)
    
    return success and position or nil
end

-- FAST function to get fresh eggs from DumpFolder
function EggSystem:getFreshEggs()
    self.cachedEggs = {}
    
    local dumpFolder = self.Workspace:FindFirstChild("#GAME") and 
                      self.Workspace["#GAME"]:FindFirstChild("Folders") and 
                      self.Workspace["#GAME"].Folders:FindFirstChild("DumpFolder")
    
    if dumpFolder then
        -- Fast scan through all children
        for _, egg in pairs(dumpFolder:GetChildren()) do
            if self:isEgg(egg) then
                local position = self:getValidEggPosition(egg)
                if position then
                    table.insert(self.cachedEggs, {
                        object = egg,
                        position = position
                    })
                end
            end
        end
    end
    
    self.lastScanTime = tick()
    return self.cachedEggs
end

-- OPTIMIZED: Function to get ProximityPrompts without lag
function EggSystem:getEggProximityPrompts()
    local currentTime = tick()
    
    -- Only rescan if cache is empty or enough time has passed
    if #self.cachedEggPrompts == 0 or (currentTime - self.lastScanTime) > 5.0 then -- Increased to 5 seconds
        self.cachedEggPrompts = {}
        
        -- Only scan DumpFolder (removed workspace scan to reduce lag)
        local dumpFolder = self.Workspace:FindFirstChild("#GAME") and 
                          self.Workspace["#GAME"]:FindFirstChild("Folders") and 
                          self.Workspace["#GAME"].Folders:FindFirstChild("DumpFolder")
        
        if dumpFolder then
            -- Limit scanning to prevent lag
            local scanCount = 0
            for _, egg in pairs(dumpFolder:GetChildren()) do
                if scanCount > 50 then break end -- Safety limit
                
                if self:isEgg(egg) then
                    -- Only check first few descendants to prevent lag
                    local prompt = egg:FindFirstChildWhichIsA("ProximityPrompt")
                    if prompt and prompt.Parent then
                        table.insert(self.cachedEggPrompts, prompt)
                    else
                        -- Quick check for prompts in descendants (limited)
                        local descendants = egg:GetDescendants()
                        for i = 1, math.min(10, #descendants) do -- Limit to 10 descendants
                            local descendant = descendants[i]
                            if descendant:IsA("ProximityPrompt") then
                                table.insert(self.cachedEggPrompts, descendant)
                                break -- Only need one prompt per egg
                            end
                        end
                    end
                    scanCount = scanCount + 1
                end
            end
        end
        
        self.lastScanTime = currentTime
    end
    
    return self.cachedEggPrompts
end

-- OPTIMIZED: Function to auto set ProximityPrompts without lag
function EggSystem:autoSetHoldDuration()
    while self.isAutoSetHoldDuration do
        -- Only process if we have prompts
        local eggPrompts = self:getEggProximityPrompts()
        
        if #eggPrompts > 0 then
            -- Process prompts in batches to prevent lag
            local processed = 0
            for _, prompt in ipairs(eggPrompts) do
                if not self.isAutoSetHoldDuration then break end
                
                if prompt and prompt.Parent then
                    -- Only update if needed (reduces unnecessary operations)
                    if prompt.HoldDuration ~= 0 then
                        prompt.HoldDuration = 0
                    end
                    if not prompt.Enabled then
                        prompt.Enabled = true
                    end
                    if prompt.RequiresLineOfSight then
                        prompt.RequiresLineOfSight = false
                    end
                    
                    processed = processed + 1
                    -- Small yield every 10 prompts to prevent freezing
                    if processed % 10 == 0 then
                        task.wait()
                    end
                end
            end
        end
        
        -- Much longer wait between scans to reduce CPU usage
        task.wait(3.0) -- Increased from 0.1 to 3.0 seconds
    end
end

-- ULTRA FAST: Function to teleport to eggs - optimized for AFK farming
function EggSystem:teleportToEggs()
    while self.isTeleportToEggs do
        local currentTime = tick()
        
        -- No cooldown check - teleport as fast as possible
        local character = self.Player.Character
        if not character then
            task.wait(0.1)
            continue
        end
        
        local humanoidRootPart = character:FindFirstChild("HumanoidRootPart")
        if not humanoidRootPart then
            task.wait(0.1)
            continue
        end
        
        -- Get fresh eggs every time
        local eggs = self:getFreshEggs()
        
        if #eggs > 0 then
            -- Find the closest valid egg
            local closestEgg = nil
            local closestDistance = math.huge
            
            for _, eggData in ipairs(eggs) do
                if not self.isTeleportToEggs then break end
                
                -- Quick check if egg still exists
                if eggData.object and eggData.object.Parent then
                    local freshPosition = self:getValidEggPosition(eggData.object)
                    if freshPosition then
                        local distance = (humanoidRootPart.Position - freshPosition).Magnitude
                        if distance < closestDistance then
                            closestDistance = distance
                            closestEgg = eggData
                        end
                    end
                end
            end
            
            if closestEgg then
                -- Instant teleport to the closest egg
                local success = pcall(function()
                    humanoidRootPart.CFrame = CFrame.new(closestEgg.position + Vector3.new(0, 3, 0))
                end)
                
                if not success then
                    -- If teleport failed, tiny wait
                    task.wait(0.01)
                end
            end
        end
        
        -- Minimal wait between scans
        task.wait(0.01)
    end
end

-- Function to auto spam E key
function EggSystem:autoSpamKey()
    while self.isAutoSpamKey do
        if self.isAutoSpamKey then
            self.VirtualInputManager:SendKeyEvent(true, Enum.KeyCode.E, false, game)
            task.wait(0.01)
            self.VirtualInputManager:SendKeyEvent(false, Enum.KeyCode.E, false, game)
            task.wait(0.01)
        end
    end
end

-- Function to restart all active features after respawn
function EggSystem:restartFeatures()
    -- Minimal wait for character to load
    task.wait(1.0)
    
    -- Clear cache on respawn
    self.cachedEggPrompts = {}
    self.cachedEggs = {}
    self.lastScanTime = 0
    
    -- Restart features if they were active
    if self.isAutoSetHoldDuration then
        self.autoSetHoldDurationThread = self:stopThread(self.autoSetHoldDurationThread)
        task.wait(0.5) -- Small delay before restarting
        self.autoSetHoldDurationThread = task.spawn(function()
            self:autoSetHoldDuration()
        end)
    end
    
    if self.isTeleportToEggs then
        self.teleportToEggsThread = self:stopThread(self.teleportToEggsThread)
        task.wait(0.5) -- Small delay before restarting
        self.teleportToEggsThread = task.spawn(function()
            self:teleportToEggs()
        end)
    end
    
    if self.isAutoSpamKey then
        self.spamKeyThread = self:stopThread(self.spamKeyThread)
        task.wait(0.5) -- Small delay before restarting
        self.spamKeyThread = task.spawn(function()
            self:autoSpamKey()
        end)
    end
end

-- Connect to character added event for respawn handling
EggSystem.Player.CharacterAdded:Connect(function(character)
    EggSystem:restartFeatures()
end)

-- UI Elements (Keeping your Fluent UI format)
MainTab:AddToggle("AutoInstantCDToggle", {
    Title = "Auto Set Instant CD To Eggs (Fast)",
    Description = "Set instant cooldown for eggs - scans every 0.5s",
    Default = false,
    Callback = function(Value)
        EggSystem.isAutoSetHoldDuration = Value
        if Value then
            -- Clear cache and start immediately
            EggSystem.cachedEggPrompts = {}
            EggSystem.lastScanTime = 0
            
            -- Force one immediate scan
            EggSystem:getEggProximityPrompts()
            
            EggSystem.autoSetHoldDurationThread = task.spawn(function()
                EggSystem:autoSetHoldDuration()
            end)
            Fluent:Notify({
                Title = "Instant CD",
                Content = "Instant Cooldown Enabled - Scanning every 0.5s",
                Duration = 3
            })
        else
            if EggSystem.autoSetHoldDurationThread then
                EggSystem:stopThread(EggSystem.autoSetHoldDurationThread)
                EggSystem.autoSetHoldDurationThread = nil
            end
            Fluent:Notify({
                Title = "Instant CD",
                Content = "Instant Cooldown Disabled",
                Duration = 3
            })
        end
    end
})

MainTab:AddToggle("AutoTeleportEggsToggle", {
    Title = "Auto Teleport To Eggs (AFK Farm)",
    Description = "Only teleports to existing eggs - no ghost teleports",
    Default = false,
    Callback = function(Value)
        EggSystem.isTeleportToEggs = Value
        if Value then
            EggSystem.teleportToEggsThread = task.spawn(function()
                EggSystem:teleportToEggs()
            end)
            Fluent:Notify({
                Title = "Egg Teleport",
                Content = "Auto Teleport to Eggs Enabled - AFK Farming Active",
                Duration = 3
            })
        else
            EggSystem.teleportToEggsThread = EggSystem:stopThread(EggSystem.teleportToEggsThread)
            Fluent:Notify({
                Title = "Egg Teleport",
                Content = "Auto Teleport to Eggs Disabled",
                Duration = 3
            })
        end
    end
})

MainTab:AddToggle("AutoSpamProximityToggle", {
    Title = "Auto Spam E Key",
    Description = "Spams E key for collection",
    Default = false,
    Callback = function(Value)
        EggSystem.isAutoSpamKey = Value
        if Value then
            EggSystem.spamKeyThread = task.spawn(function()
                EggSystem:autoSpamKey()
            end)
            Fluent:Notify({
                Title = "Auto Spam E",
                Content = "Auto spamming E key enabled",
                Duration = 3
            })
        else
            EggSystem.spamKeyThread = EggSystem:stopThread(EggSystem.spamKeyThread)
            Fluent:Notify({
                Title = "Auto Spam E",
                Content = "Auto spamming E key disabled",
                Duration = 3
            })
        end
    end
})

-- Egg Spawn Notifier
local EggNotifier = {
    enabled = false,
    connection = nil,
    detectedEggs = {}
}

-- Function to check if object is an Egg
EggNotifier.isEgg = function(obj)
    if not obj or not obj.Parent then
        return false
    end
    
    local isValidType = obj:IsA("BasePart") or obj:IsA("Model") or obj:IsA("MeshPart")
    if not isValidType then
        return false
    end
    
    -- Check if name contains "Egg" (case insensitive)
    return string.find(obj.Name:lower(), "egg")
end

-- Function to handle new descendants
EggNotifier.onDescendantAdded = function(descendant)
    if not EggNotifier.enabled then return end
    
    if EggNotifier.isEgg(descendant) then
        local eggName = descendant.Name
        local eggId = tostring(descendant:GetFullName())
        
        -- Check if we've already detected this egg
        if not EggNotifier.detectedEggs[eggId] then
            EggNotifier.detectedEggs[eggId] = true
            
            -- Send notification using Fluent
            Fluent:Notify({
                Title = " Egg Spawned!",
                Content = eggName .. " has spawned!",
                Duration = 5
            })
            
            -- Optional: Print to console for debugging
            warn("EGG SPAWNED: " .. eggName .. " at " .. tostring(descendant:GetFullName()))
        end
    end
end

-- Function to start egg spawn detection
EggNotifier.startDetection = function()
    if EggNotifier.connection then
        EggNotifier.connection:Disconnect()
    end
    
    -- Clear previous detections
    EggNotifier.detectedEggs = {}
    
    -- Connect to descendant added event
    EggNotifier.connection = workspace.DescendantAdded:Connect(EggNotifier.onDescendantAdded)
    
    -- Also check for existing eggs when starting
    task.spawn(function()
        task.wait(1) -- Wait a bit for game to load
        
        local dumpFolder = workspace:FindFirstChild("#GAME") and 
                          workspace["#GAME"]:FindFirstChild("Folders") and 
                          workspace["#GAME"].Folders:FindFirstChild("DumpFolder")
        
        if dumpFolder then
            for _, egg in pairs(dumpFolder:GetChildren()) do
                if EggNotifier.isEgg(egg) then
                    local eggId = tostring(egg:GetFullName())
                    if not EggNotifier.detectedEggs[eggId] then
                        EggNotifier.detectedEggs[eggId] = true
                        Fluent:Notify({
                            Title = " Egg Detected",
                            Content = egg.Name .. " already exists!",
                            Duration = 3
                        })
                    end
                end
            end
        end
    end)
end

-- Function to stop egg spawn detection
EggNotifier.stopDetection = function()
    if EggNotifier.connection then
        EggNotifier.connection:Disconnect()
        EggNotifier.connection = nil
    end
    EggNotifier.detectedEggs = {}
end

-- Add the toggle to your tab (replace "Tab" with the actual tab variable)
MainTab:AddToggle("AutoNotifyEggToggle", {
    Title = "Auto Notify Spawned Egg",
    Description = "Get notified when eggs spawn",
    Default = false,
    Callback = function(Value)
        EggNotifier.enabled = Value
        
        if Value then
            EggNotifier.startDetection()
            Fluent:Notify({
                Title = "Egg Notifier",
                Content = "Egg spawn notifications enabled!",
                Duration = 3
            })
        else
            EggNotifier.stopDetection()
            Fluent:Notify({
                Title = "Egg Notifier",
                Content = "Egg spawn notifications disabled!",
                Duration = 3
            })
        end
    end
})

-- Optional: Add a button to manually check for eggs
MainTab:AddButton({
    Title = "Check For Existing Eggs",
    Description = "Count eggs currently in DumpFolder",
    Callback = function()
        local eggCount = 0
        local dumpFolder = workspace:FindFirstChild("#GAME") and 
                          workspace["#GAME"]:FindFirstChild("Folders") and 
                          workspace["#GAME"].Folders:FindFirstChild("DumpFolder")
        
        if dumpFolder then
            for _, egg in pairs(dumpFolder:GetChildren()) do
                if EggNotifier.isEgg(egg) then
                    eggCount = eggCount + 1
                end
            end
        end
        
        Fluent:Notify({
            Title = "Egg Check",
            Content = "Found " .. eggCount .. " eggs in DumpFolder",
            Duration = 3
        })
    end
})

-- Optional: Add a button to clear egg detection history
MainTab:AddButton({
    Title = "Clear Egg Detection History",
    Description = "Clear detected egg cache",
    Callback = function()
        EggNotifier.detectedEggs = {}
        Fluent:Notify({
            Title = "Egg Notifier",
            Content = "Egg detection history cleared!",
            Duration = 3
        })
    end
})

-- ========== BADGES TAB ==========
local BadgesTab = Tabs.Badges

BadgesTab:AddParagraph({
    Title = "Secret Badge 1",
    Content = ""
})

_G.CrackedBasGunName = "Minigun"
_G.CrackedBasShootingSpeed = 6
_G.CrackedBasAutoShootEnabled = false
_G.CrackedBasMaxDistance = 1000
_G.CrackedBasAutoShootConnection = nil

BadgesTab:AddInput("CrackedBasGunName", {
    Title = "Gun Name",
    Default = "Minigun",
    Placeholder = "Enter gun name",
    Numeric = false,
    Finished = false,
    Callback = function(Text)
        _G.CrackedBasGunName = Text or "Minigun"
    end
})

BadgesTab:AddInput("CrackedBasShootingSpeed", {
    Title = "Shooting Speed",
    Default = "6",
    Placeholder = "Enter shooting speed",
    Numeric = true,
    Finished = false,
    Callback = function(Text)
        _G.CrackedBasShootingSpeed = math.clamp(tonumber(Text) or 6, 1, 60)
    end
})

BadgesTab:AddInput("CrackedBasMaxDistance", {
    Title = "Max Distance",
    Default = "1000",
    Placeholder = "Enter max distance",
    Numeric = true,
    Finished = false,
    Callback = function(Text)
        _G.CrackedBasMaxDistance = math.clamp(tonumber(Text) or 1000, 10, 5000)
    end
})

BadgesTab:AddToggle("AutoShootCrackedBasToggle", {
    Title = "Auto Shoot (CrackedBas Only)",
    Description = "Automatically shoot only CrackedBas",
    Default = false,
    Callback = function(Value)
        _G.CrackedBasAutoShootEnabled = Value
        
        if Value then
            if _G.CrackedBasAutoShootConnection then
                _G.CrackedBasAutoShootConnection:Disconnect()
                _G.CrackedBasAutoShootConnection = nil
            end
            
            _G.CrackedBasAutoShootConnection = RunService.Heartbeat:Connect(function()
                if not _G.CrackedBasAutoShootEnabled then 
                    if _G.CrackedBasAutoShootConnection then
                        _G.CrackedBasAutoShootConnection:Disconnect()
                        _G.CrackedBasAutoShootConnection = nil
                    end
                    return 
                end
                
                local character = getCharacter()
                if not character then return end
                
                local targets = findSpecificNPCs({"CrackedBas"})
                if #targets > 0 then
                    FireAttack(targets[1], _G.CrackedBasGunName)
                end
                
                task.wait(0.1 / _G.CrackedBasShootingSpeed)
            end)
            
            Fluent:Notify({
                Title = "Auto Shoot",
                Content = "Auto Shooting CrackedBas Only - Enabled",
                Duration = 3
            })
        else
            if _G.CrackedBasAutoShootConnection then
                _G.CrackedBasAutoShootConnection:Disconnect()
                _G.CrackedBasAutoShootConnection = nil
            end
            Fluent:Notify({
                Title = "Auto Shoot",
                Content = "Auto Shooting CrackedBas Only - Disabled",
                Duration = 3
            })
        end
    end
})

-- Fix the Teleport To Room button
BadgesTab:AddButton({
    Title = "Teleport To Room (Make Sure Bas From Chair Is Killed)",
    Description = "Teleport to the secret room",
    Callback = function()
        local success = pcall(function()
            if workspace:FindFirstChild("#GAME") and workspace["#GAME"]:FindFirstChild("Map") and
               workspace["#GAME"].Map:FindFirstChild("_Other") and 
               workspace["#GAME"].Map._Other:FindFirstChild("Shop") and
               workspace["#GAME"].Map._Other.Shop:FindFirstChild("ShopPictureFrame") and
               workspace["#GAME"].Map._Other.Shop.ShopPictureFrame:FindFirstChild("Back") and
               workspace["#GAME"].Map._Other.Shop.ShopPictureFrame.Back:FindFirstChild("ClickDetector") then
                fireclickdetector(workspace["#GAME"].Map._Other.Shop.ShopPictureFrame.Back.ClickDetector)
            end
        end)
        
        if success then
            Fluent:Notify({
                Title = "Teleport",
                Content = "Teleported to room successfully",
                Duration = 3
            })
        else
            Fluent:Notify({
                Title = "Error",
                Content = "Failed to teleport to room",
                Duration = 3
            })
        end
    end
})

-- Fix the Teleport To WhiteBas button
BadgesTab:AddButton({
    Title = "Teleport To WhiteBas",
    Description = "Teleport to WhiteBas location",
    Callback = function()
        local function findWhiteBas()
            -- Search in NPCFolder first
            local npcFolder = workspace:FindFirstChild("#GAME") and 
                             workspace["#GAME"]:FindFirstChild("Folders") and 
                             workspace["#GAME"].Folders:FindFirstChild("HumanoidFolder") and 
                             workspace["#GAME"].Folders.HumanoidFolder:FindFirstChild("NPCFolder")
            
            if npcFolder then
                local whiteBas = npcFolder:FindFirstChild("WhiteBas")
                if whiteBas then
                    return whiteBas
                end
            end
            
            -- Search in entire workspace as backup
            for _, obj in pairs(workspace:GetDescendants()) do
                if obj:IsA("Model") and obj.Name == "WhiteBas" then
                    return obj
                end
            end
            
            return nil
        end
        
        local whiteBas = findWhiteBas()
        local character = game.Players.LocalPlayer.Character
        
        if whiteBas and character then
            local humanoidRootPart = character:FindFirstChild("HumanoidRootPart")
            local whiteBasPrimary = whiteBas.PrimaryPart or whiteBas:FindFirstChild("HumanoidRootPart") or whiteBas:FindFirstChild("Head")
            
            if humanoidRootPart and whiteBasPrimary then
                humanoidRootPart.CFrame = CFrame.new(whiteBasPrimary.Position + Vector3.new(0, 5, 0))
                Fluent:Notify({
                    Title = "Teleport",
                    Content = "Successfully teleported to WhiteBas!",
                    Duration = 3
                })
            else
                Fluent:Notify({
                    Title = "Teleport",
                    Content = "Failed to find position for teleport",
                    Duration = 3
                })
            end
        else
            Fluent:Notify({
                Title = "Teleport",
                Content = "WhiteBas not found in the game!",
                Duration = 3
            })
        end
    end
})

_G.BothBasGunName = "Minigun"
_G.BothBasShootingSpeed = 6
_G.BothBasAutoShootEnabled = false
_G.BothBasMaxDistance = 1000
_G.BothBasAutoShootConnection = nil

BadgesTab:AddInput("BothBasGunName", {
    Title = "Gun Name",
    Default = "Minigun",
    Placeholder = "Enter gun name",
    Numeric = false,
    Finished = false,
    Callback = function(Text)
        _G.BothBasGunName = Text or "Minigun"
    end
})

BadgesTab:AddInput("BothBasShootingSpeed", {
    Title = "Shooting Speed",
    Default = "6",
    Placeholder = "Enter shooting speed",
    Numeric = true,
    Finished = false,
    Callback = function(Text)
        _G.BothBasShootingSpeed = math.clamp(tonumber(Text) or 6, 1, 60)
    end
})

BadgesTab:AddInput("BothBasMaxDistance", {
    Title = "Max Distance",
    Default = "1000",
    Placeholder = "Enter max distance",
    Numeric = true,
    Finished = false,
    Callback = function(Text)
        _G.BothBasMaxDistance = math.clamp(tonumber(Text) or 1000, 10, 5000)
    end
})

BadgesTab:AddToggle("AutoShootBothBasToggle", {
    Title = "Auto Shoot (CrackedBas & WhiteBas)",
    Description = "Automatically shoot both CrackedBas and WhiteBas",
    Default = false,
    Callback = function(Value)
        _G.BothBasAutoShootEnabled = Value
        
        if Value then
            if _G.BothBasAutoShootConnection then
                _G.BothBasAutoShootConnection:Disconnect()
                _G.BothBasAutoShootConnection = nil
            end
            
            _G.BothBasAutoShootConnection = RunService.Heartbeat:Connect(function()
                if not _G.BothBasAutoShootEnabled then 
                    if _G.BothBasAutoShootConnection then
                        _G.BothBasAutoShootConnection:Disconnect()
                        _G.BothBasAutoShootConnection = nil
                    end
                    return 
                end
                
                local character = getCharacter()
                if not character then return end
                
                local targets = findSpecificNPCs({"CrackedBas", "WhiteBas"})
                if #targets > 0 then
                    local target = targets[math.random(1, #targets)]
                    FireAttack(target, _G.BothBasGunName)
                end
                
                task.wait(0.1 / _G.BothBasShootingSpeed)
            end)
            
            Fluent:Notify({
                Title = "Auto Shoot",
                Content = "Auto Shooting CrackedBas & WhiteBas - Enabled",
                Duration = 3
            })
        else
            if _G.BothBasAutoShootConnection then
                _G.BothBasAutoShootConnection:Disconnect()
                _G.BothBasAutoShootConnection = nil
            end
            Fluent:Notify({
                Title = "Auto Shoot",
                Content = "Auto Shooting CrackedBas & WhiteBas - Disabled",
                Duration = 3
            })
        end
    end
})

BadgesTab:AddParagraph({
    Title = "Super Secret Badge 1",
    Content = ""
})

BadgesTab:AddButton({
    Title = "Remove Touch Part",
    Description = "So Auto Click Can Work",
    Callback = function()
        local success = pcall(function()
            if workspace:FindFirstChild("#GAME") and workspace["#GAME"]:FindFirstChild("Map") then
                local blackRoom = workspace["#GAME"].Map:FindFirstChild("BlackRoom")
                if blackRoom then
                    local whiteRoom = blackRoom:FindFirstChild("WhiteRoom")
                    if whiteRoom then
                        if whiteRoom:FindFirstChild("TouchPart") then
                            whiteRoom.TouchPart:Destroy()
                        end
                        if whiteRoom:FindFirstChild("TouchPart2") then
                            whiteRoom.TouchPart2:Destroy()
                        end
                        if whiteRoom:FindFirstChild("SoundRaycastPart") then
                            whiteRoom.SoundRaycastPart:Destroy()
                        end
                    end
                end
            end
        end)
        
        if success then
            Fluent:Notify({
                Title = "Touch Parts Removed",
                Content = "Touch parts have been removed",
                Duration = 3
            })
        else
            Fluent:Notify({
                Title = "Error",
                Content = "Failed to remove touch parts",
                Duration = 3
            })
        end
    end
})

BadgesTab:AddButton({
    Title = "View WhiteBas",
    Description = "View WhiteBas character",
    Callback = function()
        local target = workspace["#GAME"].Folders.HumanoidFolder.NPCFolder.WhiteBas
        if target then
            workspace.CurrentCamera.CameraSubject = target
            Fluent:Notify({
                Title = "Viewing WhiteBas",
                Content = "Now viewing WhiteBas",
                Duration = 3
            })
        else
            Fluent:Notify({
                Title = "Error",
                Content = "WhiteBas not found!",
                Duration = 3
            })
        end
    end
})

BadgesTab:AddButton({
    Title = "Unview WhiteBas",
    Description = "Return to local player",
    Callback = function()
        local character = Players.LocalPlayer.Character
        if character then
            local humanoid = character:FindFirstChildOfClass("Humanoid")
            if humanoid then
                workspace.CurrentCamera.CameraSubject = humanoid
            else
                workspace.CurrentCamera.CameraSubject = character
            end
            Fluent:Notify({
                Title = "Unviewed",
                Content = "Returned to local player",
                Duration = 3
            })
        else
            Fluent:Notify({
                Title = "Error",
                Content = "Local player character not found!",
                Duration = 3
            })
        end
    end
})

BadgesTab:AddButton({
    Title = "Teleport To Room",
    Description = "Make Sure Bas From Chair Is Killed",
    Callback = function()
        local success = pcall(function()
            fireclickdetector(workspace["#GAME"].Map._Other.Shop.ShopPictureFrame.Back.ClickDetector)
        end)
        
        if success then
            Fluent:Notify({
                Title = "Teleported",
                Content = "Teleported to room",
                Duration = 3
            })
        else
            Fluent:Notify({
                Title = "Error",
                Content = "Failed to teleport",
                Duration = 3
            })
        end
    end
})

-- Auto Click Head Implementation
local spamEnabled = false
local spamConnection

BadgesTab:AddToggle("AutoClickHeadToggle", {
    Title = "Auto Spam Click Head (0.1 Speed Click)",
    Description = "Automatically click the head",
    Default = false,
    Callback = function(Value)
        spamEnabled = Value
        if Value then
            spamConnection = RunService.Heartbeat:Connect(function()
                if not spamEnabled then return end
                
                local success = pcall(function()
                    local clickDetector = workspace["#GAME"].Map.WhiteBasFakeHead:FindFirstChild("ClickDetector")
                    if clickDetector then
                        fireclickdetector(clickDetector)
                    end
                end)
            end)
            Fluent:Notify({
                Title = "Auto Click Head",
                Content = "Auto clicking head enabled",
                Duration = 3
            })
        else
            if spamConnection then
                spamConnection:Disconnect()
                spamConnection = nil
            end
            Fluent:Notify({
                Title = "Auto Click Head",
                Content = "Auto clicking head disabled",
                Duration = 3
            })
        end
    end
})

BadgesTab:AddButton({
    Title = "Bring Head Cube",
    Description = "Bring the head cube to player",
    Callback = function()
        local player = game.Players.LocalPlayer
        local character = player.Character or player.CharacterAdded:Wait()
        local targetPart = workspace["#GAME"].Map.WhiteBasFakeHead

        if targetPart and character then
            local characterPosition = character:WaitForChild("HumanoidRootPart").Position
            targetPart.CFrame = CFrame.new(characterPosition)
            Fluent:Notify({
                Title = "Head Cube Brought",
                Content = "Head cube brought to character",
                Duration = 3
            })
        else
            Fluent:Notify({
                Title = "Error",
                Content = "Target part or character not found",
                Duration = 3
            })
        end
    end
})

-- Auto Bring Head Implementation
local isAutoBringHead = false
local bringHeadConnection

BadgesTab:AddToggle("AutoBringHeadToggle", {
    Title = "Auto Bring Head Cube (Every 0.3 Sec)",
    Description = "Automatically bring head cube",
    Default = false,
    Callback = function(Value)
        isAutoBringHead = Value
        if Value then
            bringHeadConnection = RunService.Heartbeat:Connect(function()
                if not isAutoBringHead then return end
                
                local player = game.Players.LocalPlayer
                local character = player.Character
                local targetPart = workspace["#GAME"].Map:FindFirstChild("WhiteBasFakeHead")
                
                if targetPart and character then
                    local characterPosition = character:WaitForChild("HumanoidRootPart").Position
                    targetPart.CFrame = CFrame.new(characterPosition)
                end
            end)
            Fluent:Notify({
                Title = "Auto Bring Head",
                Content = "Auto bring head enabled",
                Duration = 3
            })
        else
            if bringHeadConnection then
                bringHeadConnection:Disconnect()
                bringHeadConnection = nil
            end
            Fluent:Notify({
                Title = "Auto Bring Head",
                Content = "Auto bring head disabled",
                Duration = 3
            })
        end
    end
})

BadgesTab:AddButton({
    Title = "Open/Close Door",
    Description = "Toggle door open/close",
    Callback = function()
        local success = pcall(function()
            fireclickdetector(workspace["#GAME"].Map.BlackRoom.WhiteRoom.Door.ClickDetector)
        end)
        
        if success then
            Fluent:Notify({
                Title = "Door Toggled",
                Content = "Door state changed",
                Duration = 3
            })
        else
            Fluent:Notify({
                Title = "Error",
                Content = "Failed to toggle door",
                Duration = 3
            })
        end
    end
})

-- Global Spam Implementation
local globalSpamEnabled = false
local globalSpamConnection

BadgesTab:AddToggle("GlobalSpamToggle", {
    Title = "Auto Spam Click All Bas (0.1 Speed Click)",
    Description = "Spam click all Bas characters",
    Default = false,
    Callback = function(Value)
        globalSpamEnabled = Value
        if Value then
            globalSpamConnection = RunService.Heartbeat:Connect(function()
                if not globalSpamEnabled then return end
                
                for _, basename in ipairs({"YellowBas", "GreyBas", "BlueBas", "WhiteBas", "BlackBas"}) do
                    local success = pcall(function()
                        local clickDetectorPath = workspace:FindFirstChild("#GAME")
                        if clickDetectorPath and clickDetectorPath:FindFirstChild("Map") and clickDetectorPath.Map:FindFirstChild(basename) then
                            local cd = clickDetectorPath.Map[basename]:FindFirstChild("ClickDetector")
                            if cd then
                                fireclickdetector(cd)
                            end
                        end
                    end)
                end
            end)
            Fluent:Notify({
                Title = "Global Spam",
                Content = "Global spam enabled for all Bas",
                Duration = 3
            })
        else
            if globalSpamConnection then
                globalSpamConnection:Disconnect()
                globalSpamConnection = nil
            end
            Fluent:Notify({
                Title = "Global Spam",
                Content = "Global spam disabled",
                Duration = 3
            })
        end
    end
})

-- Auto Notify Implementation
local modelListenerEnabled = false
local notifyConnection

BadgesTab:AddToggle("AutoNotifyToggle", {
    Title = "Auto Notify Heads Spawn",
    Description = "Notify when heads spawn",
    Default = false,
    Callback = function(Value)
        modelListenerEnabled = Value
        if Value then
            notifyConnection = workspace.DescendantAdded:Connect(function(obj)
                if obj:IsA("BasePart") then
                    local modelNotifications = {
                        ["YellowBas"] = {Title = "Alert!", Content = "Yellow Head has spawned!"},
                        ["GreyBas"] = {Title = "Alert!", Content = "Grey Head has spawned!"},
                        ["BlueBas"] = {Title = "Alert!", Content = "Blue Head has spawned!"},
                        ["WhiteBas"] = {Title = "Alert!", Content = "White Head has spawned!"},
                        ["BlackBas"] = {Title = "Alert!", Content = "Black Head has spawned!"},
                    }
                    
                    if modelNotifications[obj.Name] then
                        local notif = modelNotifications[obj.Name]
                        Fluent:Notify({
                            Name = notif.Title,
                            Content = notif.Content,
                            Time = 3
                        })
                    end
                end
            end)
            Fluent:Notify({
                Title = "Auto Notify",
                Content = "Auto notify enabled",
                Duration = 3
            })
        else
            if notifyConnection then
                notifyConnection:Disconnect()
                notifyConnection = nil
            end
            Fluent:Notify({
                Title = "Auto Notify",
                Content = "Auto notify disabled",
                Duration = 3
            })
        end
    end
})

BadgesTab:AddParagraph({
    Title = "Secret Badge 2",
    Content = ""
})

BadgesTab:AddButton({
    Title = "Enable/Disable Fire",
    Description = "Toggle fireplace",
    Callback = function()
        local success = pcall(function()
            fireclickdetector(workspace["#GAME"].Map.Houses["Blue House"].Rooms.LivingRoom.Fireplace.Base.Dial.Interactive.ClickDetector)
        end)
        
        if success then
            Fluent:Notify({
                Title = "Fire Toggled",
                Content = "Fireplace state changed",
                Duration = 3
            })
        else
            Fluent:Notify({
                Title = "Error",
                Content = "Failed to toggle fire",
                Duration = 3
            })
        end
    end
})

BadgesTab:AddButton({
    Title = "Collect All Bacon Parts",
    Description = "Collect all bacon parts in the map",
    Callback = function()
        local collected = 0
        local map = workspace["#GAME"].Map
        for _, part in pairs(map:GetChildren()) do
            if part:IsA("BasePart") and part.Name == "Part" then
                local clickDetector = part:FindFirstChild("ClickDetector")
                if clickDetector then
                    fireclickdetector(clickDetector)
                    collected = collected + 1
                end
            end
        end
        Fluent:Notify({
            Title = "Bacon Parts Collected",
            Content = "Collected " .. collected .. " bacon parts",
            Duration = 3
        })
    end
})

-- Auto Click Image Implementation
local autoClickCorrectImageEnabled = false
local autoClickImageConnection

BadgesTab:AddToggle("AutoClickImageToggle", {
    Title = "Auto Click Correct Image",
    Description = "Automatically click correct images",
    Default = false,
    Callback = function(Value)
        autoClickCorrectImageEnabled = Value
        if Value then
            autoClickImageConnection = RunService.Heartbeat:Connect(function()
                if not autoClickCorrectImageEnabled then return end
                
                local success = pcall(function()
                    local pictureFrame = workspace:FindFirstChild("#GAME")
                        :FindFirstChild("Map")
                        :FindFirstChild("Houses")
                        :FindFirstChild("Blue House")
                        :FindFirstChild("Rooms")
                        :FindFirstChild("LivingRoom")
                        :FindFirstChild("Fireplace")
                        :FindFirstChild("PouwkPictureFrame")

                    if pictureFrame then
                        local crackedBasFace = pictureFrame:FindFirstChild("CrackedBasFace")
                        local clickDetector = pictureFrame:FindFirstChild("ClickDetector")

                        if crackedBasFace and clickDetector then
                            local decal = crackedBasFace:FindFirstChildOfClass("Decal")
                            if decal and decal.Texture then
                                local textureId = decal.Texture
                                if textureId == "http://www.roblox.com/asset/?id=15044103899" or textureId == "rbxassetid://15044103899" then
                                    fireclickdetector(clickDetector)
                                end
                            end
                        end
                    end
                end)
            end)
            Fluent:Notify({
                Title = "Auto Click Image",
                Content = "Auto click image enabled",
                Duration = 3
            })
        else
            if autoClickImageConnection then
                autoClickImageConnection:Disconnect()
                autoClickImageConnection = nil
            end
            Fluent:Notify({
                Title = "Auto Click Image",
                Content = "Auto click image disabled",
                Duration = 3
            })
        end
    end
})

BadgesTab:AddButton({
    Title = "Equip All Bacon Parts",
    Description = "Stand Close To Fire",
    Callback = function()
        local requiredParts = {"Right Leg", "Left Leg", "Right Arm", "Left Arm", "Torso", "Head"}
        local missingParts = {}
        local character = game.Players.LocalPlayer.Character or game.Players.LocalPlayer.CharacterAdded:Wait()
        local backpack = game.Players.LocalPlayer.Backpack

        for _, partName in ipairs(requiredParts) do
            local part = backpack:FindFirstChild(partName)
            if part then
                part.Parent = character
            else
                table.insert(missingParts, partName)
            end
        end

        if #missingParts > 0 then
            local missingPartsMessage = table.concat(missingParts, ", ")
            Fluent:Notify({
                Title = "Missing Parts",
                Content = "Not Found: " .. missingPartsMessage,
                Duration = 5
            })
        else
            Fluent:Notify({
                Title = "All Parts Equipped",
                Content = "Successfully equipped all Bacon parts",
                Duration = 3
            })
        end
    end
})

BadgesTab:AddButton({
    Title = "Teleport To Hatred",
    Description = "Teleport to the hatred",
    Callback = function()
       local function findHatred()
            -- Search in NPCFolder first
            local npcFolder = workspace:FindFirstChild("#GAME") and 
                             workspace["#GAME"]:FindFirstChild("Folders") and 
                             workspace["#GAME"].Folders:FindFirstChild("HumanoidFolder") and 
                             workspace["#GAME"].Folders.HumanoidFolder:FindFirstChild("NPCFolder")
            
            if npcFolder then
                local Hatred = npcFolder:FindFirstChild("Hatred")
                if Hatred then
                    return Hatred
                end
            end
            
            -- Search in entire workspace as backup
            for _, obj in pairs(workspace:GetDescendants()) do
                if obj:IsA("Model") and obj.Name == "Hatred" then
                    return obj
                end
            end
            
            return nil
        end
        
        local Hatred = findHatred()
        local character = game.Players.LocalPlayer.Character
        
        if Hatred and character then
            local humanoidRootPart = character:FindFirstChild("HumanoidRootPart")
            local HatredPosition = Hatred:GetPrimaryPartCFrame().Position
            
            if humanoidRootPart and HatredPosition then
                humanoidRootPart.CFrame = CFrame.new(HatredPosition + Vector3.new(0, 5, 0))
            Fluent:Notify({
                Title = "Teleport",
                Content = "Successfully teleported to Hatred!",
                Duration = 3
            })
            else
            Fluent:Notify({
                Title = "Teleport",
                Content = "Failed to find position for teleport",
                Duration = 3
            })
            end
        else
            Fluent:Notify({
                Title = "Teleport",
                Content = "Hatred not found in the game!",
                Duration = 3
            })
        end
    end
})

-- ========== ESP TAB ==========
local ESPTab = Tabs.ESP

-- ESP Implementation
local PlayerESP = false
local NPCESP = false
local PartESP = false
local EggESP = false
local PresentESP = false
local SoulESP = false

-- Store ESP objects for cleanup
local ESPObjects = {
    Players = {},
    NPCs = {},
    Parts = {},
    Eggs = {},
    Presents = {},
    Souls = {}
}

local function createESP(parent, name, text, color)
    local esp = Instance.new("BillboardGui")
    esp.Name = name
    esp.Adornee = parent
    esp.Size = UDim2.new(0, 150, 0, 40)
    esp.StudsOffset = Vector3.new(0, 2, 0)
    esp.AlwaysOnTop = true
    esp.Parent = parent

    local label = Instance.new("TextLabel")
    label.BackgroundTransparency = 1
    label.Size = UDim2.new(1, 0, 1, 0)
    label.TextSize = 16
    label.Font = Enum.Font.FredokaOne
    label.TextColor3 = color
    label.TextStrokeTransparency = 0.2
    label.Text = text
    label.Parent = esp

    return esp
end

_G.createHighlight = function(parent, color, espType)
    local highlight = Instance.new("Highlight")
    highlight.Parent = parent
    highlight.FillColor = color
    highlight.FillTransparency = 0.5  -- Fixed transparency
    highlight.OutlineColor = color
    highlight.OutlineTransparency = 0
    highlight.DepthMode = Enum.HighlightDepthMode.AlwaysOnTop
    
    -- Store for cleanup
    if espType then
        table.insert(ESPObjects[espType], highlight)
    end
    
    return highlight
end

-- Function to clear all ESP of a specific type
local function clearESP(espType)
    for _, obj in ipairs(ESPObjects[espType]) do
        if obj and obj.Parent then
            obj:Destroy()
        end
    end
    ESPObjects[espType] = {}
end

-- Function to clear all billboard GUIs of a specific type
local function clearBillboards(espName)
    for _, obj in pairs(workspace:GetDescendants()) do
        if obj:IsA("BillboardGui") and obj.Name == espName then
            obj:Destroy()
        end
    end
end

-- Players ESP
ESPTab:AddToggle("PlayerESPToggle", {
    Title = "Players ESP",
    Description = "Show ESP for all players",
    Default = false,
    Callback = function(Value)
        PlayerESP = Value
        if Value then
            clearESP("Players")
            clearBillboards("PlayerEsp")
            
            task.spawn(function()
                while PlayerESP do
                    local localPlayer = game.Players.LocalPlayer
                    for _, player in ipairs(game.Players:GetPlayers()) do
                        if player ~= localPlayer and player.Character then
                            local head = player.Character:FindFirstChild("Head")
                            local humanoid = player.Character:FindFirstChildOfClass("Humanoid")
                            
                            if head and humanoid and humanoid.Health > 0 then
                                -- Create ESP if it doesn't exist
                                if not head:FindFirstChild("PlayerEsp") then
                                    createESP(head, "PlayerEsp", player.Name, Color3.new(1, 1, 1))
                                end
                                
                                -- Create highlight if it doesn't exist
                                if not player.Character:FindFirstChildOfClass("Highlight") then
                                    _G.createHighlight(player.Character, Color3.new(1, 1, 1), "Players")
                                end
                            end
                        end
                    end
                    task.wait(1)
                end
            end)
            Fluent:Notify({
                Title = "Player ESP",
                Content = "Player ESP enabled for all players",
                Duration = 3
            })
        else
            clearESP("Players")
            clearBillboards("PlayerEsp")
            Fluent:Notify({
                Title = "Player ESP",
                Content = "Player ESP disabled",
                Duration = 3
            })
        end
    end
})

-- NPC ESP
ESPTab:AddToggle("NPCESPToggle", {
    Title = "Noobs/Werewolfs/ETC... ESP",
    Description = "Show ESP for all NPCs",
    Default = false,
    Callback = function(Value)
        NPCESP = Value
        if Value then
            clearESP("NPCs")
            clearBillboards("NPCESP")
            
            task.spawn(function()
                while NPCESP do
                    local npcFolder = workspace:FindFirstChild("#GAME") and workspace["#GAME"]:FindFirstChild("Folders") and 
                                     workspace["#GAME"].Folders:FindFirstChild("HumanoidFolder") and 
                                     workspace["#GAME"].Folders.HumanoidFolder:FindFirstChild("NPCFolder")

                    if npcFolder then
                        for _, npc in ipairs(npcFolder:GetChildren()) do
                            if npc:IsA("Model") then
                                local humanoid = npc:FindFirstChildOfClass("Humanoid")
                                local head = npc:FindFirstChild("Head")

                                -- Check if humanoid exists AND health is greater than 0
                                if humanoid and head and humanoid.Health > 0 then
                                    -- Skip dead NPCs by name
                                    if not string.find(npc.Name:lower(), "dead") then
                                        -- Get proper display name (handle zombie transformation)
                                        local displayName = npc.Name
                                        -- Check if it's a zombie by looking for zombie attributes or other indicators
                                        if humanoid:GetAttribute("Zombie") or string.find(npc.Name:lower(), "zombie") then
                                            displayName = "Zombie " .. npc.Name
                                        end
                                        
                                        -- Create ESP if it doesn't exist
                                        if not head:FindFirstChild("NPCESP") then
                                            createESP(head, "NPCESP", displayName, Color3.fromRGB(0, 255, 0))
                                        else
                                            -- Update existing ESP text if name changed
                                            local existingESP = head:FindFirstChild("NPCESP")
                                            if existingESP and existingESP:FindFirstChildOfClass("TextLabel") then
                                                existingESP:FindFirstChildOfClass("TextLabel").Text = displayName
                                            end
                                        end
                                        
                                        -- Create highlight if it doesn't exist
                                        if not npc:FindFirstChildOfClass("Highlight") then
                                            _G.createHighlight(npc, Color3.fromRGB(0, 255, 0), "NPCs")
                                        end
                                    end
                                else
                                    -- Remove ESP from dead NPCs
                                    local existingESP = head and head:FindFirstChild("NPCESP")
                                    if existingESP then
                                        existingESP:Destroy()
                                    end
                                    local highlight = npc and npc:FindFirstChildOfClass("Highlight")
                                    if highlight then
                                        highlight:Destroy()
                                    end
                                end
                            end
                        end
                    end
                    task.wait(1)
                end
            end)
            Fluent:Notify({
                Title = "NPC ESP",
                Content = "NPC ESP enabled for all NPCs",
                Duration = 3
            })
        else
            clearESP("NPCs")
            clearBillboards("NPCESP")
            Fluent:Notify({
                Title = "NPC ESP",
                Content = "NPC ESP disabled",
                Duration = 3
            })
        end
    end
})

-- Bacon Parts ESP
ESPTab:AddToggle("PartESPToggle", {
    Title = "Bacon Parts ESP",
    Description = "Show ESP for all bacon parts",
    Default = false,
    Callback = function(Value)
        PartESP = Value
        if Value then
            clearESP("Parts")
            clearBillboards("PartESP")
            
            task.spawn(function()
                while PartESP do
                    local map = workspace:FindFirstChild("#GAME") and workspace["#GAME"]:FindFirstChild("Map")
                    
                    if map then
                        for _, part in ipairs(map:GetDescendants()) do
                            if part:IsA("BasePart") and part.Name == "Part" then
                                local clickDetector = part:FindFirstChild("ClickDetector")
                                
                                if clickDetector then
                                    -- Create ESP if it doesn't exist
                                    if not part:FindFirstChild("PartESP") then
                                        createESP(part, "PartESP", "Bacon Part", Color3.fromRGB(255, 0, 0))
                                    end
                                    
                                    -- Create highlight if it doesn't exist
                                    if not part:FindFirstChildOfClass("Highlight") then
                                        _G.createHighlight(part, Color3.fromRGB(255, 0, 0), "Parts")
                                    end
                                end
                            end
                        end
                    end
                    task.wait(1)
                end
            end)
            Fluent:Notify({
                Title = "Bacon Parts ESP",
                Content = "Bacon parts ESP enabled for all parts",
                Duration = 3
            })
        else
            clearESP("Parts")
            clearBillboards("PartESP")
            Fluent:Notify({
                Title = "Bacon Parts ESP",
                Content = "Bacon parts ESP disabled",
                Duration = 3
            })
        end
    end
})

-- Eggs ESP
ESPTab:AddToggle("EggESPToggle", {
    Title = "Eggs ESP",
    Description = "Show ESP for all eggs",
    Default = false,
    Callback = function(Value)
        EggESP = Value
        if Value then
            clearESP("Eggs")
            clearBillboards("EggESP")
            
            task.spawn(function()
                while EggESP do
                    local dumpFolder = workspace:FindFirstChild("#GAME") and workspace["#GAME"]:FindFirstChild("Folders") and 
                                     workspace["#GAME"].Folders:FindFirstChild("DumpFolder")
                    
                    if dumpFolder then
                        for _, item in ipairs(dumpFolder:GetChildren()) do
                            if (item:IsA("MeshPart") or item:IsA("Model") or item:IsA("Part")) and string.find(item.Name:lower(), "egg") then
                                local targetPart = item
                                if item:IsA("Model") and item.PrimaryPart then
                                    targetPart = item.PrimaryPart
                                end
                                
                                if targetPart then
                                    -- Create ESP if it doesn't exist
                                    if not targetPart:FindFirstChild("EggESP") then
                                        createESP(targetPart, "EggESP", item.Name, Color3.fromRGB(255, 255, 0))
                                    end
                                    
                                    -- Create highlight if it doesn't exist
                                    if not item:FindFirstChildOfClass("Highlight") then
                                        _G.createHighlight(item, Color3.fromRGB(255, 255, 0), "Eggs")
                                    end
                                end
                            end
                        end
                    end
                    task.wait(1)
                end
            end)
            Fluent:Notify({
                Title = "Eggs ESP",
                Content = "Eggs ESP enabled for all eggs",
                Duration = 3
            })
        else
            clearESP("Eggs")
            clearBillboards("EggESP")
            Fluent:Notify({
                Title = "Eggs ESP",
                Content = "Eggs ESP disabled",
                Duration = 3
            })
        end
    end
})

-- Presents ESP
ESPTab:AddToggle("PresentESPToggle", {
    Title = "Presents ESP",
    Description = "Show ESP for all presents",
    Default = false,
    Callback = function(Value)
        PresentESP = Value
        if Value then
            clearESP("Presents")
            clearBillboards("PresentESP")
            
            task.spawn(function()
                while PresentESP do
                    local dumpFolder = workspace:FindFirstChild("#GAME") and workspace["#GAME"]:FindFirstChild("Folders") and 
                                     workspace["#GAME"].Folders:FindFirstChild("DumpFolder")
                    
                    if dumpFolder then
                        -- Check all descendants for presents
                        for _, item in ipairs(dumpFolder:GetDescendants()) do
                            if (item:IsA("BasePart") or item:IsA("MeshPart") or item:IsA("Model")) and 
                               (item.Name == "Present" or item.Name == "MysteryPresent") then
                                local targetPart = item
                                if item:IsA("Model") and item.PrimaryPart then
                                    targetPart = item.PrimaryPart
                                end
                                
                                if targetPart then
                                    -- Create ESP if it doesn't exist
                                    if not targetPart:FindFirstChild("PresentESP") then
                                        createESP(targetPart, "PresentESP", item.Name, Color3.fromRGB(0, 255, 0))
                                    end
                                    
                                    -- Create highlight if it doesn't exist
                                    if not item:FindFirstChildOfClass("Highlight") then
                                        _G.createHighlight(item, Color3.fromRGB(0, 255, 0), "Presents")
                                    end
                                end
                            end
                        end
                    end
                    task.wait(1)
                end
            end)
            Fluent:Notify({
                Title = "Presents ESP",
                Content = "Presents ESP enabled for all presents",
                Duration = 3
            })
        else
            clearESP("Presents")
            clearBillboards("PresentESP")
            Fluent:Notify({
                Title = "Presents ESP",
                Content = "Presents ESP disabled",
                Duration = 3
            })
        end
    end
})

-- Souls ESP
ESPTab:AddToggle("SoulESPToggle", {
    Title = "Souls ESP",
    Description = "Show ESP for all souls",
    Default = false,
    Callback = function(Value)
        SoulESP = Value
        if Value then
            clearESP("Souls")
            clearBillboards("SoulESP")
            
            task.spawn(function()
                while SoulESP do
                    local dumpFolder = workspace:FindFirstChild("#GAME") and workspace["#GAME"]:FindFirstChild("Folders") and 
                                     workspace["#GAME"].Folders:FindFirstChild("DumpFolder")
                    
                    if dumpFolder then
                        for _, item in ipairs(dumpFolder:GetDescendants()) do
                            if item:IsA("BasePart") and item.Name == "Handle" then
                                -- Create ESP if it doesn't exist
                                if not item:FindFirstChild("SoulESP") then
                                    createESP(item, "SoulESP", "Soul", Color3.fromRGB(0, 255, 255))
                                end
                                
                                -- Create highlight if it doesn't exist
                                if not item:FindFirstChildOfClass("Highlight") then
                                    _G.createHighlight(item, Color3.fromRGB(0, 255, 255), "Souls")
                                end
                            end
                        end
                    end
                    task.wait(1)
                end
            end)
            Fluent:Notify({
                Title = "Souls ESP",
                Content = "Souls ESP enabled for all souls",
                Duration = 3
            })
        else
            clearESP("Souls")
            clearBillboards("SoulESP")
            Fluent:Notify({
                Title = "Souls ESP",
                Content = "Souls ESP disabled",
                Duration = 3
            })
        end
    end
})

-- ========== SHOP TAB ==========
-- ========== SHOP TAB ==========
local ShopTab = Tabs.Shop

-- Shop Items (full list restored)
_G.shopItems = {
    "Great King Poop Noob", "Exclusive 10k Pet", "Bob", "20k Pet", "Party Pedro", "Bombarder Noob Pet", 
    "Exclusive 1 MILLION Pet", "Balloon Tank", "Party Pet", "Buoyant Pet", "Delicious Pet", "Balloon Sword",
    "Revolvah", "Revwholever", "MegAK-47", "Poop Werewolf Pet", "Scammah Pet", "Poop Noob Pet", 
    "Bigger Fat Poop Noob Pet", "Biggest Mega Fat Poop Noob Pet", "Banana Cato", "Sir Stinkington", 
    "Lamppost", "Pine Tree", "Billboard", "Shyserkampfwagen IV", "Turd Maus", "Sebastian", "Toilet Pouwk", 
    "Toilet BULL", "Black Bas", "Turd Mouse", "BULLKERPOUWKER", "Exclusive Verdant Vanquisher", "Justice", 
    "Revolutionary Rain", "Liberty Annihilator", "Chicken Gun", "The Eggsterminator", "Easter Egg", 
    "Chicken", "Lil Scrambler", "Chicken Noob Pet", "Moai Pet", "Strongest Egg", "Bunny Noob Pet", 
    "Supreme Chick", "Bulk Beak", "Stone Cold Cutie", "Suprahme Chick", "Easter Doggo", "Eggstinction Rush X",
    "Firework Launcher", "Bunny Ears", "Nubids Bow", "Teddy", "Heart Pet", "Pinky", "Nubid", "BULLkiePouwk",
    "Pumpkin Launcher", "Little Jack", "Biggest Cracked Bas", "Exclusive 10 MILLION Pet", 
    "Corrupted Black Hole Pet", "Exclusive 100 MILLION Pet", "Exclusive Scarlet Slaughterer", "Soulreaper",
    "The Scepter", "King Biggest Mega Fat Poop Noob", "King Poop Noob", "Queen Poop Noob", "King Noob", 
    "Great King Noob", "Queen Noob", "The Crown", "Festive Noob Pet", "Turkey Pet", "Elf Pet", 
    "Gingerbread Pet", "Santa Pet", "Revolver", "Deagle", "UZI", "Tommy Gun", "AK-47", "Sawed-Off", 
    "Trench Shotgun", "SPAS-12", "AWP", "Remington 700", "RPG-7", "Panzer IV", "Kriss Vector", "Hecate II", 
    "Minigun", "S-G", "MG 1", "M4A3E8", "Microgun", "TMG V2", "M1 Abrams", "SMOGGTTLTSG", "Maus", "UZYeah", 
    "Smiley Sucker", "Revolvahhh", "Baby Noob Pet", "Bacon Pet", "Short Bacon Pet", "Tall Bacon Pet", 
    "Bigger Bacon Pet", "10k Pet", "Rock Noob Pet", "Monster Noob Pet", "Zombie Pet", "Biggest Bacon Pet", 
    "Stick Bug", "Werewolf Pet", "100k Pet", "PedroMobile", "Biggest Bigger Bacon Pet", "Sticker Bug", 
    "Cracked Stick Bug", "Stickest Bug", "Cracked Sticker Bug", "10 MILLION Pet", "Stickester Bug", 
    "100 MILLION Pet", "1 BILLION Pet", "Clown Mouse", "SGobbler", "Pouwk", "Scammer Pet", "Cracked Bas", 
    "BULL", "Sjebullepouwker", "Exclusive 100k Pet", "Cursor", "Silver Cursor", "Golden Cursor", 
    "Diamond Cursor", "Emerald Cursor", "Ruby Cursor", "Amethyst Cursor", "Boots", "Silver Boots", 
    "Golden Boots", "Diamond Boots", "Emerald Boots", "Ruby Boots", "Amethyst Boots", "Gloves", 
    "Silver Gloves", "Golden Gloves", "Diamond Gloves", "Emerald Gloves", "Ruby Gloves", "Amethyst Gloves", 
    "Body Armor", "Silver Body Armor", "Golden Body Armor", "Diamond Body Armor", "Emerald Body Armor", 
    "Ruby Body Armor", "Amethyst Body Armor", "Cheese", "Lantern", "Classic Sword", "King Slayer", 
    "CRACKED Mode", "Hatred", "Onion", "Noob burger", "OOOHnion", "Bigger Noob burger", "Biggest Noob burger", 
    "Biggest Bigger Noob burger"
}

-- Safe sort that removes nil values first
local function safeSort(t)
    local cleaned = {}
    for _, v in ipairs(t) do
        if v ~= nil then
            table.insert(cleaned, v)
        end
    end
    table.sort(cleaned)
    return cleaned
end

_G.shopItems = safeSort(_G.shopItems)

_G.selectedShopItem = "Deagle"

ShopTab:AddDropdown("ShopItemDropdown", {
    Title = "Choose What To Buy From Shop",
    Description = "Select an item to purchase",
    Values = _G.shopItems,
    Default = "Deagle",
    Multi = false,
    Callback = function(Value)
        _G.selectedShopItem = Value
    end
})

ShopTab:AddButton({
    Title = "Buy Item From Shop",
    Description = "Purchase selected item",
    Callback = function()
        if ReplicatedStorage:FindFirstChild("Events") and ReplicatedStorage.Events:FindFirstChild("BuyItem") then
            ReplicatedStorage.Events.BuyItem:FireServer(_G.selectedShopItem)
            Fluent:Notify({
                Title = "Item Purchased",
                Content = "Purchased: " .. _G.selectedShopItem,
                Duration = 3
            })
        else
            Fluent:Notify({
                Title = "Error",
                Content = "BuyItem event not found",
                Duration = 3
            })
        end
    end
})

-- Auto Buy Implementation
_G.autoBuyEnabled = false
_G.autoBuyConnection = nil

ShopTab:AddToggle("AutoBuyToggle", {
    Title = "Auto Buy Item From Shop",
    Description = "Automatically buy selected item",
    Default = false,
    Callback = function(Value)
        _G.autoBuyEnabled = Value
        if Value then
            _G.autoBuyConnection = RunService.Heartbeat:Connect(function()
                if not _G.autoBuyEnabled then return end
                
                if ReplicatedStorage:FindFirstChild("Events") and ReplicatedStorage.Events:FindFirstChild("BuyItem") then
                    ReplicatedStorage.Events.BuyItem:FireServer(_G.selectedShopItem)
                end
                task.wait(1)
            end)
            Fluent:Notify({
                Title = "Auto Buy",
                Content = "Auto buy enabled for " .. _G.selectedShopItem,
                Duration = 3
            })
        else
            if _G.autoBuyConnection then
                _G.autoBuyConnection:Disconnect()
                _G.autoBuyConnection = nil
            end
            Fluent:Notify({
                Title = "Auto Buy",
                Content = "Auto buy disabled",
                Duration = 3
            })
        end
    end
})

-- ========== SCRIPTS TAB ==========
local ScriptsTab = Tabs.Scripts

ScriptsTab:AddParagraph({
    Title = "ZScriptX",
    Content = ""
})

ScriptsTab:AddButton({
    Title = "SAEN Script",
    Description = "Load ZScriptX SAEN script",
    Callback = function()
        local success, result = pcall(function()
            loadstring(game:HttpGet('https://raw.githubusercontent.com/sederyttv-scripter/Wow/refs/heads/main/djdj'))()
        end)
        
        if success then
            Fluent:Notify({
                Title = "Script Loaded",
                Content = "ZScriptX SAEN script loaded",
                Duration = 3
            })
        else
            Fluent:Notify({
                Title = "Error",
                Content = "Failed to load script: " .. tostring(result),
                Duration = 5
            })
        end
    end
})

-- ========== INVENTORY TAB ==========
local InventoryTab = Tabs.Inventory

-- Inventory Implementation
_G.selectedPlayer = Players.LocalPlayer
_G.autoUpdateInventory = false
_G.playerDropdown = nil  -- Store the dropdown reference

_G.updatePlayerList = function()
    local playerNames = {}
    for _, player in ipairs(Players:GetPlayers()) do
        table.insert(playerNames, player.Name)
    end
    table.sort(playerNames)
    return playerNames
end

-- Store the dropdown in _G so we can access it later
_G.playerDropdown = InventoryTab:AddDropdown("PlayerSelectDropdown", {
    Title = "Select Player",
    Description = "Choose player to view inventory",
    Values = _G.updatePlayerList(),
    Default = Players.LocalPlayer.Name,
    Multi = false,
    Callback = function(Value)
        _G.selectedPlayer = Players:FindFirstChild(Value)
    end
})

InventoryTab:AddButton({
    Title = "Update Player List",
    Description = "Refresh player list",
    Callback = function()
        -- Safe way to update dropdown values
        local success, result = pcall(function()
            if _G.playerDropdown then
                _G.playerDropdown:SetValues(_G.updatePlayerList())
            end
        end)
        
        if success then
            Fluent:Notify({
                Title = "Player List Updated",
                Content = "Player list refreshed",
                Duration = 3
            })
        else
            Fluent:Notify({
                Title = "Update Failed",
                Content = "Could not update player list",
                Duration = 3
            })
        end
    end
})

inventoryDisplay = InventoryTab:AddParagraph({
    Title = "Inventory Items:",
    Content = "Select a player to view their inventory"
})

_G.updateInventoryDisplay = function()
    local tools = {}
    
    if _G.selectedPlayer then
        -- Check backpack
        if _G.selectedPlayer:FindFirstChild("Backpack") then
            for _, tool in ipairs(_G.selectedPlayer.Backpack:GetChildren()) do
                if tool:IsA("Tool") then
                    local amount = tool:GetAttribute("Amount")
                    if amount then
                        table.insert(tools, tool.Name .. " " .. tostring(amount))
                    else
                        table.insert(tools, tool.Name)
                    end
                end
            end
        end
        
        -- Check equipped tools
        if _G.selectedPlayer.Character then
            for _, tool in ipairs(_G.selectedPlayer.Character:GetChildren()) do
                if tool:IsA("Tool") then
                    local amount = tool:GetAttribute("Amount")
                    if amount then
                        table.insert(tools, tool.Name .. " " .. tostring(amount))
                    else
                        table.insert(tools, tool.Name)
                    end
                end
            end
        end
    end
    
    local displayText = ""
    if #tools > 0 then
        for i, tool in ipairs(tools) do
            displayText = displayText .. tool
            if i < #tools then
                displayText = displayText .. "\n"
            end
        end
    else
        displayText = "No tools found in inventory"
    end
    
    -- Safe update of display
    local success, err = pcall(function()
        inventoryDisplay:SetDesc(displayText)
    end)
    
    if not success then
        warn("Failed to update inventory display: " .. tostring(err))
    end
end

InventoryTab:AddToggle("AutoUpdateInventoryToggle", {
    Title = "Auto Set Info",
    Description = "Automatically update inventory display",
    Default = false,
    Callback = function(Value)
        _G.autoUpdateInventory = Value
        if Value then
            -- Use a separate thread for auto-update to prevent blocking
            task.spawn(function()
                while _G.autoUpdateInventory do
                    _G.updateInventoryDisplay()
                    task.wait(0.5)  -- Increased delay to reduce CPU usage
                end
            end)
        end
    end
})

-- Add a manual refresh button as backup
InventoryTab:AddButton({
    Title = "Refresh Inventory",
    Description = "Manually refresh inventory display",
    Callback = function()
        _G.updateInventoryDisplay()
        Fluent:Notify({
            Title = "Inventory Refreshed",
            Content = "Inventory display updated",
            Duration = 3
        })
    end
})

-- ========== HEALTH NPC TAB ==========
local HealthNPCTab = Tabs.HealthNPC

npcHealthDisplay = HealthNPCTab:AddParagraph({
    Title = "NPC Health Status:",
    Content = "NPC health information will appear here"
})

_G.getNPCHealthStatus = function()
    local npcStatus = {}
    
    local npcFolder = workspace:FindFirstChild("#GAME") and workspace["#GAME"]:FindFirstChild("Folders") and 
                     workspace["#GAME"].Folders:FindFirstChild("HumanoidFolder") and 
                     workspace["#GAME"].Folders.HumanoidFolder:FindFirstChild("NPCFolder")
    
    if npcFolder then
        for _, npc in ipairs(npcFolder:GetChildren()) do
            if npc:IsA("Model") then
                local humanoid = npc:FindFirstChildOfClass("Humanoid")
                if humanoid and humanoid.Health > 0 then
                    local currentHealth = math.floor(humanoid.Health)
                    local maxHealth = math.floor(humanoid.MaxHealth)
                    table.insert(npcStatus, npc.Name .. " = (" .. currentHealth .. "/" .. maxHealth .. ")")
                end
            end
        end
    end
    
    return npcStatus
end

_G.updateNPCHealthDisplay = function()
    local npcStatus = _G.getNPCHealthStatus()
    local displayText = ""
    
    if #npcStatus > 0 then
        for i, status in ipairs(npcStatus) do
            displayText = displayText .. status
            if i < #npcStatus then
                displayText = displayText .. "\n"
            end
        end
    else
        displayText = "No NPCs found or no humanoids detected"
    end
    
    -- Safe update with error handling
    local success, err = pcall(function()
        npcHealthDisplay:SetDesc(displayText)
    end)
    
    if not success then
        warn("Failed to update NPC health display: " .. tostring(err))
    end
end

HealthNPCTab:AddButton({
    Title = "Update NPC Health Status",
    Description = "Refresh NPC health information",
    Callback = function()
        _G.updateNPCHealthDisplay()  -- Call via _G
        Fluent:Notify({
            Title = "NPC Health Updated",
            Content = "NPC health information refreshed",
            Duration = 3
        })
    end
})

_G.autoNPCHealth = false
_G.autoNPCHealthConnection = nil

HealthNPCTab:AddToggle("AutoNPCHealthToggle", {
    Title = "Auto Update NPC Health",
    Description = "Automatically update NPC health",
    Default = false,
    Callback = function(Value)
        _G.autoNPCHealth = Value
        
        if Value then
            -- Stop any existing connection first
            if _G.autoNPCHealthConnection then
                _G.autoNPCHealthConnection:Disconnect()
                _G.autoNPCHealthConnection = nil
            end
            
            -- Start auto-update in a separate thread
            _G.autoNPCHealthConnection = RunService.Heartbeat:Connect(function()
                if not _G.autoNPCHealth then 
                    if _G.autoNPCHealthConnection then
                        _G.autoNPCHealthConnection:Disconnect()
                        _G.autoNPCHealthConnection = nil
                    end
                    return 
                end
                
                _G.updateNPCHealthDisplay()
                task.wait(0.5)  -- Reduced frequency to prevent lag
            end)
            
            Fluent:Notify({
                Title = "Auto NPC Health",
                Content = "Auto NPC health updates enabled",
                Duration = 3
            })
        else
            if _G.autoNPCHealthConnection then
                _G.autoNPCHealthConnection:Disconnect()
                _G.autoNPCHealthConnection = nil
            end
            Fluent:Notify({
                Title = "Auto NPC Health",
                Content = "Auto NPC health updates disabled",
                Duration = 3
            })
        end
    end
})

-- Add a manual refresh button as backup
HealthNPCTab:AddButton({
    Title = "Force Refresh NPC Health",
    Description = "Immediately refresh NPC health display",
    Callback = function()
        _G.updateNPCHealthDisplay()
        Fluent:Notify({
            Title = "NPC Health",
            Content = "NPC health display force refreshed",
            Duration = 3
        })
    end
})

-- ========== VULNERABILITY TAB ==========
local VulnerabilityTab = Tabs.Vulnerability

-- Use _G to avoid local register limits completely
_G.FluentHub = {
    -- Tab references
    Tabs = {
        Vulnerability = Tabs.Vulnerability,
        Changelogs = Tabs.Changelogs,
        Credits = Tabs.Credits,
        Settings = Tabs.Settings
    },

    -- Pet clicker data
    PetData = {
        names = {"Turkey Pet", "Chicken Noob Pet", "Corrupted Black Hole Pet", "Pouwk", "BULLkiePouwk", "Sjebullepouwker", "BULL"},
        selected = "",
        clicking = false,
        connection = nil,
        toggle = nil
    },
    
    -- Changelog data
    ChangelogData = {
        logs = {
            {
                version = "V. 2.2.0",
                changes = "[x] Fixed Auto Eat Toggle (Shouldnt Freeze/Crash Roblox)..."
            },
            {
                version = "V. 2.1.6", 
                changes = "[x] Changed Webhook Image (Now Thumbnail Is Normal)..."
            }
        }
    },

    -- Credit buttons data
    CreditButtons = {
        {
            title = "Scripter (Youtube)",
            desc = "Copy YouTube link",
            clipboard = "https://www.youtube.com/@Scripter-Coder",
            notify = "YouTube link copied to clipboard"
        },
        {
            title = "Scripter (Discord)",
            desc = "Copy Discord link",
            clipboard = "https://discord.gg/k8vJHZM6",
            notify = "Discord link copied to clipboard"
        },
        {
            title = "ZScriptX (Discord)",
            desc = "Copy ZScriptX Discord link",
            clipboard = "https://discord.gg/HvevRJVWWm",
            notify = "ZScriptX Discord link copied to clipboard"
        }
    },
    
    -- Server buttons data
    ServerButtons = {
        {
            title = "Rejoin",
            desc = "Rejoin the current server",
            callback = function()
                TeleportService:TeleportToPlaceInstance(game.PlaceId, game.JobId, game.Players.LocalPlayer)
            end
        },
        {
            title = "ServerHop (Regular Server)",
            desc = "Hop to a different server",
            callback = function()
                -- Server hop implementation
            end
        },
        {
            title = "ServerHop (Small Server)",
            desc = "Hop to a smaller server", 
            callback = function()
                -- Small server hop implementation
            end
        },
        {
            title = "Reset Player",
            desc = "Reset your character",
            callback = function()
                local character = game.Players.LocalPlayer.Character
                if character then
                    local humanoid = character:FindFirstChildOfClass("Humanoid")
                    if humanoid then
                        humanoid.Health = 0
                        Fluent:Notify({Title = "Player Reset", Content = "Character has been reset", Duration = 3})
                    end
                end
            end
        }
    },
    
    -- Anti system data
    AntiData = {
        sitEnabled = false,
        kickEnabled = false,
        kickConnection = nil
    }
}

_G.setclipboard = function(text)
    pcall(function()
        if setclipboard then
            setclipboard(text)
        elseif writeclipboard then
            writeclipboard(text)
        elseif syn and syn.write_clipboard then
            syn.write_clipboard(text)
        end
    end)
end

-- ========== PET CLICKER ==========
_G.FluentHub.Tabs.Vulnerability:AddParagraph({Title = "Pet Clicker", Content = ""})

-- Pet dropdown
_G.FluentHub.Tabs.Vulnerability:AddDropdown("PetSelectDropdown", {
    Title = "Select Pet",
    Description = "Choose pet to auto click",
    Values = _G.FluentHub.PetData.names,
    Default = "",
    Multi = false,
    Callback = function(Value)
        _G.FluentHub.PetData.selected = Value
        if _G.FluentHub.PetData.clicking and _G.FluentHub.PetData.connection then
            _G.FluentHub.PetData.connection:Disconnect()
            _G.FluentHub.PetData.connection = nil
            _G.FluentHub.PetData.clicking = false
            if _G.FluentHub.PetData.toggle then
                _G.FluentHub.PetData.toggle:SetValue(false)
            end
        end
    end
})

-- Pet toggle
_G.FluentHub.PetData.toggle = _G.FluentHub.Tabs.Vulnerability:AddToggle("AutoClickPetToggle", {
    Title = "Auto Click Pet",
    Description = "Automatically click selected pet",
    Default = false,
    Callback = function(Value)
        if Value and _G.FluentHub.PetData.selected == "" then
            Fluent:Notify({Title = "Error", Content = "Please select a pet first!", Duration = 3})
            _G.FluentHub.PetData.toggle:SetValue(false)
            return
        end
        
        if _G.FluentHub.PetData.connection then
            _G.FluentHub.PetData.connection:Disconnect()
            _G.FluentHub.PetData.connection = nil
        end
        
        _G.FluentHub.PetData.clicking = Value
        
        if Value then
            _G.FluentHub.PetData.connection = RunService.Heartbeat:Connect(function()
                if not _G.FluentHub.PetData.clicking then 
                    if _G.FluentHub.PetData.connection then
                        _G.FluentHub.PetData.connection:Disconnect()
                        _G.FluentHub.PetData.connection = nil
                    end
                    return 
                end
                
                pcall(function()
                    local player = game.Players.LocalPlayer
                    local petFolder = workspace:WaitForChild("#GAME"):WaitForChild("Folders"):WaitForChild("HumanoidFolder"):WaitForChild("NPCFolder"):WaitForChild("PetFolder")
                    local petName = player.DisplayName .. "'s " .. _G.FluentHub.PetData.selected
                    local petModel = petFolder:FindFirstChild(petName)
                    if petModel then
                        local clickDetector = petModel:FindFirstChildOfClass("ClickDetector")
                        if clickDetector then
                            fireclickdetector(clickDetector)
                        end
                    end
                end)
            end)
            Fluent:Notify({Title = "Auto Click Pet", Content = "Auto clicking " .. _G.FluentHub.PetData.selected, Duration = 3})
        else
            Fluent:Notify({Title = "Auto Click Pet", Content = "Auto click pet disabled", Duration = 3})
        end
    end
})

-- ========== SECRET PRICES ==========
VulnerabilityTab:AddParagraph({
    Title = "Price Shower",
    Content = ""
})

-- Local function to create price shower buttons
_G.createPriceShowerButtons = function(tab)
    local priceData = {
        {name = "Bob Pet", price = "14703 Cookies"},
        {name = "UZYeah Gun", price = "0 Coins (Only if u tester/dev)"},
        {name = "Smiley Sucker Gun", price = "0 Coins (Only if u tester/dev)"},
        {name = "Revolvahhh Gun", price = "0 Coins (Only if u tester/dev)"},
        {name = "Easter Egg Pet", price = "-1 Coins"},
        {name = "Black Bas Pet", price = "Check attribute"},
        {name = "Clown Mouse Pet", price = "0 Coins (Need Aniversary 2024 - Secret Badge)"},
        {name = "Pouwk Pet", price = "0 Coins (Need Meet the Co-Owner Badge)"},
        {name = "SGobbler Pet", price = "0 Coins (Need Like Game + Join Group)"},
        {name = "Easter Doggo Pet", price = "0 Coins (Need Easter 2024 - Egg-Gathering Gladiator Badge)"},
        {name = "Scammer Pet", price = "0 Coins (Only if u tester/dev)"},
        {name = "BULLkiePouwk Pet", price = "0 Coins (Need Secret Badge Valentines 2024)"},
        {name = "Cracked Bas Pet", price = "0 Coins (Need Secret Badge 1)"},
        {name = "Sjebullepouwker Pet", price = "0 Coins (Need Secret Badge Valentines 2025)"},
        {name = "BULL Pet", price = "0 Coins (Need Meet the Owner Badge)"},
        {name = "Exclusive 100k Pet", price = "100k Coins/Bites (Need Be First Player To Obtain)"},
        {name = "CRACKED Mode Item", price = "0 Coins (Need Super Secret Badge 1)"},
        {name = "Bunny Ears Item", price = "0 Coins (Need Hatched Badge)"},
        {name = "Eggstinction Rush X Item", price = "0 Coins (Need Easter 2025 - Path to Eggstinction Badge)"},
        {name = "Hatred Item", price = "0 Coins (Need Secret Badge 2)"}
    }

    for _, buttonInfo in ipairs(priceData) do
        tab:AddButton({
            Title = "Check " .. buttonInfo.name .. " Costing Price",
            Description = "View the price information",
            Callback = function()
                Fluent:Notify({
                    Title = buttonInfo.name .. " Cost Found",
                    Content = buttonInfo.name .. " Cost is: " .. buttonInfo.price,
                    Duration = 5
                })
            end
        })
    end
end

-- ACTUALLY CALL THE FUNCTION TO CREATE THE BUTTONS
_G.createPriceShowerButtons(VulnerabilityTab)

-- ========== CHANGELOGS ==========
_G.FluentHub.Tabs.Changelogs:AddParagraph({Title = "Changelogs Info", Content = ""})

_G.FluentHub.Tabs.Changelogs:AddParagraph({
    Title = "V. 2.3.3",
    Content = [[
[x] Fixed Check Type Server Button (Now Tells U What Type Server U Are In)
[x] Improved Auto Eat Toggles (Now Does Faster)
[x] Fixed Auto Eat (Smart) Toggle (Now Goes From Amethyst-Rock And Rest If Not Find Any Type)
[x] Improved Auto Shoot Toggle (Now Does Faster)
[x] Improved Auto Teleport To Eggs Toggle (Now Does/Detects Faster And Doesnt Auto Stop When Toggle On)
[-] Removed Auto Collect Eggs Toggle (it doesnt work at all + not need)
[+] Added Auto Notify Spawned Egg Toggle (Sends U Auto Notification Which Egg Spawned)
[+] Added Check For Existing Egg Button
[+] Added Clear Egg Detection History
[+] Added Secret Badge 1 Section
[+] Added Auto Shoo Stuff To It (Only Shoots Normal Bas)
[+] Added Teleport To Room Button
[+] Added Teleport To WhiteBas Button (He Has To Kill U For SB1 Badge)
[+] Added Auto Shoo Stuff To It (Only Shoots Normal Bas/Cracked Bas)
[-] Removed Auto Close Door Toggle
[+] Added Teleport To Hatred Button
[x] Fixed Anti Void Button

Settings:
[+] = Added
[x] = Fixed/Changed
[-] = Removed
]]
})

_G.FluentHub.Tabs.Changelogs:AddParagraph({
    Title = "V. 2.2.0",
    Content = [[
[x] Fixed Auto Eat Toggle (Shouldnt Freeze/Crash Roblox)
[x] Fixed Auto Shoot Toggle (Shouldnt Freeze/Crash Roblox)
[x] Fixed Auto Eggs Toggle (Shouldnt Freeze/Crash Roblox + No More Lags)
[+] Added Auto Spam ProximityPrompt (Spams Clicks Prompt [Its very useful to use on eggs auto click])
[x] Fixed Anti Void Button
[x] Fixed Anti Sit Toggle (Now Disables/Enables All Sits)
[-] Removed Auto Join To Bull's Server
[-] Removed Auto Join To Pouwk's Server

Settings:
[+] = Added
[x] = Fixed/Changed
[-] = Removed
]]
})

_G.FluentHub.Tabs.Changelogs:AddParagraph({
    Title = "V. 2.1.6",
    Content = [[
[x] Changed Webhook Image (Now Thumbnail Is Normal)
[+] Added Paragraph Of Text "Attention U Can Get Banned If Doing On Public Reccomended On Private Server"
[+] Added Check Type Server Button (Sends Notification If Public Or Private Server)
[-] Removed Remove ProximityPrompt From Shop Button
[+] Added Others Section To Info Tab
[+] Added Insaenity Lvl Info
[+] Added BOSS Noob in Info
[+] Added House 1 Kllls Info
[+] Added House 2 Kllls Info
[+] Added House 3 Kllls Info
[+] Added House 4 Kllls Info
[+] Added House 5 Kllls Info
[x] Fixed Auto Set Info Toggle
[x] Changed All Auto Eat Toggles (Now They Auto Click [Screen] Too)
[+] Added Auto Eat (Dead Noobs Only) Toggle
[x] Fixed Auto Shoot Stuff
- Now The Eggsterminator Auto Equips
- Works Without Auto Breaking Randomly
[-] Removed Auto Click (0.01 Speed Click) Toggle [Useless cuz alr exists on auto eat toggles]
[x] Improved Auto Set Instant CD To Eggs (0.3 Sec CD) Toggle [Can still lag but not much]
[x] Improved Auto Collect Eggs Toggle [Can maybe still lag but not much]
[+] Added View WhiteBas Button
[+] Added Unview WhiteBas Button
[+] Added Auto Close Door Toggle
[x] FULLY Improved All ESP Toggles (No More Lag + Shows Highlight)
[+] Added Scripts Tab
[+] Added SAEN Script Button (ZScriptX)
[+] Added Copy Key For SAEN Script (ZScriptX)
[+] Added Inventory Tab
[+] Added Select Player Dropdown
[+] Added Update Player List Button
[+] Added "Inventory Items:", "Select a player to view their inventory" Paragraph
[+] Added Auto Set Info Toggle
[+] Added NPC Health Status Paragraph
[+] Added Auto Update NPC Status Toggle
[+] Added Update NPC Health Status Button
[x] Fixed Auto Click Pet/s Toggle (No More Shows Stop Notification Randomly)
[+] Added ZScriptX To Credits Tab
[+] Added Anti Void Button
[+] Added Anti Sit Toggle (no more get stuck)
[+] Added Anti Contributor | Owner Toggle (kicks you if finds high player rank)

Settings:
[+] = Added
[x] = Fixed/Changed
[-] = Removed
]]
})

_G.FluentHub.Tabs.Changelogs:AddParagraph({
    Title = "V. 1.7.9",
    Content = [[
[+] Added Remove Shop Proximity Prompt (So Wont Auto Open Shop Everytime U AFK Farm Eggs)
[+] Added The Eggsterminator Tool To Support On Auto Shoot Toggle
[x] Fixed Auto Shoot Toggle (Now Doesn't Stops If Toggle Still Enabled)
[x] Fixed Noobs/Werewolfs/ETC... ESP Toggle
[+] Added Pet Clicker Section
[+] Added Select Pet Dropdown
[+] Added Auto Click Pet
[+] Added Check Bob Pet Costing Price Button
[+] Added Check UZYeah Gun Costing Price Button
[+] Added Check Smiley Sucker Gun Costing Price Button
[+] Added Check Revolvahhh Gun Costing Price Button
[+] Added Check Easter Egg Pet Costing Price Button
[+] Added Check Clown Mouse Pet Costing Price Button
[+] Added Check Pouwk Pet Costing Price Button
[+] Added Check SGobbler Pet Costing Price Button
[+] Added Check Easter Doggo Pet Costing Price Button
[+] Added Check Scammer Pet Costing Price Button
[+] Added Check BULLkiePouwk Pet Costing Price Button
[+] Added Check Cracked Bas Pet Costing Price Button
[+] Added Check Sjebullepouwker Pet Costing Price Button
[+] Added Check BULL Pet Costing Price Button
[+] Added Check Exclusive 100k Pet Costing Price Button
[+] Added Check CRACKED Mode Item Costing Price Button
[+] Added Check Bunny Ears Item Costing Price Button
[+] Added Check Eggstinction Rush X Item Costing Price Button
[+] Added Check Hatred Item Costing Price Button

Settings:
[+] = Added
[x] = Fixed/Changed
[-] = Removed
]]
})

_G.FluentHub.Tabs.Changelogs:AddParagraph({
    Title = "V. 1.4.7",
    Content = [[
[x] Changed Webhook Image (Now Thumbnail Is Halloween)
[x] Improved Anti Cheat Button (Bypasses 3 More Anti Cheats)
[x] Fully Changed Sections In Main Tab
[x] Changed From "Auto Eat (For Positive/Stink Coins)" to "Auto Eat (For All Type Coins) Toggle
[+] Added Auto Eat (Smart From Value High To Low) Toggle
[+] Added Choose Coin Type To Auto Eat Dropdown
List Are: Positive Coins, Stink Coins, Cookies and King Coins
[+] Added Auto Eat (Choosed Type) Toggle
[x] Improved Auto Shoot Toggle (Supports More Guns Now)
[x] Improved Again Auto Shoot Toggle (For TMG V2, SMOGGTTLTSG It Holds)
[x] IMPROVED LAST TIME AGAIN AUTO SHOOT TOGGLE (Doesnt shoot Bas [From Chair], Dead and Invincible)
[x] Improved Auto Use Sword Toggle (Now Supports All Swords)
[-] Removed Auto Bring/Collect Eggs Toggle (It just doesnt collect at this point)
[-] Removed Auto Bring/Collect Presents Toggle (It just doesnt collect at this point)
[x] Changed From "SSB1/SB2 Badges" To "Badges" Tab
[+] Added Auto Notify Heads Spawn Toggle
[x] Fixed Noobs/Werewolfs/ETC... ESP Toggle (Showed 2 Names + Very Laggy Was)
[+] Added Anti Settings Section In Settings Tab
[+] Added Anti Kick Toggle
[+] Added Auto Join To Bull's Server Toggle
[+] Added Auto Join To Pouwk's Server Toggle

Settings:
[+] = Added
[x] = Fixed/Changed
[-] = Removed
]]
})

_G.FluentHub.Tabs.Changelogs:AddParagraph({
    Title = "V. 1.3.0",
    Content = [[
[+] Added Bypass Mountain Anti Cheat (Prevent Crashing Roblox I Guess...) Button
[+] Added Dead Noob Type To Auto Eat (For Positive/Stink Coins) Toggle
[x] Improved Auto Bring Noobs/Werewolves Toggle (Brings Even If U Respawn)
[x] Improved Auto Bring/Collect Eggs Toggle (Brings Even If U Respawn)
[+] Added Auto Teleport To Eggs Toggle (Other Way Collecting Eggs)
[+] Added Auto Spam ProximityPrompts Toggle
[x] Fixed Eggs ESP Toggle
[x] FULLY Improved Shop Tab
[+] Added Secret Prices Shower Section

Settings:
[+] = Added
[x] = Fixed/Changed
[-] = Removed
]]
})

_G.FluentHub.Tabs.Changelogs:AddParagraph({
    Title = "V. 1.2.1",
    Content = [[
[x] Changed Webhook Script Messager Sender Info (Now Shows Image)
[x] Improved Auto Eat Toggle (Positive) (Now It Doesnt Eat Negative Type Noobs)
[-] Removed Auto Eat Toggle (Negative) (They Changed Negative To Stink Coins)
[-] Removed Auto Shoot Gui Button (Dont really need it)
[+] Added Gun Name Textbox (Example Minigun)
[+] Added Shooting Speed Textbox (Example 6)
[+] Added Auto Shoot Toggle (Auto Shoots Can Be Stopped)
[x] Improved Auto Bring Noobs/Werewolfs Toggle (Now a bit further and infront)
[-] Removed Auto Set PP To 0 CD Button (Very Much Lags)
[+] Added Auto Set PP To 0 CD Toggle (For Instant Collecting Eggs)
[+] Added Auto Bring/Collect Eggs Toggle (Useful If Giant Egg Drops Then U Instant Collect It)
[+] Added Auto Bring/Collect Presents Toggle (Useful If Present Drops Then U Can Auto Collect It)
[-] Removed Auto Teleport To Eggs Toggle (Very Easy It Makes U To Teleport To Mountain Where U Get Crashed)
[x] Changed Collect All Bacon Parts Button (Now Its In Badges SB2 Section)
[+] Added Enable/Disable Fire Button (For SB2)
[+] Added Equip All Bacon Parts [Stand Close To Fire] (Equips All 6 Parts Also Tells If Missing Or Success)
[+] Added ESP Tab
[+] Added Players ESP Toggle
[+] Added Noobs/Werewolfs/ETC... ESP Toggle
[+] Added Bacon Parts ESP Toggle
[+] Added Eggs ESP Toggle
[+] Added Presents ESP Toggle
[+] Added Souls ESP Toggle
[+] Added Vunerability Tab
[+] Added Check Black Bas Costing Price Button

Settings:
[+] = Added
[x] = Fixed/Changed
[-] = Removed
]]
})

_G.FluentHub.Tabs.Changelogs:AddParagraph({
    Title = "V. 1.0.0",
    Content = [[
[+] SCRIPT RELEASED

Settings:
[+] = Added
[x] = Fixed/Changed
[-] = Removed
]]
})

-- ========== CREDITS ==========
local CreditsTab = Tabs.Credits

Tabs.Credits:AddParagraph({Title = "Credits Users", Content = ""})
Tabs.Credits:AddParagraph({Title = "Scripter - (Youtube, Discord)", Content = ""})
Tabs.Credits:AddParagraph({Title = "ZScriptX - Discord", Content = ""})
Tabs.Credits:AddParagraph({Title = "Helpers", Content = ""})
Tabs.Credits:AddParagraph({Title = "ZScriptX - Auto Shoot", Content = ""})
Tabs.Credits:AddParagraph({Title = "Links", Content = ""})

-- Local function to create credit buttons
_G.createCreditButtons = function(tab)
    -- Check if tab exists before trying to add buttons
    if not tab then
        warn("CreditButtons: Tab is nil, cannot create buttons")
        return
    end
    
    local creditButtons = {
        {
            title = "Scripter (Youtube)",
            desc = "Copy YouTube link",
            clipboard = "https://www.youtube.com/@Scripter-Coder",
            notify = "YouTube link copied to clipboard"
        },
        {
            title = "Scripter (Discord)",
            desc = "Copy Discord link",
            clipboard = "https://discord.gg/k8vJHZM6",
            notify = "Discord link copied to clipboard"
        },
        {
            title = "ZScriptX (Discord)",
            desc = "Copy ZScriptX Discord link",
            clipboard = "https://discord.gg/HvevRJVWWm",
            notify = "ZScriptX Discord link copied to clipboard"
        }
    }

    for index, buttonData in ipairs(creditButtons) do
        tab:AddButton({
            Title = buttonData.title,
            Description = buttonData.desc,
            Callback = function()
                setclipboard(buttonData.clipboard)
                Fluent:Notify({Title = "Link Copied", Content = buttonData.notify, Duration = 3})
            end
        })
    end
end

-- Only call the function if CreditsTab exists
if CreditsTab then
    _G.createCreditButtons(CreditsTab)
else
    warn("CreditsTab is nil, cannot create credit buttons")
end

-- ========== SETTINGS ==========
_G.FluentHub.Tabs.Settings:AddParagraph({Title = "Anti Settings", Content = ""})

local TeleportService = game:GetService("TeleportService")

-- Anti Void
_G.FluentHub.Tabs.Settings:AddButton({
    Title = "Anti Void",
    Description = "Create anti-void platform",
    Callback = function()
        -- ANTI VOID --
        if workspace:FindFirstChild("AntiVoid1") == nil then
            -- Create 10 longer layers of protection
            local sizes = {
                Vector3.new(500, 2, 500),    -- Layer 1
                Vector3.new(600, 2, 600),    -- Layer 2  
                Vector3.new(700, 2, 700),    -- Layer 3
                Vector3.new(800, 2, 800),    -- Layer 4
                Vector3.new(900, 2, 900),    -- Layer 5
                Vector3.new(1000, 2, 1000),  -- Layer 6
                Vector3.new(1100, 2, 1100),  -- Layer 7
                Vector3.new(1200, 2, 1200),  -- Layer 8
                Vector3.new(1300, 2, 1300),  -- Layer 9
                Vector3.new(1400, 2, 1400)   -- Layer 10
            }
            
            local positions = {
                Vector3.new(0, -20, 0),   -- Layer 1
                Vector3.new(0, -25, 0),   -- Layer 2
                Vector3.new(0, -30, 0),   -- Layer 3
                Vector3.new(0, -35, 0),   -- Layer 4
                Vector3.new(0, -40, 0),   -- Layer 5
                Vector3.new(0, -45, 0),   -- Layer 6
                Vector3.new(0, -50, 0),   -- Layer 7
                Vector3.new(0, -55, 0),   -- Layer 8
                Vector3.new(0, -60, 0),   -- Layer 9
                Vector3.new(0, -65, 0)    -- Layer 10
            }
            
            local colors = {
                BrickColor.new("Bright blue"),
                BrickColor.new("Bright blue"),
                BrickColor.new("Bright blue"),
                BrickColor.new("Bright blue"),
                BrickColor.new("Bright blue"),
                BrickColor.new("Bright blue"),
                BrickColor.new("Bright blue"),
                BrickColor.new("Bright blue"),
                BrickColor.new("Bright blue"),
                BrickColor.new("Bright blue")
            }
            
            for i = 1, 10 do
                local AntiVoid = Instance.new("Part", workspace)
                AntiVoid.Name = "AntiVoid" .. i
                AntiVoid.Position = positions[i]
                AntiVoid.Size = sizes[i]
                AntiVoid.Anchored = true
                AntiVoid.CanCollide = true
                AntiVoid.Transparency = 0.8 -- Slightly less transparent for better visibility
                AntiVoid.Material = Enum.Material.Neon
                AntiVoid.BrickColor = colors[i]
                
                -- Add a slight glow effect
                local SurfaceLight = Instance.new("SurfaceLight", AntiVoid)
                SurfaceLight.Brightness = 0.5
                SurfaceLight.Face = Enum.NormalId.Top
                SurfaceLight.Range = 10
                SurfaceLight.Color = Color3.new(0, 0.5, 1)
            end
            
            Fluent:Notify({Title = "Success", Content = "Anti-void created successfully!", Duration = 3})
        else
            -- Remove all anti-void parts
            local removedCount = 0
            for _, part in pairs(workspace:GetChildren()) do
                if string.find(part.Name, "AntiVoid") then
                    part:Destroy()
                    removedCount = removedCount + 1
                end
            end
            Fluent:Notify({Title = "Success", Content = "Anti-void removed successfully!", Duration = 3})
        end
    end
})

-- Anti Sit - FIXED SYNTAX
Tabs.Settings:AddToggle("AntiSitToggle", {
    Title = "Anti Sit",
    Description = "Prevent sitting in vehicles", 
    Default = false,
    Callback = function(Value)
        for _, seat in pairs(workspace:GetDescendants()) do
            if seat:IsA("VehicleSeat") or seat:IsA("Seat") then
                seat.CanTouch = not Value
            end
        end
        if Value then
            Fluent:Notify({
                Title = "Anti Sit", 
                Content = "All seats disabled",
                Duration = 3
            })
        else
            Fluent:Notify({
                Title = "Anti Sit",
                Content = "All seats enabled", 
                Duration = 3
            })
        end
    end
})

-- Anti AFK
_G.FluentHub.Tabs.Settings:AddToggle("AntiAFKToggle", {
    Title = "Anti Afk",
    Description = "Prevent being kicked for AFK",
    Default = false,
    Callback = function(Value)
        if Value then
            local VirtualUser = game:GetService('VirtualUser')
            game:GetService('Players').LocalPlayer.Idled:Connect(function()
                VirtualUser:CaptureController()
                VirtualUser:ClickButton2(Vector2.new())
            end)
            Fluent:Notify({Title = "Anti AFK", Content = "Anti AFK enabled", Duration = 3})
        else
            Fluent:Notify({Title = "Anti AFK", Content = "Anti AFK disabled", Duration = 3})
        end
    end
})

-- Anti Kick
_G.FluentHub.Tabs.Settings:AddToggle("AntiKickToggle", {
    Title = "Anti Kick",
    Description = "Prevent being kicked from game",
    Default = false,
    Callback = function(Value)
        if Value then
            local connection = RunService.Heartbeat:Connect(function()
                for i,v in pairs(game.CoreGui.RobloxPromptGui.promptOverlay:GetDescendants()) do
                    if v.Name == "ErrorPrompt" then
                        TeleportService:TeleportToPlaceInstance(game.PlaceId, game.JobId, game.Players.LocalPlayer)
                    end
                end
            end)
            Fluent:Notify({Title = "Anti Kick", Content = "Anti kick enabled", Duration = 3})
        else
            Fluent:Notify({Title = "Anti Kick", Content = "Anti kick disabled", Duration = 3})
        end
    end
})

_G.FluentHub.Tabs.Settings:AddParagraph({Title = "Server Settings", Content = ""})

-- Add server buttons directly (since _G.FluentHub.ServerButtons might be missing)
_G.FluentHub.Tabs.Settings:AddButton({
    Title = "Rejoin",
    Description = "Rejoin the current server",
    Callback = function()
        TeleportService:TeleportToPlaceInstance(game.PlaceId, game.JobId, game.Players.LocalPlayer)
    end
})

_G.FluentHub.Tabs.Settings:AddButton({
    Title = "ServerHop (Regular Server)",
    Description = "Hop to a different server",
    Callback = function()
        local PlaceID = game.PlaceId
        local AllIDs = {}
        local foundAnything = ""
        local actualHour = os.date("!*t").hour
        
        function TPReturner()
            local Site;
            if foundAnything == "" then
                Site = game.HttpService:JSONDecode(game:HttpGet('https://games.roblox.com/v1/games/' .. PlaceID .. '/servers/Public?sortOrder=Asc&limit=100'))
            else
                Site = game.HttpService:JSONDecode(game:HttpGet('https://games.roblox.com/v1/games/' .. PlaceID .. '/servers/Public?sortOrder=Asc&limit=100&cursor=' .. foundAnything))
            end
            local ID = ""
            if Site.nextPageCursor and Site.nextPageCursor ~= "null" and Site.nextPageCursor ~= nil then
                foundAnything = Site.nextPageCursor
            end
            local num = 0;
            for i,v in pairs(Site.data) do
                local Possible = true
                ID = tostring(v.id)
                if tonumber(v.maxPlayers) > tonumber(v.playing) then
                    for _,Existing in pairs(AllIDs) do
                        if num ~= 0 then
                            if ID == tostring(Existing) then
                                Possible = false
                            end
                        else
                            if tonumber(actualHour) ~= tonumber(Existing) then
                                local delFile = pcall(function()
                                    AllIDs = {}
                                    table.insert(AllIDs, actualHour)
                                end)
                            end
                        end
                        num = num + 1
                    end
                    if Possible == true then
                        table.insert(AllIDs, ID)
                        wait()
                        pcall(function()
                            wait()
                            game:GetService("TeleportService"):TeleportToPlaceInstance(PlaceID, ID, game.Players.LocalPlayer)
                        end)
                        wait(4)
                    end
                end
            end
        end
        
        function Teleport()
            while wait() do
                pcall(function()
                    TPReturner()
                    if foundAnything ~= "" then
                        TPReturner()
                    end
                end)
            end
        end
        
        Teleport()
    end
})

_G.FluentHub.Tabs.Settings:AddButton({
    Title = "ServerHop (Small Server)",
    Description = "Hop to a smaller server",
    Callback = function()
        local Http = game:GetService("HttpService")
        local TPS = game:GetService("TeleportService")
        local Api = "https://games.roblox.com/v1/games/"

        local _place = game.PlaceId
        local _servers = Api.._place.."/servers/Public?sortOrder=Asc&limit=100"
        function ListServers(cursor)
           local Raw = game:HttpGet(_servers .. ((cursor and "&cursor="..cursor) or ""))
           return Http:JSONDecode(Raw)
        end

        local Server, Next; repeat
           local Servers = ListServers(Next)
           Server = Servers.data[1]
           Next = Servers.nextPageCursor
        until Server

        TPS:TeleportToPlaceInstance(_place,Server.id,game:GetService('Players').LocalPlayer)
    end
})

_G.FluentHub.Tabs.Settings:AddButton({
    Title = "Reset Player",
    Description = "Reset your character",
    Callback = function()
        local character = game.Players.LocalPlayer.Character
        if character then
            local humanoid = character:FindFirstChildOfClass("Humanoid")
            if humanoid then
                humanoid.Health = 0
                Fluent:Notify({Title = "Player Reset", Content = "Character has been reset", Duration = 3})
            end
        end
    end
})

_G.FluentHub.Tabs.Settings:AddParagraph({Title = "Destroy Script", Content = ""})

_G.FluentHub.Tabs.Settings:AddButton({
    Title = "Destroy Gui",
    Description = "Close the script interface",
    Callback = function()
        Window:Destroy()
        Fluent:Notify({Title = "GUI Destroyed", Content = "Script interface has been closed", Duration = 3})
    end
})

-- Initialize
SaveManager:SetLibrary(Fluent)
InterfaceManager:SetLibrary(Fluent) 
SaveManager:IgnoreThemeSettings()
SaveManager:SetIgnoreIndexes({})
InterfaceManager:SetFolder("FluentScriptHub")
SaveManager:SetFolder("FluentScriptHub/specific-game")

-- Load the interface
SaveManager:Load()

-- Select first tab
Window:SelectTab(1)

Fluent:Notify({
    Title = "Fluent Hub Loaded",
    Content = "Welcome to " .. gameName .. " Hub!",
    Duration = 5
})

end
