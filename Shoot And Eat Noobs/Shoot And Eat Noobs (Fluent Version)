local MarketplaceService = game:GetService("MarketplaceService")
local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local RunService = game:GetService("RunService")
local Workspace = game:GetService("Workspace")
local VirtualInputManager = game:GetService("VirtualInputManager")
local TweenService = game:GetService("TweenService")

local placeInfo = MarketplaceService:GetProductInfo(game.PlaceId)
local gameName = placeInfo.Name
local localPlayer = Players.LocalPlayer

-- Import Fluent
local WebhookScripterHub = loadstring(game:HttpGet("https://raw.githubusercontent.com/Scripter-Coder/Scripter-Coder/refs/heads/main/Universal/Webhook"))()
local Fluent = loadstring(game:HttpGet("https://github.com/dawid-scripts/Fluent/releases/latest/download/main.lua"))()
local SaveManager = loadstring(game:HttpGet("https://raw.githubusercontent.com/dawid-scripts/Fluent/master/Addons/SaveManager.lua"))()
local InterfaceManager = loadstring(game:HttpGet("https://raw.githubusercontent.com/dawid-scripts/Fluent/master/Addons/InterfaceManager.lua"))()

local Window = Fluent:CreateWindow({
    Title = gameName .. " Hub (Fluent Edition) V. 3.5.7",
    SubTitle = "by Scripter",
    TabWidth = 160,
    Size = UDim2.fromOffset(580, 460),
    Acrylic = true,
    Theme = "Dark",
    MinimizeKey = Enum.KeyCode.LeftControl
})

local Tabs = {
    Welcome = Window:AddTab({ Title = "Welcome", Icon = "home" }),
    Info = Window:AddTab({ Title = "Info", Icon = "info" }),
    Main = Window:AddTab({ Title = "Main", Icon = "settings" }),
    Event = Window:AddTab({ Title = "Event", Icon = "settings" }),
    Badges = Window:AddTab({ Title = "Badges", Icon = "award" }),
    ESP = Window:AddTab({ Title = "ESP", Icon = "eye" }),
    Shop = Window:AddTab({ Title = "Shop", Icon = "shopping-cart" }),
    Scripts = Window:AddTab({ Title = "Scripts", Icon = "code" }),
    Inventory = Window:AddTab({ Title = "Inventory", Icon = "briefcase" }),
    HealthNPCs = Window:AddTab({ Title = "Health NPC's", Icon = "heart" }),
    OtherStuff = Window:AddTab({ Title = "Other Stuff", Icon = "box" }),
    Changelogs = Window:AddTab({ Title = "Changelogs", Icon = "file-text" }),
    Credits = Window:AddTab({ Title = "Credits", Icon = "users" }),
    Settings = Window:AddTab({ Title = "Settings", Icon = "settings" })
}

local Options = Fluent.Options

-- Global Variables
_G.AutoSetInfo = false
_G.AutoNPCHealth = false
_G.AutoShootEnabled = false
_G.AutoShootEnabledSecret1 = false
_G.AutoShootEnabledSuperSecret1 = false
_G.isAutoSetHoldDurationEggs = false
_G.isTeleportToEggs = false
_G.isAutoSpamKeyEggs = false
_G.isAutoSetHoldDurationPresents = false
_G.isTeleportToPresents = false
_G.isAutoSpamKeyPresents = false
_G.AutoTeleportSnowflakes = false
_G.isTeleporting = false
_G.isUsingSword = false
_G.isBringing = false
_G.autoBuyEnabled = false
_G.isAutoDeleteModels = false
_G.PlayerESP = false
_G.NPCESP = false
_G.PartESP = false
_G.EggESP = false
_G.PresentESP = false
_G.SoulESP = false
_G.SnowflakeESP = false
_G.isAntiSit = false
_G.AntiAfk = false
_G.AntiKick = false
_G.isAutoClickingPet = false
_G.selectedPet = ""
_G.spamEnabled = false
_G.modelListenerEnabled = false
_G.autoClickCorrectImageEnabled = false
_G.autoEquipEnabled = false
_G.autoClickPetEnabled = false

-- Notify user
Fluent:Notify({
    Title = "Welcome to " .. gameName,
    Content = "Good luck!",
    Duration = 3
})

-- ============================================
-- WELCOME TAB
-- ============================================
do
    local WelcomeTab = Tabs.Welcome
    
    WelcomeTab:AddParagraph({
        Title = "Hello " .. game.Players.LocalPlayer.Name .. "!",
        Content = "Welcome to the Fluent Edition of " .. gameName .. " Hub"
    })
    
    WelcomeTab:AddButton({
        Title = "Bypass Anti Cheat",
        Description = "Prevent crashing Roblox",
        Callback = function()
            workspace["#GAME"].Map._Other.MountainWedge:destroy()
            workspace["#GAME"].Map._Other["Touch/TargetParts"].MountainPart:destroy()
            workspace["#GAME"].Map._Other.Mountain:destroy()
            game:GetService("ReplicatedStorage")["#GAME"]._Storage.Events.AntiSpeed:destroy()
            workspace["#GAME"].Map._Other.BOEL:destroy()
            workspace["#GAME"].Map._Other.Water:destroy()
            Fluent:Notify({
                Title = "Bypassed",
                Content = "Total Bypassed: 6 Anti Cheats",
                Duration = 3
            })
        end
    })
    
    WelcomeTab:AddParagraph({
        Title = "Note:",
        Content = "Use in private server if you don't want to get caught and banned!"
    })
    
    WelcomeTab:AddButton({
        Title = "Check Server Type",
        Description = "Detect if you're in public or private server",
        Callback = function()
            local function detectServerType()
                
                -- Main method: Check PrivateServerOwner attribute
                local privateServerOwner = workspace:GetAttribute("PrivateServerOwner")
                local localPlayer = game:GetService("Players").LocalPlayer
                local localUserId = localPlayer.UserId
                
                print("PrivateServerOwner attribute:", privateServerOwner)
                print("Your UserId:", localUserId)
                
                if privateServerOwner == nil then
                    return "Unknown (Attribute not found)"
                    
                elseif privateServerOwner == 0 then
                    return "Public Server"
                    
                elseif privateServerOwner == localUserId then
                    return "Private Server (You own it)"
                    
                elseif privateServerOwner > 0 and privateServerOwner ~= localUserId then
                    -- Optional: Try to get the owner's username
                    local ownerName = "Unknown Player"
                    pcall(function()
                        local playerService = game:GetService("Players")
                        ownerName = playerService:GetNameFromUserIdAsync(privateServerOwner)
                    end)
                    return "VIP Server (Owned by: " .. ownerName .. ")"
                    
                else
                    return "Unknown Server Type"
                end
            end
            
            -- Run detection
            local serverType = detectServerType()
            
            -- Create notification
            Fluent:Notify({
                Title = "Server Type",
                Content = serverType,
                Duration = 5
            })
            
            -- Optional: Display additional info in notification if you want
            local localPlayer = game:GetService("Players").LocalPlayer
            local privateServerOwner = workspace:GetAttribute("PrivateServerOwner")
            
            if privateServerOwner and privateServerOwner > 0 and privateServerOwner ~= localPlayer.UserId then
                pcall(function()
                    local ownerName = game:GetService("Players"):GetNameFromUserIdAsync(privateServerOwner)
                    Fluent:Notify({
                        Title = "Server Owner Info",
                        Content = "Owner: " .. ownerName .. " (ID: " .. privateServerOwner .. ")",
                        Duration = 5
                    })
                end)
            end
        end
    })
end

-- ============================================
-- INFO TAB
-- ============================================
do
    local InfoTab = Tabs.Info
    local player = game.Players.LocalPlayer
    
    -- Currency/Leaderstats Section
    InfoTab:AddParagraph({
        Title = "Currency/Leaderstats",
        Content = ""
    })
    
    local coinsLabel = InfoTab:AddParagraph({
        Title = "Coins",
        Content = "Loading..."
    })
    
    local bitesLabel = InfoTab:AddParagraph({
        Title = "Bites",
        Content = "Loading..."
    })
    
    -- Others Section
    InfoTab:AddParagraph({
        Title = "Others",
        Content = ""
    })
    
    local insaenityLabel = InfoTab:AddParagraph({
        Title = "Insaenity Level",
        Content = "Loading..."
    })
    
    local bossTimerLabel = InfoTab:AddParagraph({
        Title = "BOSS Noob Timer",
        Content = "Loading..."
    })
    
    local houseKillsLabels = {}
    for i = 1, 5 do
        houseKillsLabels[i] = InfoTab:AddParagraph({
            Title = "House " .. i .. " Kills",
            Content = "Loading..."
        })
    end
    
    -- Universal Section
    InfoTab:AddParagraph({
        Title = "Universal",
        Content = ""
    })
    
    local placeNameLabel = InfoTab:AddParagraph({
        Title = "Place Name",
        Content = gameName
    })
    
    local placeIdLabel = InfoTab:AddParagraph({
        Title = "Place ID",
        Content = tostring(game.PlaceId)
    })
    
    local clientVersionLabel = InfoTab:AddParagraph({
        Title = "Client Version",
        Content = "Loading..."
    })
    
    local serverVersionLabel = InfoTab:AddParagraph({
        Title = "Server Version",
        Content = "Loading..."
    })
    
    local serverChannelLabel = InfoTab:AddParagraph({
        Title = "Server Channel",
        Content = "Loading..."
    })
    
    local placeVersionLabel = InfoTab:AddParagraph({
        Title = "Place Version",
        Content = "Loading..."
    })
    
    local coreScriptLabel = InfoTab:AddParagraph({
        Title = "Client CoreScript Version",
        Content = "Loading..."
    })
    
    -- Auto Update Toggle
    local autoUpdateToggle = InfoTab:AddToggle("AutoUpdateInfo", {
        Title = "Auto Update Info",
        Default = false,
        Callback = function(value)
            _G.AutoSetInfo = value
            if value then
                local connection
                connection = game:GetService("RunService").Heartbeat:Connect(function()
                    if not _G.AutoSetInfo then
                        if connection then
                            connection:Disconnect()
                        end
                        return
                    end
                    
                    -- Update currency
                    if player.leaderstats then
                        if player.leaderstats:FindFirstChild("Coins") then
                            coinsLabel:SetDesc("Coins: [ " .. player.leaderstats.Coins.Value .. " ]")
                        end
                        if player.leaderstats:FindFirstChild("Bites") then
                            bitesLabel:SetDesc("Bites: [ " .. player.leaderstats.Bites.Value .. " ]")
                        end
                    end
                    
                    -- Update insaenity level
                    local insaenityTracker = workspace["#GAME"].Map._Other.InsaenityTracker
                    if insaenityTracker and insaenityTracker.LVL.SurfaceGui.TextLabel then
                        insaenityLabel:SetDesc("Insaenity Lvl: [ " .. insaenityTracker.LVL.SurfaceGui.TextLabel.Text .. " ]")
                    end
                    
                    -- Update boss timer
                    local bossTimer = workspace["#GAME"].Map._Other.BOSS_Timer
                    if bossTimer and bossTimer.SurfaceGui.TextLabel then
                        bossTimerLabel:SetDesc("BOSS Noob in: [ " .. bossTimer.SurfaceGui.TextLabel.Text .. " ]")
                    end
                    
                    -- Update house kills
                    for i = 1, 5 do
                        local houseTracker = workspace["#GAME"].Map._Other.HouseTrackers[tostring(i)]
                        if houseTracker and houseTracker.Count.SurfaceGui.TextLabel then
                            houseKillsLabels[i]:SetDesc("House " .. i .. " Kills: [ " .. houseTracker.Count.SurfaceGui.TextLabel.Text .. " ]")
                        end
                    end
                    
                    -- Update version info
                    local coreGui = game:GetService("CoreGui").RobloxGui
                    if coreGui then
                        local settings = coreGui.SettingsClippingShield.SettingsShield.VersionContainer
                        if settings then
                            if settings:FindFirstChild("ClientVersionLabel") then
                                clientVersionLabel:SetDesc("Client Version [ " .. settings.ClientVersionLabel.Text .. " ]")
                            end
                            if settings:FindFirstChild("ServerVersionLabel") then
                                serverVersionLabel:SetDesc("Server Version [ " .. settings.ServerVersionLabel.Text .. " ]")
                            end
                            if settings:FindFirstChild("ServerChannelLabel") then
                                serverChannelLabel:SetDesc("Server Channel [ " .. settings.ServerChannelLabel.Text .. " ]")
                            end
                            if settings:FindFirstChild("PlaceVersionLabel") then
                                placeVersionLabel:SetDesc("Place Version [ " .. settings.PlaceVersionLabel.Text .. " ]")
                            end
                            if settings:FindFirstChild("CoreScriptVersionLabel") then
                                coreScriptLabel:SetDesc("Client CoreScript Version [ " .. settings.CoreScriptVersionLabel.Text .. " ]")
                            end
                        end
                    end
                end)
            end
        end
    })
end

do
    local MainTab = Tabs.Main
    
    -- Auto Eat Feature
    MainTab:AddParagraph({
        Title = "Auto Eat Feature",
        Content = ""
    })

-- Add this at the TOP of your script (after variables but before functions)
local RunService = game:GetService("RunService")
local Camera = workspace.CurrentCamera
local Players = game:GetService("Players")
local LocalPlayer = Players.LocalPlayer

local AutoEat = {
    -- Performance optimization variables
    PERFORMANCE_THRESHOLD = 0.033,
    lastPerformanceCheck = tick(),
    frameCount = 0,
    currentFPS = 60,
    lastActionTime = 0,
    ACTION_COOLDOWN = 0.1, -- Increased from 0.01 to reduce spam
    lastScanTime = 0,
    SCAN_INTERVAL = 0.1, -- Increased from 0.01 to reduce spam
    
    -- Cache for NPC lists to reduce scanning
    cachedDeadNPCs = {},
    cachedDeadNoobs = {},
    lastNPCCacheTime = 0,
    NPC_CACHE_INTERVAL = 0.5, -- Increased from 0.02 to reduce scanning
    
    -- Toggle states
    isActiveAll = false,
    isActiveSmart = false,
    isActiveChoosed = false,
    selectedCoinType = "Positive Coins",
    isAutoClicking = false,
    autoClickConnection = nil,
    
    -- Game settings
    USE_DEVIATION = true,
    MAX_DEVIATION_STUDS = 0.5,
    
    -- FIXED: Store camera reference
    Camera = nil,
    
    -- NEW: Game value calculation data
    baseValues = {
        Basic = {coins = 3, bites = 1},
        Ginger = {coins = 4, bites = 1},
        Delicious = {coins = 4, bites = 1},
        Party = {coins = 4, bites = 1},
        Buoyant = {coins = 5, bites = 1},
        Baby = {coins = 5, bites = 2},
        Big = {coins = 5, bites = 2},
        Bomb = {coins = 4, bites = 1},
        Bombarder = {coins = 12, bites = 7},
        Fat = {coins = 4, bites = 3},
        Fatter = {coins = 7, bites = 6},
        Fattest = {coins = 13, bites = 9},
        Flying = {coins = 10, bites = 3},
        Jumperino = {coins = 10, bites = 3},
        Metal = {coins = 12, bites = 5},
        Moai = {coins = 10, bites = 4},
        Nuke = {coins = 15, bites = 2},
        Paper = {coins = 5, bites = 1},
        Old = {coins = 1, bites = 3},
        Poop = {coins = 0, bites = 4},
        Rock = {coins = 8, bites = 3},
        Small = {coins = 4, bites = 1},
        Smaller = {coins = 6, bites = 1},
        Smallest = {coins = 8, bites = 1},
        Skinny = {coins = 4, bites = 10},
        Squished = {coins = 4, bites = 1},
        Squashed = {coins = 4, bites = 1},
        Tall = {coins = 4, bites = 2},
        Taller = {coins = 8, bites = 6},
        Tallest = {coins = 10, bites = 7},
        Turd = {coins = -1, bites = 9},
        Wide = {coins = 8, bites = 6},
        Werewolf = {coins = 50, bites = 20},
        Berend = {coins = 25, bites = 8},
        Dead = {coins = 5, bites = 1},
        BOSS = {coins = 200, bites = 50},
        Cracked = {coins = 85, bites = 5},
        BULL = {coins = 100, bites = 5},
        Nasty = {coins = -3, bites = 1},
        Raffie = {coins = -4, bites = -1},
        SigmaBloxian = {coins = -10, bites = -4},
        Stinky = {coins = -1, bites = 2},
        Greasy = {coins = -1, bites = 3},
        Rusty = {coins = -1, bites = 3},
        Rotten = {coins = -1, bites = 4},
        Burnt = {coins = -1, bites = 5},
    },
    
    -- Rarity multipliers from game code
    rarityMultipliers = {
        Silver = {coins = 2, bites = 1.5},
        Golden = {coins = 4, bites = 2},
        Diamond = {coins = 8, bites = 3},
        Emerald = {coins = 32, bites = 4},
        Ruby = {coins = 160, bites = 6},
        Amethyst = {coins = 800, bites = 8},
    },
    
    -- P2W (Pay-to-Win) detection - ONLY Emerald, Ruby, Amethyst
    p2wRarities = {"Amethyst", "Ruby", "Emerald"}
}

-- Initialize camera reference
AutoEat.Camera = workspace.CurrentCamera

-- ========== UPDATED PATH INITIALIZATION ==========
-- Initialize folders and remotes with correct paths
task.spawn(function()
    local success, errorMsg = pcall(function()
        -- Try to find the game folder with multiple attempts
        local gameFolder = workspace:FindFirstChild("#GAME") or workspace:FindFirstChild("GAME")
        
        if gameFolder then
            -- Try to find NPC folder with multiple path variations
            local possibleNPCPaths = {
                gameFolder:FindFirstChild("Folders") and gameFolder.Folders:FindFirstChild("VisibleInstances") and gameFolder.Folders.VisibleInstances:FindFirstChild("HumanoidFolder") and gameFolder.Folders.VisibleInstances.HumanoidFolder:FindFirstChild("NPCFolder"),
                gameFolder:FindFirstChild("NPCs"),
                gameFolder:FindFirstChild("Noobs"),
                workspace:FindFirstChild("NPCs"),
                workspace:FindFirstChild("Noobs")
            }
            
            for _, folder in ipairs(possibleNPCPaths) do
                if folder then
                    AutoEat.mainFolder = folder
                    break
                end
            end
            
            print("NPC Folder found:", AutoEat.mainFolder and AutoEat.mainFolder.Name or "Not found")
        end
        
        -- Get the ReplicatedStorage game folder
        local repStorageGame = game:GetService("ReplicatedStorage"):FindFirstChild("#GAME")
        if repStorageGame then
            -- MainAttack remote (as specified)
            AutoEat.remote = repStorageGame:FindFirstChild("_Storage") and 
                            repStorageGame._Storage:FindFirstChild("Events") and 
                            repStorageGame._Storage.Events:FindFirstChild("MainAttack")
            
            -- Click remote (updated path)
            AutoEat.clickRemote = repStorageGame:FindFirstChild("_Storage") and 
                                 repStorageGame._Storage:FindFirstChild("Events") and 
                                 repStorageGame._Storage.Events:FindFirstChild("Click")
            
            -- UsableTool remote (updated path)
            AutoEat.usableToolRemote = repStorageGame:FindFirstChild("_Storage") and 
                                      repStorageGame._Storage:FindFirstChild("Events") and 
                                      repStorageGame._Storage.Events:FindFirstChild("UsableTool")
        end
        
        -- Fallback: Try old paths if new ones don't work
        if not AutoEat.remote then
            AutoEat.remote = game:GetService("ReplicatedStorage"):FindFirstChild("Events") and game:GetService("ReplicatedStorage").Events:FindFirstChild("MainAttack")
        end
        if not AutoEat.clickRemote then
            AutoEat.clickRemote = game:GetService("ReplicatedStorage"):FindFirstChild("Events") and game:GetService("ReplicatedStorage").Events:FindFirstChild("Click")
        end
        if not AutoEat.usableToolRemote then
            AutoEat.usableToolRemote = game:GetService("ReplicatedStorage"):FindFirstChild("Events") and game:GetService("ReplicatedStorage").Events:FindFirstChild("UsableTool")
        end
        
        -- Debug prints
        print("=== AutoEat Path Debug ===")
        print("MainAttack Remote:", AutoEat.remote and AutoEat.remote:GetFullName() or "Not found")
        print("Click Remote:", AutoEat.clickRemote and AutoEat.clickRemote:GetFullName() or "Not found")
        print("UsableTool Remote:", AutoEat.usableToolRemote and AutoEat.usableToolRemote:GetFullName() or "Not found")
        print("NPC Folder:", AutoEat.mainFolder and AutoEat.mainFolder:GetFullName() or "Not found")
        print("==========================")
    end)
    
    if not success then
        warn("AutoEat: Failed to initialize game folders. Error:", errorMsg)
    end
end)

-- ========== REAL VALUE CALCULATION FUNCTIONS ==========
local function parseNoobInfo(npcName)
    local name = npcName:lower()
    local info = {
        baseType = "Basic",
        rarity = nil,
        modifiers = {},
        isP2W = false
    }
    
    -- Check for BOSS first
    if string.find(name, "boss") then
        info.baseType = "BOSS"
        return info
    end
    
    -- Check for special high-value types
    if string.find(name, "werewolf") then
        info.baseType = "Werewolf"
        return info
    end
    if string.find(name, "berend") then
        info.baseType = "Berend"
        return info
    end
    if string.find(name, "cracked") then
        info.baseType = "Cracked"
        return info
    end
    if string.find(name, "bull") then
        info.baseType = "BULL"
        return info
    end
    
    -- Check for dead types
    if string.find(name, "dead") then
        table.insert(info.modifiers, "Dead")
    end
    
    -- Check for negative/stink coin types
    local negativeTypes = {"nasty", "raffie", "sigmabloxian", "stinky", "greasy", "rusty", "rotten", "burnt", "turd", "poop"}
    for _, negType in ipairs(negativeTypes) do
        if string.find(name, negType) then
            info.baseType = negType:gsub("^%l", string.upper)
            break
        end
    end
    
    -- Check for cookies
    local cookieTypes = {"ginger", "delicious", "party", "buoyant", "primo"}
    for _, cookie in ipairs(cookieTypes) do
        if string.find(name, cookie) then
            info.baseType = cookie:gsub("^%l", string.upper)
            break
        end
    end
    
    -- Check for rarity
    local rarities = {"amethyst", "ruby", "emerald", "diamond", "golden", "gold", "silver", "rock"}
    for _, rarity in ipairs(rarities) do
        if string.find(name, rarity) then
            info.rarity = rarity:gsub("^%l", string.upper)
            if info.rarity == "Gold" then
                info.rarity = "Golden"
            end
            
            -- P2W detection: ONLY Emerald, Ruby, Amethyst are P2W
            for _, p2wRarity in ipairs(AutoEat.p2wRarities) do
                if info.rarity == p2wRarity then
                    info.isP2W = true
                    break
                end
            end
            break
        end
    end
    
    -- Check for base noob types
    if info.baseType == "Basic" then
        local baseTypes = {
            "baby", "big", "bomb", "fat", "fatter", "fattest", "flying", "jumperino",
            "metal", "moai", "nuke", "paper", "old", "small", "smaller", "smallest",
            "skinny", "squished", "squashed", "tall", "taller", "tallest", "wide"
        }
        for _, base in ipairs(baseTypes) do
            if string.find(name, base) then
                info.baseType = base:gsub("^%l", string.upper)
                break
            end
        end
    end
    
    return info
end

local function calculateActualCoins(noobInfo)
    local baseValue = AutoEat.baseValues[noobInfo.baseType] or AutoEat.baseValues.Basic
    local baseCoins = baseValue.coins
    
    -- Apply rarity multiplier
    if noobInfo.rarity and AutoEat.rarityMultipliers[noobInfo.rarity] then
        baseCoins = baseCoins * AutoEat.rarityMultipliers[noobInfo.rarity].coins
    end
    
    return math.floor(baseCoins)
end

local function calculateActualBites(noobInfo)
    local baseValue = AutoEat.baseValues[noobInfo.baseType] or AutoEat.baseValues.Basic
    local baseBites = baseValue.bites
    
    -- Apply rarity multiplier
    if noobInfo.rarity and AutoEat.rarityMultipliers[noobInfo.rarity] then
        baseBites = baseBites * AutoEat.rarityMultipliers[noobInfo.rarity].bites
    end
    
    return math.floor(baseBites)
end

-- ========== PERFORMANCE MONITORING ==========
local function checkPerformance()
    AutoEat.frameCount = AutoEat.frameCount + 1
    local currentTime = tick()
    
    if currentTime - AutoEat.lastPerformanceCheck >= 1 then
        AutoEat.currentFPS = AutoEat.frameCount
        AutoEat.frameCount = 0
        AutoEat.lastPerformanceCheck = currentTime
        
        if AutoEat.currentFPS < 25 then
            return false
        end
    end
    return true
end

-- Replace the useBurger function with this improved version:
local function useBurger()
    local player = game.Players.LocalPlayer
    local character = player.Character
    if not character then return false end
    
    -- First, check if we have any burgers equipped or in backpack
    local burgers = {}
    
    -- Check equipped tool
    local equippedTool = character:FindFirstChildWhichIsA("Tool")
    if equippedTool and string.find(equippedTool.Name:lower(), "burger") then
        table.insert(burgers, equippedTool)
    end
    
    -- Check backpack for burgers
    for _, item in ipairs(player.Backpack:GetChildren()) do
        if item:IsA("Tool") and string.find(item.Name:lower(), "burger") then
            table.insert(burgers, item)
        end
    end
    
    if #burgers == 0 then return false end
    
    -- Select a random burger
    local selectedBurger = burgers[math.random(1, #burgers)]
    
    -- If not equipped, equip it first
    if selectedBurger.Parent == player.Backpack then
        if equippedTool then
            equippedTool.Parent = player.Backpack
            task.wait(0.05)
        end
        selectedBurger.Parent = character
        task.wait(0.1)
    end
    
    -- Try to use the burger
    if AutoEat.usableToolRemote then
        local burgerArgs = {selectedBurger}
        local success = pcall(function()
            AutoEat.usableToolRemote:FireServer(unpack(burgerArgs))
        end)
        
        if success then
            -- Also send a click to ensure action registers
            if AutoEat.clickRemote then
                pcall(function()
                    AutoEat.clickRemote:FireServer()
                end)
            end
            return true
        end
    end
    
    -- Fallback to click if burger remote fails
    if AutoEat.clickRemote then
        pcall(function()
            AutoEat.clickRemote:FireServer()
        end)
        return true
    end
    
    return false
end

-- ========== AUTO CLICK FUNCTIONS ==========
local function startAutoClick()
    if AutoEat.autoClickConnection then
        AutoEat.autoClickConnection:Disconnect()
        AutoEat.autoClickConnection = nil
    end
    
    AutoEat.isAutoClicking = true
    AutoEat.autoClickConnection = RunService.Heartbeat:Connect(function()
        if not checkPerformance() then
            task.wait(0.01)
            return
        end
        
        local currentTime = tick()
        
        if AutoEat.isActiveChoosed and AutoEat.selectedCoinType == "Burgers" then
            if currentTime - AutoEat.lastActionTime >= AutoEat.ACTION_COOLDOWN then
                if AutoEat.clickRemote then
                    pcall(function()
                        AutoEat.clickRemote:FireServer()
                    end)
                end
            end
            return
        end
        
        if AutoEat.clickRemote then
            pcall(function()
                AutoEat.clickRemote:FireServer()
            end)
        end
        task.wait(0.01)
    end)
end

local function stopAutoClick()
    AutoEat.isAutoClicking = false
    if AutoEat.autoClickConnection then
        AutoEat.autoClickConnection:Disconnect()
        AutoEat.autoClickConnection = nil
    end
end

-- ========== NPC SCANNING FUNCTIONS ==========
local function getDeadNPCs()
    local currentTime = tick()
    
    if #AutoEat.cachedDeadNPCs > 0 and (currentTime - AutoEat.lastNPCCacheTime) < AutoEat.NPC_CACHE_INTERVAL then
        return AutoEat.cachedDeadNPCs
    end
    
    local deadList = {}
    if not AutoEat.mainFolder then 
        AutoEat.cachedDeadNPCs = deadList
        return deadList 
    end

    pcall(function()
        local foldersToCheck = {AutoEat.mainFolder}
        
        -- Alternative path check
        local alternativePath = workspace:FindFirstChild("#GAME") and 
                               workspace["#GAME"]:FindFirstChild("Folders") and 
                               workspace["#GAME"].Folders:FindFirstChild("VisibleInstances") and 
                               workspace["#GAME"].Folders.VisibleInstances:FindFirstChild("HumanoidFolder") and 
                               workspace["#GAME"].Folders.VisibleInstances.HumanoidFolder:FindFirstChild("NPCFolder")
        if alternativePath and alternativePath ~= AutoEat.mainFolder then
            table.insert(foldersToCheck, alternativePath)
        end

        for _, folder in ipairs(foldersToCheck) do
            local npcs = folder:GetChildren()
            for i = 1, #npcs do
                local npc = npcs[i]
                if npc:IsA("Model") then
                    local humanoid = npc:FindFirstChildOfClass("Humanoid")
                    if humanoid and (humanoid.Health <= 0 or string.find(npc.Name, "Dead", 1, true) or string.find(humanoid.Name, "Dead", 1, true)) then
                        table.insert(deadList, npc)
                    end
                end
                
                if i % 20 == 0 then
                    task.wait()
                end
            end
        end
    end)
    
    AutoEat.cachedDeadNPCs = deadList
    AutoEat.lastNPCCacheTime = currentTime
    return deadList
end

-- ========== FIXED TARGET SELECTION ==========

-- AUTO EAT SMART: First P2W noobs, then regular highest coin noobs
local function getSmartTarget(npcList)
    if not npcList or #npcList == 0 then return nil end
    
    local p2wTargets = {}
    local regularTargets = {}
    
    -- Separate P2W and regular noobs
    for _, npc in ipairs(npcList) do
        local noobInfo = parseNoobInfo(npc.Name)
        local coins = calculateActualCoins(noobInfo)
        
        if noobInfo.isP2W then
            -- P2W noob
            table.insert(p2wTargets, {
                npc = npc,
                coins = coins,
                isP2W = true,
                rarity = noobInfo.rarity
            })
        else
            -- Regular noob
            table.insert(regularTargets, {
                npc = npc,
                coins = coins,
                isP2W = false
            })
        end
    end
    
    -- 1. First priority: P2W noobs (sorted highest to lowest coins)
    if #p2wTargets > 0 then
        table.sort(p2wTargets, function(a, b)
            return a.coins > b.coins
        end)
        return p2wTargets[1].npc
    end
    
    -- 2. Second priority: Regular noobs (sorted highest to lowest coins)
    if #regularTargets > 0 then
        table.sort(regularTargets, function(a, b)
            return a.coins > b.coins
        end)
        return regularTargets[1].npc
    end
    
    return nil
end

-- AUTO EAT ALL: Targets ALL noobs (highest to lowest coins overall)
local function getAllNoobsTarget(npcList)
    if not npcList or #npcList == 0 then return nil end
    
    -- Collect all noobs with their coin values
    local allTargets = {}
    
    for _, npc in ipairs(npcList) do
        local noobInfo = parseNoobInfo(npc.Name)
        local coins = calculateActualCoins(noobInfo)
        
        table.insert(allTargets, {
            npc = npc,
            coins = coins
        })
    end
    
    -- Sort ALL targets from HIGHEST to LOWEST coins
    table.sort(allTargets, function(a, b)
        return a.coins > b.coins
    end)
    
    -- Return the highest coin target overall
    return allTargets[1].npc
end

local function getChoosedTypeTarget(npcList, coinType)
    if not npcList or #npcList == 0 then return nil end
    
    if coinType == "Positive Coins" then
        -- Get all positive coin targets
        local positiveTargets = {}
        for _, npc in ipairs(npcList) do
            local noobInfo = parseNoobInfo(npc.Name)
            local coins = calculateActualCoins(noobInfo)
            if coins > 0 then
                table.insert(positiveTargets, {
                    npc = npc,
                    coins = coins
                })
            end
        end
        
        -- Sort positive targets from HIGHEST to LOWEST
        if #positiveTargets > 0 then
            table.sort(positiveTargets, function(a, b)
                return a.coins > b.coins
            end)
            return positiveTargets[1].npc
        end
        
    elseif coinType == "Negative Coins" then
        -- Get all negative coin targets
        local negativeTargets = {}
        for _, npc in ipairs(npcList) do
            local noobInfo = parseNoobInfo(npc.Name)
            local coins = calculateActualCoins(noobInfo)
            if coins < 0 then
                table.insert(negativeTargets, {
                    npc = npc,
                    coins = coins
                })
            end
        end
        
        -- Sort negative targets from LOWEST to HIGHEST (most negative first)
        if #negativeTargets > 0 then
            table.sort(negativeTargets, function(a, b)
                return a.coins < b.coins
            end)
            return negativeTargets[1].npc
        end
        
    elseif coinType == "Stink Coins" then
        -- Get stink coin noobs (coins <= 0)
        local stinkTargets = {}
        for _, npc in ipairs(npcList) do
            local noobInfo = parseNoobInfo(npc.Name)
            local coins = calculateActualCoins(noobInfo)
            if coins <= 0 then
                table.insert(stinkTargets, {
                    npc = npc,
                    coins = coins
                })
            end
        end
        
        -- Sort stink targets from LOWEST to HIGHEST (most negative first)
        if #stinkTargets > 0 then
            table.sort(stinkTargets, function(a, b)
                return a.coins < b.coins
            end)
            return stinkTargets[1].npc
        end
        
    elseif coinType == "Cookies" then
        -- Get cookie noobs
        local cookieNames = {"Ginger", "Delicious", "Party", "Buoyant", "Primo"}
        local cookieTargets = {}
        for _, npc in ipairs(npcList) do
            for _, cookieName in ipairs(cookieNames) do
                if string.find(npc.Name, cookieName, 1, true) then
                    local noobInfo = parseNoobInfo(npc.Name)
                    local coins = calculateActualCoins(noobInfo)
                    table.insert(cookieTargets, {
                        npc = npc,
                        coins = coins
                    })
                    break
                end
            end
        end
        
        -- Sort cookie targets from HIGHEST to LOWEST
        if #cookieTargets > 0 then
            table.sort(cookieTargets, function(a, b)
                return a.coins > b.coins
            end)
            return cookieTargets[1].npc
        end
        
    elseif coinType == "King Coins" then
        for _, npc in ipairs(npcList) do
            if npc.Name:find("BOSS", 1, true) then
                return npc
            end
        end
        
    elseif coinType == "Dead Noobs" then
        local deadNoobList = {}
        for _, npc in ipairs(npcList) do
            if string.find(npc.Name:lower(), "dead", 1, true) then
                local noobInfo = parseNoobInfo(npc.Name)
                local coins = calculateActualCoins(noobInfo)
                table.insert(deadNoobList, {
                    npc = npc,
                    coins = coins
                })
            end
        end
        
        -- Sort dead noobs from HIGHEST to LOWEST
        if #deadNoobList > 0 then
            table.sort(deadNoobList, function(a, b)
                return a.coins > b.coins
            end)
            return deadNoobList[1].npc
        end
        
    elseif coinType == "Burgers" then
        return "BURGER_MODE"
        
    elseif coinType == "Pouwkoins" then
    -- Get only targets with "Pouwk" in the name (case insensitive)
    local pouwkTargets = {}
    for _, npc in ipairs(npcList) do
        local npcNameLower = npc.Name:lower()
        if string.find(npcNameLower, "pouwk") then
            local noobInfo = parseNoobInfo(npc.Name)
            local bites = calculateActualBites(noobInfo)
            table.insert(pouwkTargets, {
                npc = npc,
                bites = bites,
                name = npc.Name
            })
        end
    end
    
    -- Sort from HIGHEST to LOWEST bites
    if #pouwkTargets > 0 then
        table.sort(pouwkTargets, function(a, b)
            return a.bites > b.bites
        end)

        return pouwkTargets[1].npc
    end
        
    elseif coinType == "BULLoneys" then
    -- Get only targets with "BULL" in the name (case insensitive)
    local bullTargets = {}
    for _, npc in ipairs(npcList) do
        local npcNameLower = npc.Name:lower()
        if string.find(npcNameLower, "bull") then
            local noobInfo = parseNoobInfo(npc.Name)
            local coins = calculateActualCoins(noobInfo)
            local bites = calculateActualBites(noobInfo)
            local totalValue = coins + (bites * 0.5)
            table.insert(bullTargets, {
                npc = npc,
                value = totalValue,
                coins = coins,
                name = npc.Name
            })
        end
    end
    
    -- Sort from HIGHEST to LOWEST total value
    if #bullTargets > 0 then
        table.sort(bullTargets, function(a, b)
            return a.value > b.value
        end)
        
        return bullTargets[1].npc
    end
    
    end

    return nil
end

-- ========== FIXED ATTACK FUNCTION ==========
local function attackTarget(targetNpc)
    local currentTime = tick()
    
    if currentTime - AutoEat.lastActionTime < AutoEat.ACTION_COOLDOWN then
        return
    end
    
    if not targetNpc or not targetNpc.Parent then return end

    -- FIXED: Get camera safely
    local camera = AutoEat.Camera
    if not camera or not camera.CFrame then
        -- Try to get fresh camera reference
        camera = workspace.CurrentCamera
        if not camera then return end
        AutoEat.Camera = camera
    end

    local validParts = {}
    pcall(function()
        for _, part in ipairs(targetNpc:GetDescendants()) do
            if part:IsA("BasePart") then
                local isGettingEaten = part:GetAttribute("IsGettingEaten")
                if not isGettingEaten then
                    table.insert(validParts, part)
                end
            end
            
            if #validParts >= 5 then
                break
            end
        end
    end)
    
    if #validParts == 0 then return end

    local bodyPart = validParts[math.random(1, #validParts)]
    local origin = camera.CFrame.Position
    local targetPosition = bodyPart.Position

    if AutoEat.USE_DEVIATION and AutoEat.MAX_DEVIATION_STUDS > 0 then
        local offsetX = (math.random() - 0.5) * 2 * AutoEat.MAX_DEVIATION_STUDS
        local offsetY = (math.random() - 0.5) * 2 * AutoEat.MAX_DEVIATION_STUDS
        local offsetZ = (math.random() - 0.5) * 2 * AutoEat.MAX_DEVIATION_STUDS
        targetPosition = targetPosition + Vector3.new(offsetX, offsetY, offsetZ)
    end

    local direction = (targetPosition - origin).Unit

    if direction.X ~= direction.X or direction.Y ~= direction.Y or direction.Z ~= direction.Z then
        direction = camera.CFrame.LookVector
    end

    local args = {
        [1] = {
            ["AN"] = "Eat",
            ["D"] = direction,
            ["O"] = origin,
            ["FBP"] = bodyPart
        }
    }
    
    local success = false
    if AutoEat.remote then
        success = pcall(function()
            AutoEat.remote:FireServer(unpack(args))
        end)
    end
    
    if success then
        AutoEat.lastActionTime = currentTime
    end
end

-- ========== FIXED MAIN LOOP ==========
local mainConnection = nil

local function startMainLoop()
    if mainConnection then
        mainConnection:Disconnect()
        mainConnection = nil
    end
    
    mainConnection = RunService.Heartbeat:Connect(function()
        -- Only run if at least one toggle is active
        if not (AutoEat.isActiveAll or AutoEat.isActiveSmart or AutoEat.isActiveChoosed) then
            return
        end
        
        if not checkPerformance() then
            task.wait(0.01)
            return
        end
        
        local currentTime = tick()
        
        -- Reduced scanning frequency
        if currentTime - AutoEat.lastScanTime < AutoEat.SCAN_INTERVAL then
            return
        end
        
        AutoEat.lastScanTime = currentTime

        local deadNPCList = getDeadNPCs()

        -- Auto Eat All: Targets ALL noobs (highest to lowest coins overall)
        if AutoEat.isActiveAll then
            local targetNpc = getAllNoobsTarget(deadNPCList)
            if targetNpc then
                attackTarget(targetNpc)
                return
            end
        end

        -- Auto Eat Smart: First P2W noobs, then regular highest coin noobs
        if AutoEat.isActiveSmart then
            local targetNpc = getSmartTarget(deadNPCList)
            if targetNpc then
                attackTarget(targetNpc)
                return
            end
        end

        -- Auto Eat Choosed Type
        if AutoEat.isActiveChoosed then
            local targetNpc = getChoosedTypeTarget(deadNPCList, AutoEat.selectedCoinType)
            
            if targetNpc == "BURGER_MODE" then
                if currentTime - AutoEat.lastActionTime >= AutoEat.ACTION_COOLDOWN then
                    useBurger()
                    AutoEat.lastActionTime = currentTime
                end
                return
            elseif targetNpc then
                attackTarget(targetNpc)
                return
            end
        end
    end)
end

local function stopMainLoop()
    if mainConnection then
        mainConnection:Disconnect()
        mainConnection = nil
    end
end

-- ========== FLUENT HUB UI ELEMENTS ==========
local coinTypes = {
    "Positive Coins",
    "Stink Coins",
    "Cookies",
    "King Coins",
    "Dead Noobs",
    "Burgers",
    "Pouwkoins",
    "BULLoneys"
}

-- ========== FLUENT HUB UI FOR AUTO EAT ==========

-- Auto Eat All Type Toggle (Fluent Hub)
local autoEatAllToggle = Tabs.Main:AddToggle("AutoEatAllToggle", {
    Title = "Auto Eat All Type",
    Description = "Eats ALL noobs (highest to lowest coins overall)",
    Default = AutoEat.isActiveAll,
    Callback = function(value)
        AutoEat.isActiveAll = value
        if value then
            -- Turn off other modes
            AutoEat.isActiveSmart = false
            AutoEat.isActiveChoosed = false
            
            -- Update other toggles
            if autoEatSmartToggle then
                autoEatSmartToggle:SetValue(false)
            end
            if autoEatChoosedToggle then
                autoEatChoosedToggle:SetValue(false)
            end
            
            startAutoClick()
            startMainLoop()
            Options.AutoEatAllToggle:SetValue(true)
        else
            if not AutoEat.isActiveSmart and not AutoEat.isActiveChoosed then
                stopAutoClick()
                stopMainLoop()
            end
        end
    end
})

-- Auto Eat Smart Toggle (Fluent Hub)
local autoEatSmartToggle = Tabs.Main:AddToggle("AutoEatSmartToggle", {
    Title = "Auto Eat Smart",
    Description = "P2W > Highest Value > Value Based",
    Default = AutoEat.isActiveSmart,
    Callback = function(value)
        AutoEat.isActiveSmart = value
        if value then
            -- Turn off other modes
            AutoEat.isActiveAll = false
            AutoEat.isActiveChoosed = false
            
            -- Update other toggles
            if autoEatAllToggle then
                autoEatAllToggle:SetValue(false)
            end
            if autoEatChoosedToggle then
                autoEatChoosedToggle:SetValue(false)
            end
            
            startAutoClick()
            startMainLoop()
            Options.AutoEatSmartToggle:SetValue(true)
        else
            if not AutoEat.isActiveAll and not AutoEat.isActiveChoosed then
                stopAutoClick()
                stopMainLoop()
            end
        end
    end
})

-- Coin Type Dropdown (Fluent Hub)
local coinTypeDropdown = Tabs.Main:AddDropdown("CoinTypeDropdown", {
    Title = "Choose Type To Auto Eat",
    Description = "Select which type of noobs to target",
    Values = {
        "Positive Coins",
        "Stink Coins",
        "Cookies",
        "King Coins",
        "Dead Noobs",
        "Burgers",
        "Pouwkoins",
        "BULLoneys"
    },
    Multi = false,
    Default = 1, -- Positive Coins is first in list
    Callback = function(value)
        -- value is the selected item (string)
        AutoEat.selectedCoinType = value
        print("AutoEat: Selected coin type:", value)
    end
})

-- Auto Eat Choosed Type Toggle (Fluent Hub)
local autoEatChoosedToggle = Tabs.Main:AddToggle("AutoEatChoosedToggle", {
    Title = "Auto Eat Choosed Type",
    Description = "Eats selected coin type (Value Based)",
    Default = AutoEat.isActiveChoosed,
    Callback = function(value)
        AutoEat.isActiveChoosed = value
        if value then
            -- Turn off other modes
            AutoEat.isActiveAll = false
            AutoEat.isActiveSmart = false
            
            -- Update other toggles
            if autoEatAllToggle then
                autoEatAllToggle:SetValue(false)
            end
            if autoEatSmartToggle then
                autoEatSmartToggle:SetValue(false)
            end
            
            startAutoClick()
            startMainLoop()
            Options.AutoEatChoosedToggle:SetValue(true)
        else
            if not AutoEat.isActiveAll and not AutoEat.isActiveSmart then
                stopAutoClick()
                stopMainLoop()
            end
        end
    end
})

    -- Auto Shoot Feature
    MainTab:AddParagraph({
        Title = "Auto Shoot Feature",
        Content = ""
    })
    
-- Auto Shoot System (Optimized)
local ShootSystem = setmetatable({
    Running = false,
    Connection = nil,
    LastShootTime = 0,
    IsHolding = false,
    HoldStartTime = 0,
    CurrentTarget = nil,
    TwoPhasePhase = 1,
    MainAttackEvent = nil,
    _cleaningUp = false,
    
    -- Weak references for better memory management
    CachedNPCs = setmetatable({}, {__mode = "v"})
}, {
    __index = function(self, key)
        -- Lazy load services
        if key == "Players" then return game:GetService("Players")
        elseif key == "ReplicatedStorage" then return game:GetService("ReplicatedStorage")
        elseif key == "RunService" then return game:GetService("RunService")
        elseif key == "Workspace" then return game:GetService("Workspace")
        elseif key == "Player" then 
            local players = game:GetService("Players")
            local player = players.LocalPlayer
            if not player then
                players.PlayerAdded:Wait()
                player = players.LocalPlayer
            end
            rawset(self, "Player", player)
            return player
        end
    end
})

-- Settings (using local table instead of _G for better performance)
local AutoShootSettings = {
    GunName = "Minigun",
    ShootingSpeed = 6,
    MaxDistance = 1000,
    Enabled = false
}

-- Configuration tables (local for faster access)
local HoldTools = {"TMG V2", "SMOGGTTLTSG"}
local TwoPhaseGuns = {"The Eggsterminator", "Firework Launcher", "Nubids Bow", "Pumpkin Launcher"}
local IgnoreNPCs = {"dead", "invincible", "crackedbas", "whitebas"}

-- Cache for NPC folder
local NPCFolderCache = nil
local lastFolderCheck = 0

-- Find NPC folder with caching
local function getNPCFolder()
    local currentTime = tick()
    if NPCFolderCache and (currentTime - lastFolderCheck) < 5 then
        return NPCFolderCache
    end
    
    local Workspace = game:GetService("Workspace")
    local gameFolder = Workspace:FindFirstChild("#GAME") or Workspace:FindFirstChild("GAME") or Workspace:FindFirstChild("Game")
    
    if not gameFolder then
        lastFolderCheck = currentTime
        return nil
    end
    
    -- Check common paths
    local possiblePaths = {
        gameFolder:FindFirstChild("Folders") and gameFolder.Folders:FindFirstChild("VisibleInstances") and 
        gameFolder.Folders.VisibleInstances:FindFirstChild("HumanoidFolder") and 
        gameFolder.Folders.VisibleInstances.HumanoidFolder:FindFirstChild("NPCFolder"),
        gameFolder:FindFirstChild("NPCs"),
        Workspace:FindFirstChild("NPCs"),
        Workspace:FindFirstChild("Noobs"),
        Workspace:FindFirstChild("DeadNoobs")
    }
    
    for _, folder in ipairs(possiblePaths) do
        if folder then
            NPCFolderCache = folder
            lastFolderCheck = currentTime
            return folder
        end
    end
    
    -- Search recursively as last resort
    local function searchForNPCFolder(parent)
        for _, child in ipairs(parent:GetChildren()) do
            if child:IsA("Folder") then
                local nameLower = child.Name:lower()
                if nameLower:find("npc") or nameLower:find("noob") then
                    return child
                end
                local found = searchForNPCFolder(child)
                if found then return found end
            end
        end
        return nil
    end
    
    NPCFolderCache = searchForNPCFolder(gameFolder) or searchForNPCFolder(Workspace)
    lastFolderCheck = currentTime
    return NPCFolderCache
end

-- Cache for attack event
local MainAttackEvent = nil
local lastEventCheck = 0

-- Get main attack event with caching
local function getAttackEvent()
    local currentTime = tick()
    if MainAttackEvent and (currentTime - lastEventCheck) < 10 then
        return MainAttackEvent
    end
    
    local rs = game:GetService("ReplicatedStorage")
    local paths = {
        rs:FindFirstChild("#GAME") and rs["#GAME"]:FindFirstChild("_Storage") and 
        rs["#GAME"]._Storage:FindFirstChild("Events") and rs["#GAME"]._Storage.Events:FindFirstChild("MainAttack"),
        rs:FindFirstChild("Events") and rs.Events:FindFirstChild("MainAttack")
    }
    
    for _, event in ipairs(paths) do
        if event and event:IsA("RemoteEvent") then
            MainAttackEvent = event
            lastEventCheck = currentTime
            return event
        end
    end
    
    lastEventCheck = currentTime
    return nil
end

-- Helper functions
local function shouldIgnore(npc)
    if not npc or not npc:IsA("Model") then return true end
    
    local name = npc.Name:lower()
    for _, ignore in ipairs(IgnoreNPCs) do
        if name:find(ignore) then
            if ignore == "crackedbas" or ignore == "whitebas" then
                local h = npc:FindFirstChildOfClass("Humanoid")
                if h and h.MaxHealth == 500000 then return true end
            else
                return true
            end
        end
    end
    return false
end

local function isHoldTool(name)
    for _, tool in ipairs(HoldTools) do
        if name == tool then return true end
    end
    return false
end

local function isTwoPhase(name)
    for _, gun in ipairs(TwoPhaseGuns) do
        if name == gun then return true end
    end
    return false
end

local function getTool(name)
    local player = ShootSystem.Player
    if not player then return nil end
    
    -- Check character first
    local char = player.Character
    if char then
        local tool = char:FindFirstChild(name)
        if tool then return tool end
    end
    
    -- Check backpack
    local backpack = player.Backpack
    if backpack then
        return backpack:FindFirstChild(name)
    end
    
    return nil
end

-- Two-phase gun attacks (optimized)
local function twoPhaseAttack(target, gunName, phase)
    local char = ShootSystem.Player.Character
    if not char then return end
    
    local tool = getTool(gunName)
    if not tool then return end
    
    local head = target:FindFirstChild("Head")
    if not head then return end
    
    local event = getAttackEvent()
    if not event then return end
    
    local args = {}
    local headPos = head.Position
    
    if gunName == "The Eggsterminator" then
        if phase == 1 then
            args = {{
                A = char, AN = gunName, O = headPos,
                D = Vector3.new(-0.5608, -0.5042, -0.6567), T = tool,
                SP = headPos, HP = headPos, RS = headPos
            }}
        else
            args = {{
                ALV = Vector3.new(-0.2052, -391.425, -5.5824), EP = headPos,
                T = tool, AN = gunName .. "Explode", A = char
            }}
        end
    elseif gunName == "Firework Launcher" then
        if phase == 1 then
            args = {{
                A = char, D = Vector3.new(0.3890, -0.3426, -0.8552), RS = headPos,
                AN = gunName, T = tool, O = headPos - Vector3.new(0, 10, 0),
                SP = headPos, FireworkCount = 2, HP = headPos, CanExplodeFirework = true
            }}
        else
            args = {{
                ALV = Vector3.new(29.2565, -18.4212, -80.4404), EP = headPos,
                T = tool, AN = gunName .. "Explode", A = char
            }}
        end
    elseif gunName == "Nubids Bow" then
        if phase == 1 then
            args = {{
                A = char, AN = gunName, O = headPos,
                D = Vector3.new(0.6942, -0.5255, -0.4919), T = tool,
                SP = headPos, HP = headPos, RS = headPos
            }}
        else
            args = {{AN = gunName .. " Hit", H = head, T = tool}}
        end
    elseif gunName == "Pumpkin Launcher" then
        if phase == 1 then
            args = {{
                A = char, AN = gunName, O = headPos,
                D = Vector3.new(0.2887, -0.4179, -0.8614), T = tool,
                SP = headPos, HP = headPos, RS = headPos
            }}
        else
            args = {{
                ALV = Vector3.new(6.4805, 122.9122, -108.0439), EP = headPos,
                T = tool, AN = gunName .. "Explode", A = char
            }}
        end
    end
    
    if #args > 0 then
        pcall(function()
            event:FireServer(unpack(args))
        end)
    end
end

-- Regular attack function (optimized)
local function regularAttack(target, gunName, isHold)
    local char = ShootSystem.Player.Character
    if not char then return end
    
    local tool = getTool(gunName)
    if not tool then return end
    
    -- Ensure tool is equipped
    if tool.Parent == ShootSystem.Player.Backpack then
        local equipped = char:FindFirstChildWhichIsA("Tool")
        if equipped then
            equipped.Parent = ShootSystem.Player.Backpack
            task.wait(0.01)
        end
        tool.Parent = char
        task.wait(0.01)
    end
    
    local head = target:FindFirstChild("Head")
    if not head then return end
    
    local root = char:FindFirstChild("HumanoidRootPart") or char.PrimaryPart
    if not root then return end
    
    local event = getAttackEvent()
    if not event then return end
    
    local args = {{
        FD = head.Position, 
        SD = Vector3.new(), 
        FO = root.Position + Vector3.new(0, 1.5, 0),
        T = tool, 
        AN = gunName, 
        H = head, 
        BM = 22.15, 
        RP = root.Position,
        HP = head.Position, 
        SP = head.Position
    }}
    
    if isHold then
        args[1].IsHolding = true
        args[1].Duration = 0.1
    end
    
    pcall(function()
        event:FireServer(unpack(args))
    end)
end

-- Find target (optimized with caching)
local lastTargetScan = 0
local cachedTargets = {}
local function findTarget(char, maxDist)
    if not char or not char.PrimaryPart then return nil end
    
    local npcFolder = getNPCFolder()
    if not npcFolder then return nil end
    
    local currentTime = tick()
    if #cachedTargets > 0 and (currentTime - lastTargetScan) < 0.1 then
        local charPos = char.PrimaryPart.Position
        for _, npc in ipairs(cachedTargets) do
            if npc and npc.Parent then
                local head = npc:FindFirstChild("Head")
                if head then
                    local dist = (charPos - head.Position).Magnitude
                    if dist <= maxDist then
                        return npc
                    end
                end
            end
        end
    end
    
    -- Refresh cache
    local validNPCs = {}
    local charPos = char.PrimaryPart.Position
    
    for _, npc in ipairs(npcFolder:GetChildren()) do
        if not ShootSystem.Running then break end
        if shouldIgnore(npc) then continue end
        
        local h = npc:FindFirstChildOfClass("Humanoid")
        local head = npc:FindFirstChild("Head")
        
        if h and head and h.Health > 0 then
            local dist = (charPos - head.Position).Magnitude
            if dist <= maxDist then
                table.insert(validNPCs, npc)
            end
        end
    end
    
    cachedTargets = validNPCs
    lastTargetScan = currentTime
    
    return validNPCs[1] -- Return first valid target
end

-- Main loop
local function startLoop()
    if ShootSystem.Connection then
        ShootSystem.Connection:Disconnect()
        ShootSystem.Connection = nil
    end
    
    ShootSystem.Connection = ShootSystem.RunService.Heartbeat:Connect(function()
        if ShootSystem._cleaningUp or not ShootSystem.Running then return end
        
        local char = ShootSystem.Player.Character
        if not char or not char.PrimaryPart then 
            task.wait(0.1)
            return 
        end
        
        local target = findTarget(char, AutoShootSettings.MaxDistance)
        if not target then
            ShootSystem.IsHolding = false
            ShootSystem.CurrentTarget = nil
            ShootSystem.TwoPhasePhase = 1
            task.wait(0.05)
            return
        end
        
        local currentTime = tick()
        local interval = 1 / math.clamp(AutoShootSettings.ShootingSpeed, 1, 60)
        
        if isTwoPhase(AutoShootSettings.GunName) then
            if not getTool(AutoShootSettings.GunName) then
                task.wait(0.1)
                return
            end
            
            if currentTime - ShootSystem.LastShootTime >= 0.01 then
                twoPhaseAttack(target, AutoShootSettings.GunName, ShootSystem.TwoPhasePhase)
                ShootSystem.TwoPhasePhase = ShootSystem.TwoPhasePhase == 1 and 2 or 1
                ShootSystem.LastShootTime = currentTime
            end
        else
            local isHold = isHoldTool(AutoShootSettings.GunName)
            
            if isHold then
                if ShootSystem.CurrentTarget ~= target then
                    ShootSystem.IsHolding = false
                    ShootSystem.CurrentTarget = target
                end
                
                if not ShootSystem.IsHolding then
                    ShootSystem.IsHolding = true
                    ShootSystem.HoldStartTime = currentTime
                    regularAttack(target, AutoShootSettings.GunName, true)
                elseif currentTime - ShootSystem.HoldStartTime >= interval then
                    regularAttack(target, AutoShootSettings.GunName, true)
                    ShootSystem.HoldStartTime = currentTime
                end
            elseif currentTime - ShootSystem.LastShootTime >= interval then
                regularAttack(target, AutoShootSettings.GunName, false)
                ShootSystem.LastShootTime = currentTime
            end
        end
    end)
end

-- Cleanup function
local function cleanup()
    if ShootSystem._cleaningUp then return end
    
    ShootSystem._cleaningUp = true
    ShootSystem.Running = false
    ShootSystem.IsHolding = false
    ShootSystem.CurrentTarget = nil
    ShootSystem.TwoPhasePhase = 1
    
    if ShootSystem.Connection then
        ShootSystem.Connection:Disconnect()
        ShootSystem.Connection = nil
    end
    
    -- Clear caches
    cachedTargets = {}
    ShootSystem.CachedNPCs = setmetatable({}, {__mode = "v"})
    
    -- Allow garbage collection
    task.wait(0.1)
    ShootSystem._cleaningUp = false
end

-- Character respawn handler
ShootSystem.Player.CharacterAdded:Connect(function()
    task.wait(1)
    if AutoShootSettings.Enabled then
        ShootSystem.Running = true
        task.wait(1)
        startLoop()
    end
end)

-- ========== FLUENT HUB UI FOR AUTO SHOOT SYSTEM ==========

-- Gun Name Textbox (Fluent Hub)
local gunNameInput = Tabs.Main:AddInput("GunNameInput", {
    Title = "Gun Name",
    Default = "Minigun",
    Placeholder = "Enter gun name",
    Numeric = false,
    Finished = false,
    Callback = function(Text)
        AutoShootSettings.GunName = tostring(Text) or "Minigun"
        print("Auto Shoot: Gun set to", AutoShootSettings.GunName)
    end
})

-- Shooting Speed Textbox (Fluent Hub)
local shootingSpeedInput = Tabs.Main:AddInput("ShootingSpeedInput", {
    Title = "Shooting Speed",
    Default = "6",
    Placeholder = "Shots per second (1-60)",
    Numeric = true,
    Finished = false,
    Callback = function(Text)
        local speed = tonumber(Text) or 6
        AutoShootSettings.ShootingSpeed = math.clamp(speed, 1, 60)
        print("Auto Shoot: Speed set to", AutoShootSettings.ShootingSpeed, "shots/sec")
    end
})

-- Max Distance Textbox (Fluent Hub)
local maxDistanceInput = Tabs.Main:AddInput("MaxDistanceInput", {
    Title = "Max Distance",
    Default = "1000",
    Placeholder = "Max targeting distance (10-5000)",
    Numeric = true,
    Finished = false,
    Callback = function(Text)
        local distance = tonumber(Text) or 1000
        AutoShootSettings.MaxDistance = math.clamp(distance, 10, 5000)
        print("Auto Shoot: Max distance set to", AutoShootSettings.MaxDistance, "studs")
    end
})

-- Auto Shoot Toggle (Fluent Hub)
local autoShootToggle = Tabs.Main:AddToggle("AutoShootToggle", {
    Title = "Auto Shoot",
    Description = "Automatically shoots at NPCs with selected gun",
    Default = AutoShootSettings.Enabled,
    Callback = function(Value)
        AutoShootSettings.Enabled = Value
        
        if Value then
            ShootSystem.Running = true
            ShootSystem.IsHolding = false
            ShootSystem.CurrentTarget = nil
            ShootSystem.LastShootTime = 0
            ShootSystem.TwoPhasePhase = 1
            
            task.spawn(function()
                getAttackEvent() -- Pre-cache event
                task.wait(1)
                if ShootSystem.Running then
                    startLoop()
                end
            end)
            
            print("Auto Shoot: Enabled with gun", AutoShootSettings.GunName)
        else
            cleanup()
            print("Auto Shoot: Disabled")
        end
    end
})

    -- Hitbox Stuff
    MainTab:AddParagraph({
        Title = "Hitbox Stuff",
        Content = ""
    })
    
    local SwordHitboxController = {
        hitboxSize = 10,
        selectedSword = "Classic Sword",
        autoSetEnabled = false,
        hitboxUpdateThread = nil
    }
    
    local swordNames = {
        "Balloon Sword",
        "Classic Sword",
        "Lamppost",
        "King Slayer",
        "Pine Tree",
        "Soulreaper",
        "Billboard"
    }
    
    local function stopThread(thread)
        if thread then
            task.cancel(thread)
            return nil
        end
        return nil
    end
    
    local function findSwordTool()
        if not localPlayer then return nil end
        
        local backpack = localPlayer:FindFirstChild("Backpack")
        if not backpack then return nil end
        
        local swordTool = backpack:FindFirstChild(SwordHitboxController.selectedSword)
        if not swordTool then
            for _, tool in pairs(backpack:GetChildren()) do
                if tool:IsA("Tool") and tool.Name:lower() == SwordHitboxController.selectedSword:lower() then
                    return tool
                end
            end
        end
        
        return swordTool
    end
    
    local function findEquippedSword()
        local character = localPlayer.Character
        if not character then return nil end
        
        local swordTool = character:FindFirstChild(SwordHitboxController.selectedSword)
        if not swordTool then
            for _, tool in pairs(character:GetChildren()) do
                if tool:IsA("Tool") and tool.Name:lower() == SwordHitboxController.selectedSword:lower() then
                    return tool
                end
            end
        end
        
        return swordTool
    end
    
    local function updateSwordHitbox()
        local swordTool = findSwordTool() or findEquippedSword()
        
        if not swordTool then
            return false
        end
        
        local updated = false
        
        for _, descendant in pairs(swordTool:GetDescendants()) do
            if descendant:IsA("BasePart") then
                if descendant.Name:lower():find("hit") or 
                   descendant.Name:lower():find("box") or
                   descendant.Name:lower():find("blade") or
                   descendant.Name:lower():find("sword") or
                   descendant.Name:lower():find("handle") or
                   descendant.Name:lower():find("part") or
                   descendant.Size.Magnitude > 5 then
                    
                    descendant.Size = Vector3.new(SwordHitboxController.hitboxSize, SwordHitboxController.hitboxSize, SwordHitboxController.hitboxSize)
                    updated = true
                    
                    if descendant.Transparency < 0.5 then
                        descendant.Transparency = 0.7
                        descendant.Material = Enum.Material.Neon
                        descendant.Color = Color3.new(1, 0, 0)
                    end
                end
            end
        end
        
        return updated
    end
    
    local function autoSetHitbox()
        while SwordHitboxController.autoSetEnabled do
            if SwordHitboxController.autoSetEnabled then
                local success, result = pcall(function()
                    return updateSwordHitbox()
                end)
                
                if success and result then
                    -- Success notification
                end
            end
            
            task.wait(0.5)
        end
    end
    
    local hitboxSizeSlider = MainTab:AddSlider("HitboxSize", {
        Title = "Hitbox Size",
        Description = "Size of sword hitbox",
        Default = 10,
        Min = 1,
        Max = 2048,
        Rounding = 0,
        Callback = function(value)
            SwordHitboxController.hitboxSize = value
            if SwordHitboxController.autoSetEnabled then
                updateSwordHitbox()
            end
        end
    })
    
    local swordDropdown = MainTab:AddDropdown("SwordDropdown", {
        Title = "Choose Your Sword",
        Values = swordNames,
        Default = "Classic Sword",
        Multi = false,
        Callback = function(value)
            SwordHitboxController.selectedSword = value
            if SwordHitboxController.autoSetEnabled then
                updateSwordHitbox()
            end
        end
    })
    
    local autoSetHitboxToggle = MainTab:AddToggle("AutoSetHitbox", {
        Title = "Auto Set Sword's Hitbox",
        Default = false,
        Callback = function(value)
            SwordHitboxController.autoSetEnabled = value
            if value then
                SwordHitboxController.hitboxUpdateThread = task.spawn(function()
                    autoSetHitbox()
                end)
                Fluent:Notify({
                    Title = "Hitbox",
                    Content = "Auto-set enabled",
                    Duration = 2
                })
            else
                if SwordHitboxController.hitboxUpdateThread then
                    stopThread(SwordHitboxController.hitboxUpdateThread)
                    SwordHitboxController.hitboxUpdateThread = nil
                end
            end
        end
    })
    
    MainTab:AddButton({
        Title = "Manual Update Hitbox",
        Description = "Update hitbox once",
        Callback = function()
            local swordTool = findSwordTool() or findEquippedSword()
            
            if not swordTool then
                Fluent:Notify({
                    Title = "Error",
                    Content = SwordHitboxController.selectedSword .. " not found!",
                    Duration = 3
                })
                return
            end
            
            local updated = updateSwordHitbox()
            
            if updated then
                Fluent:Notify({
                    Title = "Hitbox Updated",
                    Content = "Hitbox size set to " .. SwordHitboxController.hitboxSize .. " for " .. SwordHitboxController.selectedSword,
                    Duration = 3
                })
            else
                Fluent:Notify({
                    Title = "Warning",
                    Content = "No BaseParts found to update in " .. SwordHitboxController.selectedSword,
                    Duration = 3
                })
            end
        end
    })
    
    MainTab:AddButton({
        Title = "Reset Hitbox Sizes",
        Description = "",
        Callback = function()
            SwordHitboxController.autoSetEnabled = false
            if SwordHitboxController.hitboxUpdateThread then
                stopThread(SwordHitboxController.hitboxUpdateThread)
                SwordHitboxController.hitboxUpdateThread = nil
            end
            Fluent:Notify({
                Title = "Hitbox Reset",
                Content = "Hitbox auto-set stopped",
                Duration = 3
            })
        end
    })
    
    -- Spinner Stuff
    MainTab:AddParagraph({
        Title = "Spinner Stuff",
        Content = ""
    })
    
    local SpinController = {
        spinSpeed = 20,
        isSpinning = false,
        currentSpinObject = nil
    }
    
    local function getRoot(character)
        if character and character:IsA("Model") then
            return character:FindFirstChild("HumanoidRootPart") or 
                   character:FindFirstChild("Torso") or 
                   character:FindFirstChild("UpperTorso")
        end
        return nil
    end
    
    local function startSpin(speaker)
        if SpinController.isSpinning then
            Fluent:Notify({
                Title = "Spin",
                Content = "Already spinning!",
                Duration = 2
            })
            return
        end
        
        local character = speaker.Character
        if not character then
            Fluent:Notify({
                Title = "Error",
                Content = "Character not found!",
                Duration = 2
            })
            return
        end
        
        local root = getRoot(character)
        if not root then
            Fluent:Notify({
                Title = "Error",
                Content = "Root part not found!",
                Duration = 2
            })
            return
        end
        
        -- Remove any existing spin objects
        for _, v in pairs(root:GetChildren()) do
            if v.Name == "Spinning" then
                v:Destroy()
            end
        end
        
        -- Create new spin object
        local Spin = Instance.new("BodyAngularVelocity")
        Spin.Name = "Spinning"
        Spin.Parent = root
        Spin.MaxTorque = Vector3.new(0, math.huge, 0)
        Spin.AngularVelocity = Vector3.new(0, SpinController.spinSpeed, 0)
        
        SpinController.currentSpinObject = Spin
        SpinController.isSpinning = true
        
        Fluent:Notify({
            Title = "Spin",
            Content = "Started spinning at speed: " .. SpinController.spinSpeed,
            Duration = 3
        })
    end
    
    local function stopSpin(speaker)
        if not SpinController.isSpinning then
            Fluent:Notify({
                Title = "Spin",
                Content = "Not currently spinning!",
                Duration = 2
            })
            return
        end
        
        local character = speaker.Character
        if character then
            local root = getRoot(character)
            if root then
                for _, v in pairs(root:GetChildren()) do
                    if v.Name == "Spinning" then
                        v:Destroy()
                    end
                end
            end
        end
        
        SpinController.currentSpinObject = nil
        SpinController.isSpinning = false
        
        Fluent:Notify({
            Title = "Spin",
            Content = "Stopped spinning",
            Duration = 3
        })
    end
    
    -- Auto stop spinning on character death/change
    localPlayer.CharacterAdded:Connect(function()
        if SpinController.isSpinning then
            SpinController.isSpinning = false
            SpinController.currentSpinObject = nil
        end
    end)
    
    localPlayer.CharacterRemoving:Connect(function()
        if SpinController.isSpinning then
            SpinController.isSpinning = false
            SpinController.currentSpinObject = nil
        end
    end)
    
    local spinSpeedInput = MainTab:AddInput("SpinSpeed", {
        Title = "Spin Speed",
        Default = "20",
        Placeholder = "Enter spin speed...",
        Numeric = true,
        Finished = false,
        Callback = function(value)
            local speed = tonumber(value)
            if speed and speed > 0 then
                SpinController.spinSpeed = speed
                if SpinController.isSpinning and SpinController.currentSpinObject then
                    SpinController.currentSpinObject.AngularVelocity = Vector3.new(0, speed, 0)
                end
                Fluent:Notify({
                    Title = "Spin Speed",
                    Content = "Spin speed set to: " .. speed,
                    Duration = 2
                })
            else
                Fluent:Notify({
                    Title = "Error",
                    Content = "Spin speed must be greater than 0!",
                    Duration = 3
                })
            end
        end
    })
    
    MainTab:AddButton({
        Title = "Spin",
        Description = "Start spinning",
        Callback = function()
            startSpin(localPlayer)
        end
    })
    
    MainTab:AddButton({
        Title = "Unspin",
        Description = "Stop spinning",
        Callback = function()
            stopSpin(localPlayer)
        end
    })
    
    local spinStatusParagraph = MainTab:AddParagraph({
        Title = "Spin Status:",
        Content = "Not spinning"
    })
    
    MainTab:AddToggle("AutoUpdateSpinStatus", {
        Title = "Auto Update Spin Status",
        Default = false,
        Callback = function(value)
            if value then
                local connection
                connection = RunService.Heartbeat:Connect(function()
                    if SpinController.isSpinning then
                        spinStatusParagraph:SetDesc("Spin Status: Spinning at speed " .. SpinController.spinSpeed)
                    else
                        spinStatusParagraph:SetDesc("Spin Status: Not spinning")
                    end
                end)
            end
        end
    })
    
    -- Rest/Others Feature
    MainTab:AddParagraph({
        Title = "Rest/Others Feature",
        Content = ""
    })
    
    local function teleportToRandomNPC()
        if _G.isTeleporting then return end
        _G.isTeleporting = true
        
        task.spawn(function()
            while _G.isTeleporting do
                local npcFolder = workspace:WaitForChild("#GAME"):WaitForChild("Folders"):WaitForChild("VisibleInstances"):WaitForChild("HumanoidFolder"):WaitForChild("NPCFolder")
                local npcs = {}
                
                for _, npc in pairs(npcFolder:GetChildren()) do
                    if npc:IsA("Model") and npc:FindFirstChild("HumanoidRootPart") then
                        table.insert(npcs, npc)
                    end
                end
                
                if #npcs > 0 then
                    local randomNPC = npcs[math.random(1, #npcs)]
                    local npcPosition = randomNPC.HumanoidRootPart.Position
                    local character = localPlayer.Character
                    if character and character:FindFirstChild("HumanoidRootPart") then
                        character:SetPrimaryPartCFrame(CFrame.new(npcPosition + Vector3.new(0, 5, 0)))
                    end
                end
                
                task.wait(0.2)
            end
        end)
    end
    
    local function stopTeleporting()
        _G.isTeleporting = false
    end
    
    local autoTeleportToggle = MainTab:AddToggle("AutoTeleportNPC", {
        Title = "Auto Teleport To NPC's",
        Default = false,
        Callback = function(value)
            if value then
                teleportToRandomNPC()
            else
                stopTeleporting()
            end
            Fluent:Notify({
                Title = "Auto Teleport",
                Content = value and "Enabled" or "Disabled",
                Duration = 2
            })
        end
    })
    
    -- Auto Use Sword
    local swordList = {
        "Balloon Sword",
        "Classic Sword", 
        "Lamppost",
        "King Slayer",
        "Pine Tree",
        "Soulreaper",
        "Billboard"
    }
    
    local function autoUseSword()
        if _G.isUsingSword then return end
        _G.isUsingSword = true
        
        local connection
        connection = RunService.Heartbeat:Connect(function()
            if not _G.isUsingSword then
                if connection then
                    connection:Disconnect()
                end
                return
            end
            
            local player = localPlayer
            local character = player.Character
            if not character then return end

            local foundSword = nil
            
            for _, swordName in ipairs(swordList) do
                local sword = character:FindFirstChild(swordName) or player.Backpack:FindFirstChild(swordName)
                if sword then
                    foundSword = sword
                    break
                end
            end

            if foundSword then
                if foundSword.Parent == player.Backpack then
                    foundSword.Parent = character
                end
                
                local tool = foundSword
                if tool:IsA("Tool") then
                    tool:Activate()
                    pcall(function() tool:InvokeServer("Activate") end)
                    pcall(function() tool:InvokeServer("MouseClick") end)
                    pcall(function() tool:InvokeServer("Click") end)
                end
            end
        end)
    end
    
    local function stopAutoUsingSword()
        _G.isUsingSword = false
    end
    
    local autoUseSwordToggle = MainTab:AddToggle("AutoUseSword", {
        Title = "Auto Use Sword",
        Default = false,
        Callback = function(value)
            if value then
                autoUseSword()
            else
                stopAutoUsingSword()
            end
            Fluent:Notify({
                Title = "Auto Sword",
                Content = value and "Enabled" or "Disabled",
                Duration = 2
            })
        end
    })
    
-- Variables to manage auto using the sword (updated for Fluent)
local isUsingHatred = false
local HatredConnection = nil

-- List of all swords to auto use (you can expand this list)
local HatredList = {
    "Hatred",
    -- Add more swords here if needed, for example:
    -- "Void Blade",
    -- "Dark Saber",
    -- "Cursed Sword"
}

-- Function to start auto using the sword every 0.1 seconds
local function autoUseHatred()
    if isUsingHatred then return end  -- Prevent starting multiple loops

    isUsingHatred = true

    HatredConnection = game:GetService("RunService").Heartbeat:Connect(function()
        if not isUsingHatred then return end  -- Safety check
        
        local player = game.Players.LocalPlayer
        local character = player.Character
        if not character then return end

        -- Check both character and backpack for all swords in the list
        local foundHatred = nil
        
        for _, hatredName in ipairs(HatredList) do
            local hatred = character:FindFirstChild(hatredName) or player.Backpack:FindFirstChild(hatredName)
            if hatred then
                foundHatred = hatred
                break  -- Use the first sword found
            end
        end

        -- If a sword was found, activate it
        if foundHatred then
            -- Make sure sword is equipped before activating
            if foundHatred.Parent == player.Backpack then
                foundHatred.Parent = character
                task.wait(0.05) -- Small delay after equipping
            end
            
            -- Use multiple activation methods for better compatibility
            if foundHatred:IsA("Tool") then
                -- Method 1: Activate() function
                pcall(function()
                    foundHatred:Activate()
                end)
                
                -- Method 2: Try to find and use remote events
                pcall(function()
                    -- Look for remote events in the tool
                    for _, descendant in ipairs(foundHatred:GetDescendants()) do
                        if descendant:IsA("RemoteEvent") then
                            if descendant.Name == "Activate" or descendant.Name == "MouseClick" or descendant.Name == "Click" then
                                descendant:FireServer()
                            end
                        end
                    end
                end)
                
                -- Method 3: Try to invoke server methods
                pcall(function()
                    foundHatred:InvokeServer("Activate")
                end)
                pcall(function()
                    foundHatred:InvokeServer("MouseClick")
                end)
                pcall(function()
                    foundHatred:InvokeServer("Click")
                end)
            end
        end
    end)
end

-- Function to stop auto using the sword
local function stopAutoUsingHatred()
    isUsingHatred = false
    if HatredConnection then
        HatredConnection:Disconnect()
        HatredConnection = nil
    end
end

-- Cleanup when player leaves
game.Players.LocalPlayer.CharacterRemoving:Connect(function()
    stopAutoUsingHatred()
end)

-- Auto Use Hatred Tool Toggle (Fluent Hub)
local autoHatredToggle = Tabs.Main:AddToggle("AutoHatredToggle", {
    Title = "Auto Use Hatred Tool",
    Description = "Automatically activates hatred every 0.1 seconds",
    Default = false,
    Callback = function(Value)
        if Value then
            -- Start using the sword if toggle is enabled
            autoUseHatred()
        else
            -- Stop the loop if the toggle is disabled
            stopAutoUsingHatred()
        end
    end
})

    -- Auto Bring NPCs
    local function bringNoobsAndWerewolves()
        if _G.isBringing then return end
        _G.isBringing = true
        
        task.spawn(function()
            while _G.isBringing do
                local character = localPlayer.Character
                if character then
                    local humanoidRootPart = character:FindFirstChild("HumanoidRootPart")
                    
                    if humanoidRootPart then
                        local npcFolder = workspace:WaitForChild("#GAME"):WaitForChild("Folders"):WaitForChild("VisibleInstances"):WaitForChild("HumanoidFolder"):WaitForChild("NPCFolder")
                        for _, npc in pairs(npcFolder:GetChildren()) do
                            if npc:IsA("Model") and npc:FindFirstChild("HumanoidRootPart") then
                                local direction = humanoidRootPart.CFrame.LookVector
                                local newPosition = humanoidRootPart.Position + direction * 10
                                npc:SetPrimaryPartCFrame(CFrame.new(newPosition))
                            end
                        end
                    end
                end
                task.wait(0.01)
            end
        end)
    end
    
    local function stopBringing()
        _G.isBringing = false
    end
    
    local autoBringToggle = MainTab:AddToggle("AutoBringNPC", {
        Title = "Auto Bring NPC's",
        Default = false,
        Callback = function(value)
            if value then
                bringNoobsAndWerewolves()
            else
                stopBringing()
            end
            Fluent:Notify({
                Title = "Auto Bring",
                Content = value and "Enabled" or "Disabled",
                Duration = 2
            })
        end
    })
    
    -- Auto Delete Models
    local function deleteAllModels()
        local deletedCount = 0
        
        -- Updated path to match your game structure
        local npcFolder = workspace:FindFirstChild("#GAME") and 
                         workspace["#GAME"]:FindFirstChild("Folders") and 
                         workspace["#GAME"].Folders:FindFirstChild("VisibleInstances") and 
                         workspace["#GAME"].Folders.VisibleInstances:FindFirstChild("HumanoidFolder") and 
                         workspace["#GAME"].Folders.VisibleInstances.HumanoidFolder:FindFirstChild("NPCFolder")
        
        if not npcFolder then return 0 end
        
        local children = npcFolder:GetChildren()
        
        for _, child in ipairs(children) do
            if not _G.isAutoDeleteModels then break end
            
            if child:IsA("Model") then
                local deleteSuccess = pcall(function()
                    child:Destroy()
                end)
                
                if deleteSuccess then
                    deletedCount = deletedCount + 1
                end
            end
            
            if deletedCount % 10 == 0 then
                task.wait()
            end
        end
        
        return deletedCount
    end
    
    local function autoDeleteModels()
        while _G.isAutoDeleteModels do
            if _G.isAutoDeleteModels then
                local deletedCount = deleteAllModels()
                
                if deletedCount > 0 and _G.isAutoDeleteModels then
                    task.spawn(function()
                        Fluent:Notify({
                            Title = "Models Deleted",
                            Content = "Deleted " .. deletedCount .. " models",
                            Duration = 1
                        })
                    end)
                end
                
                task.wait(0.2)
            end
        end
    end
    
    local autoDeleteToggle = MainTab:AddToggle("AutoDeleteModels", {
        Title = "Auto Delete All NPC's",
        Default = false,
        Callback = function(value)
            _G.isAutoDeleteModels = value
            if value then
                task.spawn(function()
                    autoDeleteModels()
                end)
                Fluent:Notify({
                    Title = "Auto Delete",
                    Content = "Enabled",
                    Duration = 2
                })
            else
                Fluent:Notify({
                    Title = "Auto Delete",
                    Content = "Disabled",
                    Duration = 2
                })
            end
        end
    })
    
local RunService = game:GetService("RunService")
local Workspace = game:GetService("Workspace")

-- State variables
local spawnLoopConnection = nil
local isSpawningEnabled = false

-- Function to start the spawning loop
local function startSpawningLoop()
    if spawnLoopConnection then
        spawnLoopConnection:Disconnect()
        spawnLoopConnection = nil
    end
    
    spawnLoopConnection = RunService.Heartbeat:Connect(function()
        if not isSpawningEnabled then
            spawnLoopConnection:Disconnect()
            spawnLoopConnection = nil
            return
        end
        
        local success, error = pcall(function()
            workspace:WaitForChild("#GAME"):WaitForChild("Globals"):WaitForChild("Comms"):WaitForChild("Remote"):WaitForChild("Functions"):WaitForChild("SpawnNoobOnPad"):InvokeServer()
        end)
        
        if not success then
            warn("Failed to spawn noob:", error)
            isSpawningEnabled = false
            spawnLoopConnection:Disconnect()
            spawnLoopConnection = nil
        end
        
        task.wait(0.01) -- Wait 0.01 seconds between invocations
    end)
end

-- Function to stop the spawning loop
local function stopSpawningLoop()
    isSpawningEnabled = false
    if spawnLoopConnection then
        spawnLoopConnection:Disconnect()
        spawnLoopConnection = nil
    end
end

-- ========== FLUENT HUB UI FOR AUTO SPAWN NOOBS ==========
Tabs.Main:AddToggle("AutoSpawnToggle", {
    Title = "Auto Spawn Noobs From Pad",
    Description = "Automatically spawns noobs from the spawn pad",
    Default = false,
    Callback = function(Value)
        isSpawningEnabled = Value
        
        if Value then
            task.spawn(function()
                startSpawningLoop()
            end)
        else
            stopSpawningLoop()
        end
    end
})
    
    -- Auto Teleport/Collect/Click Stuff
    MainTab:AddParagraph({
        Title = "Auto Teleport/Collect/Click Stuff",
        Content = ""
    })
    
-- Egg Collection System (Optimized for Auto Teleport) - FLUENT HUB VERSION
    local EggSystem = {
        Workspace = game:GetService("Workspace"),
        Players = game:GetService("Players"),
        RunService = game:GetService("RunService"),
        VirtualInputManager = game:GetService("VirtualInputManager"),
        
        Player = nil,
        
        -- Feature toggles
        isAutoSetHoldDuration = false,
        isTeleportToEggs = false,
        isAutoSpamKey = false,
        isEggNotifier = false,
        
        -- Threads
        autoSetHoldDurationThread = nil,
        teleportToEggsThread = nil,
        spamKeyThread = nil,
        
        -- Performance optimization
        cachedEggPrompts = {},
        cachedEggs = {},
        lastScanTime = 0,
        SCAN_INTERVAL = 0.1,
        lastTeleportTime = 0,
        TELEPORT_COOLDOWN = 0.01,
        lastPromptTime = 0,
        PROMPT_COOLDOWN = 0.01,
        
        -- Performance monitoring
        frameCount = 0,
        lastFPSUpdate = tick(),
        currentFPS = 60,
        
        -- Egg spawn detection
        eggDetectionConnection = nil,
        detectedEggs = {}
    }

    -- Initialize
    EggSystem.Player = EggSystem.Players.LocalPlayer

    -- Exact egg names from the list (only these will be collected)
    local VALID_EGG_NAMES = {
        -- Small/Big variants
        "Basic Egg",
        "Small Egg",
        "Smaller Egg",
        "Smallest Egg",
        "Fat Egg",
        "Fatter Egg",
        "Fattest Egg",
        "Tall Egg",
        "Taller Egg",
        "Tallest Egg",
        "Big Egg",
        "Baby Egg",
        "Bomb Egg",
        "Skinny Egg",
        "Squished Egg",
        "Paper Egg",
        "Squashed Egg",
        "Wide Egg",
        "Flying Egg",
        "Zombie Egg",
        "Mega Egg",
        "Nuke Egg",
        "Bombarder Egg",
        "Dark Egg",
        "Micro Egg",
        "OOOOOOMEGA Egg",
        "Poop Egg",
        
        -- Precious metal eggs
        "Silver Egg",
        "Golden Egg",
        "Diamond Egg",
        "Emerald Egg",
        "Ruby Egg",
        "Amethyst Egg",
        
        -- Bigger variants
        "Bigger Egg",
        "Biggest Egg",
        "Biggest Bigger Egg",
        "Biggester Egg",
        "Monster Egg",
        "Enraged Egg",
        "Rock Egg",
        "Nasty Egg",
        "Moai Egg",
        "Cracked Egg",
        "Bas Egg",
        "Raffie Egg",
        "Ghost Egg",
        "BULLKER Egg",
        "Pouwker Egg",
        "Berend Egg",
        "Chicken Egg",
        
        -- BOSS and special
        "BOSS Egg",
        "Delicious Egg",
        "Burnt Egg",
        "OOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOMEGAAAAAAAAAAAAHHHHHHHHHHHH Egg",
        "Dead Egg",
        "Hellfire Egg",
        "Invincible Egg",
        "Invisible Egg",
        "Metal Egg",
        "Santa Egg",
        "Fr Egg",
        "Rotten Egg",
        "SigmaBloxian Egg",
        "Stinky Egg",
        "Jack Egg",
        "Buoyant Egg",
        "Primo Egg",
        "Werewolf Egg",
        "Boeman Egg",
        "Mighty Egg",
        "Old Egg",
        "Bacon Egg",
        "Ginger Egg",
        "Headless Egg",
        "Skeleton Egg",
        "Elf Egg",
        "Pouwk Egg",
        "BULL Egg",
        "Turd Egg",
        "Co Egg",
        "Nano Egg",
        "Not Egg",
        "R6 Egg",
        "Bunny Egg",
        "Banana Egg",
        "Bananade Egg",
        "Glitch Egg",
        "Error Egg",
        "Jumperino Egg",
        "Cheese Egg",
        "Greasy Egg",
        "Rusty Egg",
        "Hateful Egg",
        "Happy Egg",
        "Party Egg",
        "Yoss Egg",
        "Cato Egg",
        "Noob Egg"
    }

    -- Create a lookup table for faster checking
    local VALID_EGG_LOOKUP = {}
    for _, eggName in ipairs(VALID_EGG_NAMES) do
        VALID_EGG_LOOKUP[eggName] = true
    end

    -- Function to check if object is a REAL egg (exact name match only)
    function EggSystem:isValidEgg(obj)
        if not obj or not obj.Parent then
            return false
        end
        
        local isValidType = obj:IsA("BasePart") or obj:IsA("Model") or obj:IsA("MeshPart")
        if not isValidType then
            return false
        end
        
        -- Check if the exact name is in our list
        if VALID_EGG_LOOKUP[obj.Name] then
            return true
        end
        
        return false
    end

    -- Function to monitor FPS and adjust performance
    function EggSystem:monitorPerformance()
        self.frameCount = self.frameCount + 1
        local currentTime = tick()
        
        if currentTime - self.lastFPSUpdate >= 1 then
            self.currentFPS = self.frameCount
            self.frameCount = 0
            self.lastFPSUpdate = currentTime
            
            if self.currentFPS < 30 then
                self.SCAN_INTERVAL = 0.5
                self.TELEPORT_COOLDOWN = 0.02
            else
                self.SCAN_INTERVAL = 0.1
                self.TELEPORT_COOLDOWN = 0.01
            end
        end
    end

    -- Function to safely stop threads
    function EggSystem:stopThread(thread)
        if thread then
            task.cancel(thread)
            return nil
        end
        return nil
    end

    -- Function to get valid egg position (checks if egg still exists)
    function EggSystem:getValidEggPosition(egg)
        if not egg or not egg.Parent then
            return nil
        end
        
        local success, position = pcall(function()
            if egg:IsA("Model") then
                if egg.PrimaryPart and egg.PrimaryPart.Parent then
                    return egg.PrimaryPart.Position
                else
                    local firstPart = egg:FindFirstChildWhichIsA("BasePart")
                    if firstPart and firstPart.Parent then
                        return firstPart.Position
                    end
                end
            else
                -- MeshPart or BasePart
                if egg.Parent then
                    return egg.Position
                end
            end
            return nil
        end)
        
        return success and position or nil
    end

    -- FAST function to get fresh eggs from GeneralFolder
    function EggSystem:getFreshEggs()
        self.cachedEggs = {}
        
        local generalFolder = self.Workspace:FindFirstChild("#GAME") and 
                             self.Workspace["#GAME"]:FindFirstChild("Folders") and 
                             self.Workspace["#GAME"].Folders:FindFirstChild("GeneralFolder")
        
        if generalFolder then
            -- Fast scan through all children
            for _, egg in pairs(generalFolder:GetChildren()) do
                if self:isValidEgg(egg) then -- Use the new isValidEgg function
                    local position = self:getValidEggPosition(egg)
                    if position then
                        table.insert(self.cachedEggs, {
                            object = egg,
                            position = position,
                            name = egg.Name
                        })
                    end
                end
            end
        end
        
        self.lastScanTime = tick()
        return self.cachedEggs
    end

    -- OPTIMIZED: Function to get ProximityPrompts without lag
    function EggSystem:getEggProximityPrompts()
        local currentTime = tick()
        
        -- Only rescan if cache is empty or enough time has passed
        if #self.cachedEggPrompts == 0 or (currentTime - self.lastScanTime) > 5.0 then
            self.cachedEggPrompts = {}
            
            -- Only scan GeneralFolder
            local generalFolder = self.Workspace:FindFirstChild("#GAME") and 
                                 self.Workspace["#GAME"]:FindFirstChild("Folders") and 
                                 self.Workspace["#GAME"].Folders:FindFirstChild("GeneralFolder")
            
            if generalFolder then
                -- Limit scanning to prevent lag
                local scanCount = 0
                for _, egg in pairs(generalFolder:GetChildren()) do
                    if scanCount > 50 then break end -- Safety limit
                    
                    if self:isValidEgg(egg) then -- Use the new isValidEgg function
                        -- Only check first few descendants to prevent lag
                        local prompt = egg:FindFirstChildWhichIsA("ProximityPrompt")
                        if prompt and prompt.Parent then
                            table.insert(self.cachedEggPrompts, prompt)
                        else
                            -- Quick check for prompts in descendants (limited)
                            local descendants = egg:GetDescendants()
                            for i = 1, math.min(10, #descendants) do -- Limit to 10 descendants
                                local descendant = descendants[i]
                                if descendant:IsA("ProximityPrompt") then
                                    table.insert(self.cachedEggPrompts, descendant)
                                    break -- Only need one prompt per egg
                                end
                            end
                        end
                        scanCount = scanCount + 1
                    end
                end
            end
            
            self.lastScanTime = currentTime
        end
        
        return self.cachedEggPrompts
    end

    -- OPTIMIZED: Function to auto set ProximityPrompts without lag
    function EggSystem:autoSetHoldDuration()
        while self.isAutoSetHoldDuration do
            -- Get fresh prompts every time to ensure we catch new eggs
            local eggPrompts = self:getEggProximityPrompts()
            
            if #eggPrompts > 0 then
                -- Process prompts in batches to prevent lag
                local processed = 0
                for _, prompt in ipairs(eggPrompts) do
                    if not self.isAutoSetHoldDuration then break end
                    
                    -- Check if prompt and its parent still exist
                    if prompt and prompt.Parent then
                        -- Always update to ensure it's set to 0 (no condition checks)
                        prompt.HoldDuration = 0
                        prompt.Enabled = true
                        prompt.RequiresLineOfSight = false
                        
                        processed = processed + 1
                        -- Small yield every 5 prompts to prevent freezing but still be fast
                        if processed % 5 == 0 then
                            task.wait()
                        end
                    end
                end
            end
            
            -- Wait between scans
            task.wait(0.5)
        end
    end

    -- ULTRA FAST: Function to teleport to eggs - optimized for AFK farming
    function EggSystem:teleportToEggs()
        while self.isTeleportToEggs do
            local character = self.Player.Character
            if not character then
                task.wait(0.1)
                continue
            end
            
            local humanoidRootPart = character:FindFirstChild("HumanoidRootPart")
            if not humanoidRootPart then
                task.wait(0.1)
                continue
            end
            
            -- Clear cache and find fresh eggs in GeneralFolder
            self.cachedEggs = {}
            
            -- Search specifically in GeneralFolder
            local generalFolder = self.Workspace:FindFirstChild("#GAME") and 
                                 self.Workspace["#GAME"]:FindFirstChild("Folders") and 
                                 self.Workspace["#GAME"].Folders:FindFirstChild("GeneralFolder")
            
            if generalFolder then
                -- Scan all children of GeneralFolder
                for _, egg in pairs(generalFolder:GetChildren()) do
                    if not self.isTeleportToEggs then break end
                    
                    -- Use your isValidEgg function to check if it's a REAL egg (exact name match)
                    if self:isValidEgg(egg) then
                        local position = self:getValidEggPosition(egg)
                        if position then
                            table.insert(self.cachedEggs, {
                                object = egg,
                                position = position,
                                name = egg.Name
                            })
                        end
                    end
                end
            end
            
            if #self.cachedEggs > 0 then
                -- Find the closest valid egg
                local closestEgg = nil
                local closestDistance = math.huge
                
                for _, eggData in ipairs(self.cachedEggs) do
                    if not self.isTeleportToEggs then break end
                    
                    -- Quick check if egg still exists
                    if eggData.object and eggData.object.Parent then
                        local freshPosition = self:getValidEggPosition(eggData.object)
                        if freshPosition then
                            local distance = (humanoidRootPart.Position - freshPosition).Magnitude
                            if distance < closestDistance then
                                closestDistance = distance
                                closestEgg = eggData
                            end
                        end
                    end
                end
                
                if closestEgg then
                    -- Debug: Print egg name to verify filtering is working
                    print("Teleporting to: " .. closestEgg.name)
                    
                    -- Instant teleport to the closest egg
                    local success = pcall(function()
                        humanoidRootPart.CFrame = CFrame.new(closestEgg.position + Vector3.new(0, 3, 0))
                    end)
                    
                    if not success then
                        task.wait(0.01)
                    end
                end
            end
            
            -- Minimal wait between scans
            task.wait(0.1)
        end
    end

    -- Function to auto spam E key
    function EggSystem:autoSpamKey()
        while self.isAutoSpamKey do
            if self.isAutoSpamKey then
                self.VirtualInputManager:SendKeyEvent(true, Enum.KeyCode.E, false, game)
                task.wait(0.01)
                self.VirtualInputManager:SendKeyEvent(false, Enum.KeyCode.E, false, game)
                task.wait(0.01)
            end
        end
    end

    -- Function to handle new egg spawns (egg notifier)
    function EggSystem:onEggSpawned(descendant)
        if not self.isEggNotifier then return end
        
        -- Only check descendants that are in GeneralFolder
        local isInGeneralFolder = false
        local current = descendant
        while current do
            if current.Name == "GeneralFolder" and 
               current.Parent and 
               current.Parent.Name == "Folders" and
               current.Parent.Parent and 
               current.Parent.Parent.Name == "#GAME" then
                isInGeneralFolder = true
                break
            end
            current = current.Parent
        end
        
        if isInGeneralFolder and self:isValidEgg(descendant) then
            local eggName = descendant.Name
            local eggId = tostring(descendant:GetFullName())
            
            -- Check if we've already detected this egg
            if not self.detectedEggs[eggId] then
                self.detectedEggs[eggId] = true
                
                -- Send Fluent notification
                Fluent:Notify({
                    Title = "Egg Spawned!",
                    Content = eggName .. " has spawned in GeneralFolder!",
                    Duration = 5
                })
                
                -- Optional: Print to console for debugging
                warn("EGG SPAWNED: " .. eggName .. " at " .. tostring(descendant:GetFullName()))
            end
        end
    end

    -- Function to start egg spawn detection
    function EggSystem:startEggDetection()
        if self.eggDetectionConnection then
            self.eggDetectionConnection:Disconnect()
        end
        
        -- Clear previous detections
        self.detectedEggs = {}
        
        -- Connect to descendant added event
        self.eggDetectionConnection = workspace.DescendantAdded:Connect(function(descendant)
            self:onEggSpawned(descendant)
        end)
        
        -- Also check for existing eggs in GeneralFolder when starting
        task.spawn(function()
            task.wait(1) -- Wait a bit for game to load
            
            local generalFolder = workspace:FindFirstChild("#GAME") and 
                                 workspace["#GAME"]:FindFirstChild("Folders") and 
                                 workspace["#GAME"].Folders:FindFirstChild("GeneralFolder")
            
            if generalFolder then
                local eggCount = 0
                for _, egg in pairs(generalFolder:GetChildren()) do
                    if self:isValidEgg(egg) then -- Use the new isValidEgg function
                        local eggId = tostring(egg:GetFullName())
                        if not self.detectedEggs[eggId] then
                            self.detectedEggs[eggId] = true
                            eggCount = eggCount + 1
                        end
                    end
                end
                
                if eggCount > 0 then
                    Fluent:Notify({
                        Title = "Egg Detected",
                        Content = "Found " .. eggCount .. " eggs already in GeneralFolder!",
                        Duration = 3
                    })
                end
            end
        end)
    end

    -- Function to stop egg spawn detection
    function EggSystem:stopEggDetection()
        if self.eggDetectionConnection then
            self.eggDetectionConnection:Disconnect()
            self.eggDetectionConnection = nil
        end
        self.detectedEggs = {}
    end

    -- Function to restart all active features after respawn
    function EggSystem:restartFeatures()
        -- Minimal wait for character to load
        task.wait(1.0)
        
        -- Clear cache on respawn
        self.cachedEggPrompts = {}
        self.cachedEggs = {}
        self.lastScanTime = 0
        
        -- Restart features if they were active
        if self.isAutoSetHoldDuration then
            self.autoSetHoldDurationThread = self:stopThread(self.autoSetHoldDurationThread)
            task.wait(0.5) -- Small delay before restarting
            self.autoSetHoldDurationThread = task.spawn(function()
                self:autoSetHoldDuration()
            end)
        end
        
        if self.isTeleportToEggs then
            self.teleportToEggsThread = self:stopThread(self.teleportToEggsThread)
            task.wait(0.5) -- Small delay before restarting
            self.teleportToEggsThread = task.spawn(function()
                self:teleportToEggs()
            end)
        end
        
        if self.isAutoSpamKey then
            self.spamKeyThread = self:stopThread(self.spamKeyThread)
            task.wait(0.5) -- Small delay before restarting
            self.spamKeyThread = task.spawn(function()
                self:autoSpamKey()
            end)
        end
        
        if self.isEggNotifier then
            self:stopEggDetection()
            task.wait(0.5) -- Small delay before restarting
            self:startEggDetection()
        end
    end

    -- Connect to character added event for respawn handling
    EggSystem.Player.CharacterAdded:Connect(function(character)
        EggSystem:restartFeatures()
    end)

    -- ========== FLUENT HUB UI ELEMENTS ==========

    -- Auto Set Instant CD To Eggs Toggle
    local autoSetHoldToggle = MainTab:AddToggle("AutoSetHoldToggle", {
        Title = "Auto Set Instant CD To Eggs",
        Default = false,
        Callback = function(value)
            EggSystem.isAutoSetHoldDuration = value
            if value then
                -- Clear cache and start immediately
                EggSystem.cachedEggPrompts = {}
                EggSystem.lastScanTime = 0
                
                -- Force one immediate scan
                EggSystem:getEggProximityPrompts()
                
                EggSystem.autoSetHoldDurationThread = task.spawn(function()
                    EggSystem:autoSetHoldDuration()
                end)
                
                Fluent:Notify({
                    Title = "Egg System",
                    Content = "Auto Set Instant CD Enabled",
                    Duration = 2
                })
            else
                if EggSystem.autoSetHoldDurationThread then
                    EggSystem:stopThread(EggSystem.autoSetHoldDurationThread)
                    EggSystem.autoSetHoldDurationThread = nil
                end
            end
        end
    })

    -- Auto Teleport To Eggs Toggle
    local autoTeleportToggle = MainTab:AddToggle("AutoTeleportToggle", {
        Title = "Auto Teleport To Eggs",
        Default = false,
        Callback = function(value)
            EggSystem.isTeleportToEggs = value
            if value then
                EggSystem.teleportToEggsThread = task.spawn(function()
                    EggSystem:teleportToEggs()
                end)
                
                Fluent:Notify({
                    Title = "Egg System",
                    Content = "Auto Teleport Enabled",
                    Duration = 2
                })
            else
                EggSystem.teleportToEggsThread = EggSystem:stopThread(EggSystem.teleportToEggsThread)
            end
        end
    })

    -- Auto Notify Spawned Eggs Toggle
    local eggNotifierToggle = MainTab:AddToggle("EggNotifierToggle", {
        Title = "Auto Notify Spawned Eggs",
        Default = false,
        Callback = function(value)
            EggSystem.isEggNotifier = value
            
            if value then
                EggSystem:startEggDetection()
                Fluent:Notify({
                    Title = "Egg Notifier",
                    Content = "Egg spawn notifications enabled",
                    Duration = 2
                })
            else
                EggSystem:stopEggDetection()
            end
        end
    })

    -- Check For Existing Eggs Button (FIXED)
    MainTab:AddButton({
        Title = "Check For Existing Eggs",
        Description = "Count eggs currently in GeneralFolder",
        Callback = function()
            local eggCount = 0
            local generalFolder = workspace:FindFirstChild("#GAME") and 
                                 workspace["#GAME"]:FindFirstChild("Folders") and 
                                 workspace["#GAME"].Folders:FindFirstChild("GeneralFolder")
            
            if generalFolder then
                for _, egg in pairs(generalFolder:GetChildren()) do
                    if EggSystem:isValidEgg(egg) then
                        eggCount = eggCount + 1
                        print("Found egg: " .. egg.Name)
                    end
                end
            end
            
            Fluent:Notify({
                Title = "Egg Check",
                Content = "Found " .. eggCount .. " eggs in GeneralFolder",
                Duration = 3
            })
        end
    })

    -- Clear Eggs Detection History Button (FIXED)
    MainTab:AddButton({
        Title = "Clear Eggs Detection History",
        Description = "Clear egg detection memory",
        Callback = function()
            EggSystem.detectedEggs = {}
            Fluent:Notify({
                Title = "Egg Notifier",
                Content = "Egg detection history cleared!",
                Duration = 3
            })
        end
    })

    -- Auto Spam E Key Prompt Toggle
    local spamKeyToggle = MainTab:AddToggle("SpamKeyToggle", {
        Title = "Auto Spam E Key Prompt",
        Default = false,
        Callback = function(value)
            EggSystem.isAutoSpamKey = value
            if value then
                EggSystem.spamKeyThread = task.spawn(function()
                    EggSystem:autoSpamKey()
                end)
                
                Fluent:Notify({
                    Title = "Egg System",
                    Content = "Auto Spam E Key Enabled",
                    Duration = 2
                })
            else
                EggSystem.spamKeyThread = EggSystem:stopThread(EggSystem.spamKeyThread)
            end
        end
    })
end

do
    local EventTab = Tabs.Event

-- ========== Helper Functions ==========

-- Create Billboard ESP
local function createESP(parent, name, text, color)
    local esp = Instance.new("BillboardGui")
    esp.Name = name
    esp.Parent = parent
    esp.Adornee = parent
    esp.Size = UDim2.new(0, 150, 0, 40)
    esp.StudsOffset = Vector3.new(0, 2, 0)
    esp.AlwaysOnTop = true
    esp.ResetOnSpawn = false
    esp.MaxDistance = 1000

    local label = Instance.new("TextLabel")
    label.Parent = esp
    label.BackgroundTransparency = 1
    label.Size = UDim2.new(1, 0, 1, 0)
    label.TextSize = 16
    label.Font = Enum.Font.FredokaOne
    label.TextColor3 = color
    label.TextStrokeTransparency = 0.2
    label.Text = text

    return label
end

-- Create Highlight
local function createHighlight(parent, color)
    local highlight = Instance.new("Highlight")
    highlight.Parent = parent
    highlight.FillColor = color
    highlight.FillTransparency = 0.5
    highlight.OutlineColor = color
    highlight.OutlineTransparency = 0
    highlight.DepthMode = Enum.HighlightDepthMode.AlwaysOnTop
    return highlight
end

-- Clean ESP function
local function cleanESP(espName)
    for _, v in pairs(workspace:GetDescendants()) do
        if v:IsA("BillboardGui") and v.Name == espName then
            v:Destroy()
        end
        if v:IsA("Highlight") then
            v:Destroy()
        end
    end
end

-- ========== Halloween Section ==========
    EventTab:AddParagraph({
        Title = "Halloween Stuff",
        Content = ""
    })

local SoulESP = false
EventTab:AddToggle("SoulsESP", {
    Title = "Souls ESP",
    Default = false,
    Callback = function(Value)
        SoulESP = Value
        if not Value then
            cleanESP("SoulESP")
            return
        end

        task.spawn(function()
            while SoulESP and task.wait(1) do
                local dumpFolder = workspace:FindFirstChild("#GAME") and 
                                 workspace["#GAME"]:FindFirstChild("Folders") and 
                                 workspace["#GAME"].Folders:FindFirstChild("DumpFolder")

                if dumpFolder then
                    for _, item in pairs(dumpFolder:GetDescendants()) do
                        if item:IsA("BasePart") and item.Name == "Handle" then
                            if not item:FindFirstChild("SoulESP") then
                                createESP(item, "SoulESP", "Soul", Color3.fromRGB(0, 255, 255))
                            end
                            
                            if not item:FindFirstChildOfClass("Highlight") then
                                createHighlight(item, Color3.fromRGB(0, 255, 255))
                            end
                        end
                    end
                end
            end
        end)
    end
})

-- ========== Christmas Section ==========
    EventTab:AddParagraph({
        Title = "Christmas Stuff",
        Content = ""
    })

-- HitBox Size System
_G.HitBoxSize = 100
_G.AutoApplyHitBoxSize = false
local autoApplyConnection = nil

local function findGeneralFolder()
    local success, generalFolder = pcall(function()
        return workspace["#GAME"]:WaitForChild("Folders"):WaitForChild("GeneralFolder")
    end)
    
    if not success then
        local gameFolder = workspace:WaitForChild("#GAME", 5)
        if not gameFolder then return nil end
        
        local foldersFolder = gameFolder:WaitForChild("Folders", 5)
        if not foldersFolder then return nil end
        
        generalFolder = foldersFolder:WaitForChild("GeneralFolder", 5)
    end
    
    return generalFolder
end

local function resizeHitBoxes(size)
    local generalFolder = findGeneralFolder()
    if not generalFolder then return false end
    
    local hitBoxCount = 0
    for _, model in ipairs(generalFolder:GetChildren()) do
        if model:IsA("Model") then
            local hitBox = model:FindFirstChild("HitBox")
            if hitBox and hitBox:IsA("BasePart") then
                hitBoxCount = hitBoxCount + 1
                pcall(function()
                    hitBox.Size = Vector3.new(size, size, size)
                end)
            end
        end
    end
    
    return hitBoxCount > 0
end

local function startAutoApply()
    if autoApplyConnection then
        autoApplyConnection:Disconnect()
    end
    
    _G.AutoApplyHitBoxSize = true
    autoApplyConnection = game:GetService("RunService").Heartbeat:Connect(function()
        local success = pcall(function()
            local size = _G.HitBoxSize or 100
            resizeHitBoxes(size)
        end)
        
        if not success then
            warn("Auto-apply failed, retrying...")
        end
        
        task.wait(0.1)
    end)
end

local function stopAutoApply()
    _G.AutoApplyHitBoxSize = false
    if autoApplyConnection then
        autoApplyConnection:Disconnect()
        autoApplyConnection = nil
    end
end

-- Hitbox Size Slider
EventTab:AddSlider("HitboxSize", {
    Title = "Snowflakes Hitbox Size",
    Description = "Adjust the size of snowflake hitboxes",
    Default = 100,
    Min = 1,
    Max = 1000,
    Rounding = 0,
    Callback = function(Value)
        _G.HitBoxSize = Value
    end
})

-- Auto Apply Toggle
EventTab:AddToggle("AutoApplyHitbox", {
    Title = "Auto Set Snowflakes Size",
    Description = "Automatically apply hitbox size changes",
    Default = false,
    Callback = function(Value)
        if Value then
            startAutoApply()
        else
            stopAutoApply()
        end
    end
})

-- Auto Teleport to Snowflakes
local AutoTeleportSnowflakes = false
EventTab:AddToggle("AutoTeleportSnowflakes", {
    Title = "Auto Teleport To Snowflakes",
    Default = false,
    Callback = function(Value)
        AutoTeleportSnowflakes = Value
        
        task.spawn(function()
            local player = game.Players.LocalPlayer
            
            while AutoTeleportSnowflakes do
                local character = player.Character
                if not character then
                    task.wait(0.01)
                    continue
                end
                
                local rootPart = character:FindFirstChild("HumanoidRootPart")
                if not rootPart then
                    task.wait(0.01)
                    continue
                end
                
                local snowflakes = {}
                local generalFolder = workspace["#GAME"] and workspace["#GAME"].Folders.GeneralFolder
                
                if generalFolder then
                    for _, item in ipairs(generalFolder:GetChildren()) do
                        if item.Name == "SnowflakeModel" and item:IsA("Model") then
                            local hitBox = item:FindFirstChild("HitBox")
                            if hitBox then
                                table.insert(snowflakes, {
                                    model = item,
                                    position = hitBox.Position
                                })
                            end
                        end
                    end
                end
                
                for _, snowflake in ipairs(snowflakes) do
                    if not AutoTeleportSnowflakes then break end
                    rootPart.CFrame = CFrame.new(snowflake.position + Vector3.new(0, 1, 0))
                    task.wait(0.001)
                end
                
                task.wait(0.01)
            end
        end)
    end
})

-- Snowflakes ESP
local SnowflakeESP = false
EventTab:AddToggle("SnowflakeESP", {
    Title = "Snowflakes ESP",
    Default = false,
    Callback = function(Value)
        SnowflakeESP = Value
        if not Value then
            cleanESP("SnowflakeESP")
            return
        end

        task.spawn(function()
            while SnowflakeESP and task.wait(1) do
                local generalFolder = workspace["#GAME"] and 
                                    workspace["#GAME"].Folders and 
                                    workspace["#GAME"].Folders.GeneralFolder

                if generalFolder then
                    for _, item in pairs(generalFolder:GetDescendants()) do
                        local isSnowflake = item:IsA("Model") and item.Name == "SnowflakeModel"
                        
                        if isSnowflake then
                            if not item:FindFirstChild("SnowflakeESP") then
                                createESP(item, "SnowflakeESP", "Snowflake", Color3.fromRGB(255, 255, 0))
                            end
                            
                            if not item:FindFirstChildOfClass("Highlight") then
                                createHighlight(item, Color3.fromRGB(255, 255, 0))
                            end
                        else
                            local existingESP = item:FindFirstChild("SnowflakeESP")
                            if existingESP then existingESP:Destroy() end
                            local highlight = item:FindFirstChildOfClass("Highlight")
                            if highlight then highlight:Destroy() end
                        end
                    end
                end
            end
        end)
    end
})

-- Present System
local PresentSystem = {
    Player = game.Players.LocalPlayer,
    VirtualInputManager = game:GetService("VirtualInputManager"),
    
    isAutoSetHoldDuration = false,
    isTeleportToPresents = false,
    isAutoSpamKey = false,
    
    cachedPresents = {},
    lastScanTime = 0
}

function PresentSystem:isValidPresent(obj)
    if not obj or not obj.Parent then return false end
    
    local isValidType = obj:IsA("BasePart") or obj:IsA("Model") or obj:IsA("MeshPart")
    if not isValidType then return false end
    
    local nameLower = obj.Name:lower()
    
    if string.find(nameLower, "present") then
        if nameLower == "present" then return false end
        
        local presentTypes = {
            "basic present", "noob present", "rare present", "epic present",
            "legendary present", "mythical present", "exotic present",
            "golden present", "diamond present", "crystal present"
        }
        
        for _, presentType in ipairs(presentTypes) do
            if string.find(nameLower, presentType) then
                return true
            end
        end
        
        if #nameLower > 7 then
            return true
        end
    end
    
    return false
end

function PresentSystem:getFreshPresents()
    self.cachedPresents = {}
    
    local generalFolder = workspace["#GAME"] and 
                         workspace["#GAME"].Folders and 
                         workspace["#GAME"].Folders.GeneralFolder
    
    if generalFolder then
        for _, present in pairs(generalFolder:GetChildren()) do
            if self:isValidPresent(present) then
                local position
                if present:IsA("Model") then
                    position = present.PrimaryPart and present.PrimaryPart.Position or 
                              (present:FindFirstChildWhichIsA("BasePart") and present:FindFirstChildWhichIsA("BasePart").Position)
                else
                    position = present.Position
                end
                
                if position then
                    table.insert(self.cachedPresents, {
                        object = present,
                        position = position
                    })
                end
            end
        end
    end
    
    self.lastScanTime = tick()
    return self.cachedPresents
end

-- Auto Set Hold Duration
local autoSetThread
EventTab:AddToggle("AutoSetHoldDuration", {
    Title = "Auto Set Instant CD To Presents",
    Default = false,
    Callback = function(Value)
        PresentSystem.isAutoSetHoldDuration = Value
        if Value then
            autoSetThread = task.spawn(function()
                while PresentSystem.isAutoSetHoldDuration do
                    local generalFolder = workspace["#GAME"] and 
                                         workspace["#GAME"].Folders and 
                                         workspace["#GAME"].Folders.GeneralFolder
                    
                    if generalFolder then
                        for _, present in pairs(generalFolder:GetChildren()) do
                            if not PresentSystem.isAutoSetHoldDuration then break end
                            if PresentSystem:isValidPresent(present) then
                                local prompt = present:FindFirstChildWhichIsA("ProximityPrompt")
                                if prompt then
                                    prompt.HoldDuration = 0
                                    prompt.Enabled = true
                                    prompt.RequiresLineOfSight = false
                                end
                            end
                        end
                    end
                    task.wait(0.5)
                end
            end)
        else
            if autoSetThread then
                task.cancel(autoSetThread)
            end
        end
    end
})

-- Auto Teleport to Presents
local teleportThread
EventTab:AddToggle("AutoTeleportPresents", {
    Title = "Auto Teleport To Presents",
    Default = false,
    Callback = function(Value)
        PresentSystem.isTeleportToPresents = Value
        if Value then
            teleportThread = task.spawn(function()
                local player = PresentSystem.Player
                
                while PresentSystem.isTeleportToPresents do
                    local character = player.Character
                    if not character then
                        task.wait(0.1)
                        continue
                    end
                    
                    local rootPart = character:FindFirstChild("HumanoidRootPart")
                    if not rootPart then
                        task.wait(0.1)
                        continue
                    end
                    
                    local presents = PresentSystem:getFreshPresents()
                    
                    if #presents > 0 then
                        for _, presentData in ipairs(presents) do
                            if not PresentSystem.isTeleportToPresents then break end
                            if presentData.object and presentData.object.Parent then
                                rootPart.CFrame = CFrame.new(presentData.position + Vector3.new(0, 3, 0))
                                task.wait(0.001)
                            end
                        end
                    end
                    task.wait(0.01)
                end
            end)
        else
            if teleportThread then
                task.cancel(teleportThread)
            end
        end
    end
})

-- Present Notifier
local PresentNotifier = {
    enabled = false,
    detectedPresents = {}
}

function PresentNotifier:onDescendantAdded(descendant)
    if not self.enabled then return end
    
    if PresentSystem:isValidPresent(descendant) then
        local presentId = tostring(descendant:GetFullName())
        
        if not self.detectedPresents[presentId] then
            self.detectedPresents[presentId] = true
            
            Window:Dialog({
                Title = "Present Spawned!",
                Content = descendant.Name .. " has spawned!",
                Buttons = {
                    {
                        Title = "OK",
                        Callback = function()
                            print("User acknowledged present spawn")
                        end
                    }
                }
            })
        end
    end
end

EventTab:AddToggle("PresentNotifier", {
    Title = "Auto Notify Spawned Presents",
    Default = false,
    Callback = function(Value)
        PresentNotifier.enabled = Value
        
        if Value then
            PresentNotifier.detectedPresents = {}
            PresentNotifier.connection = workspace.DescendantAdded:Connect(function(descendant)
                PresentNotifier:onDescendantAdded(descendant)
            end)
        else
            if PresentNotifier.connection then
                PresentNotifier.connection:Disconnect()
                PresentNotifier.connection = nil
            end
        end
    end
})

-- Auto Spam E Key
local spamThread
EventTab:AddToggle("AutoSpamE", {
    Title = "Auto Spam E Key",
    Default = false,
    Callback = function(Value)
        PresentSystem.isAutoSpamKey = Value
        if Value then
            spamThread = task.spawn(function()
                while PresentSystem.isAutoSpamKey do
                    PresentSystem.VirtualInputManager:SendKeyEvent(true, Enum.KeyCode.E, false, game)
                    task.wait(0.01)
                    PresentSystem.VirtualInputManager:SendKeyEvent(false, Enum.KeyCode.E, false, game)
                    task.wait(0.01)
                end
            end)
        else
            if spamThread then
                task.cancel(spamThread)
            end
        end
    end
})

-- Presents ESP
local PresentESP = false
EventTab:AddToggle("PresentESP", {
    Title = "Presents ESP",
    Default = false,
    Callback = function(Value)
        PresentESP = Value
        if not Value then
            cleanESP("PresentESP")
            return
        end

        task.spawn(function()
            while PresentESP and task.wait(1) do
                local generalFolder = workspace["#GAME"] and 
                                     workspace["#GAME"].Folders and 
                                     workspace["#GAME"].Folders.GeneralFolder

                if generalFolder then
                    for _, item in pairs(generalFolder:GetDescendants()) do
                        local isValidPresent = false
                        
                        if item:IsA("BasePart") or item:IsA("MeshPart") or item:IsA("Model") then
                            local nameLower = item.Name:lower()
                            
                            if string.find(nameLower, "present") then
                                if nameLower ~= "present" then
                                    local presentTypes = {
                                        "basic present", "noob present", "rare present", "epic present",
                                        "legendary present", "mythical present", "golden present"
                                    }
                                    
                                    for _, presentType in ipairs(presentTypes) do
                                        if string.find(nameLower, presentType) then
                                            isValidPresent = true
                                            break
                                        end
                                    end
                                    
                                    if #nameLower > 7 then
                                        isValidPresent = true
                                    end
                                end
                            end
                        end
                        
                        if isValidPresent then
                            if not item:FindFirstChild("PresentESP") then
                                createESP(item, "PresentESP", item.Name, Color3.fromRGB(255, 215, 0))
                            end
                            
                            if not item:FindFirstChildOfClass("Highlight") then
                                createHighlight(item, Color3.fromRGB(255, 215, 0))
                            end
                        else
                            local existingESP = item:FindFirstChild("PresentESP")
                            if existingESP then existingESP:Destroy() end
                            local highlight = item:FindFirstChildOfClass("Highlight")
                            if highlight then highlight:Destroy() end
                        end
                    end
                end
            end
        end)
    end
})
end

do
    local BadgesTab = Tabs.Badges
    
-- Secret Badge 1 Section
BadgesTab:AddParagraph({
    Title = "Secret Badge 1",
    Content = "Features for the first secret badge"
})

-- Local variables for AutoShoot
local AutoShootSettings = {
    GunName = "Minigun",
    ShootingSpeed = 6,
    MaxDistance = 1000,
    Enabled = false
}

-- AutoShoot system
local ShootSystem = setmetatable({
    connection = nil,
    isRunning = false,
    isHolding = false,
    holdStartTime = 0,
    currentTarget = nil,
    twoPhaseGunPhase = 1,
    lastShootTime = 0,
    _cleaningUp = false,
    cachedNPCFolder = nil,
    cachedMainAttackEvent = nil,
}, {
    __index = function(self, key)
        if key == "Player" then
            rawset(self, "Player", Players.LocalPlayer)
            return self.Player
        end
        return nil
    end
})

-- Tool data
local TOOL_DATA = {
    HOLD_TOOLS = {
        ["TMG V2"] = true,
        ["SMOGGTTLTSG"] = true
    },
    TWO_PHASE_GUNS = {
        ["The Eggsterminator"] = true,
        ["Firework Launcher"] = true,
        ["Nubids Bow"] = true,
        ["Pumpkin Launcher"] = true
    }
}

-- Functions
local function isHoldTool(toolName)
    return TOOL_DATA.HOLD_TOOLS[toolName] == true
end

local function isTwoPhaseGun(toolName)
    return TOOL_DATA.TWO_PHASE_GUNS[toolName] == true
end

local function getNPCFolder()
    if ShootSystem.cachedNPCFolder then
        return ShootSystem.cachedNPCFolder
    end
    
    local success, npcFolder = pcall(function()
        return Workspace:WaitForChild("#GAME"):WaitForChild("Folders"):WaitForChild("VisibleInstances"):WaitForChild("HumanoidFolder"):WaitForChild("NPCFolder")
    end)
    
    if success and npcFolder then
        ShootSystem.cachedNPCFolder = npcFolder
        return npcFolder
    end
    
    return nil
end

local function getMainAttackEvent()
    if ShootSystem.cachedMainAttackEvent then
        return ShootSystem.cachedMainAttackEvent
    end
    
    local gameSystem = ReplicatedStorage:FindFirstChild("#GAME")
    if gameSystem then
        local storage = gameSystem:FindFirstChild("_Storage")
        if storage then
            local events = storage:FindFirstChild("Events")
            if events then
                local mainAttack = events:FindFirstChild("MainAttack")
                if mainAttack then
                    ShootSystem.cachedMainAttackEvent = mainAttack
                    return mainAttack
                end
            end
        end
    end
    
    return nil
end

local function getCharacter()
    local player = ShootSystem.Player
    return player and player.Character
end

local function getToolFromInventory(toolName)
    local player = ShootSystem.Player
    if not player then return nil end
    
    -- Check backpack
    local backpack = player.Backpack
    if backpack then
        local tool = backpack:FindFirstChild(toolName)
        if tool then return tool end
    end
    
    -- Check character
    local character = getCharacter()
    if character then
        return character:FindFirstChild(toolName)
    end
    
    return nil
end

local VECTOR_CONSTANTS = {
    CameraOffset = Vector3.new(0, 1.5, 0),
    FireworkOffset = Vector3.new(0, 10, 0)
}

-- Main shooting logic
local function fireRegularAttack(target, gunName, isHold)
    local character = getCharacter()
    if not character then return end
    
    local gunTool = getToolFromInventory(gunName)
    if not gunTool then return end
    
    if gunTool.Parent == ShootSystem.Player.Backpack then
        local currentTool = character:FindFirstChildWhichIsA("Tool")
        if currentTool then
            currentTool.Parent = ShootSystem.Player.Backpack
        end
        gunTool.Parent = character
        task.wait(0.05)
    end
    
    local head = target:FindFirstChild("Head")
    if not head then return end
    
    local primaryPart = character:FindFirstChild("HumanoidRootPart") or character.PrimaryPart
    if not primaryPart then return end
    
    local event = getMainAttackEvent()
    if not event then return end
    
    local attackArgs = {
        FD = head.Position,
        SD = Vector3.new(),
        FO = primaryPart.Position + VECTOR_CONSTANTS.CameraOffset,
        T = gunTool,
        AN = gunName,
        H = head,
        BM = 22.15,
        RP = primaryPart.Position,
        HP = head.Position,
        SP = head.Position
    }
    
    if isHold then
        attackArgs.IsHolding = true
        attackArgs.Duration = 0.1
    end
    
    event:FireServer(attackArgs)
end

local function findCrackedBasTarget(character, maxDistance)
    if not character or not character.PrimaryPart then return nil end
    
    local npcFolder = getNPCFolder()
    if not npcFolder then return nil end
    
    local closestTarget = nil
    local closestDistance = maxDistance
    local charPos = character.PrimaryPart.Position
    
    for _, npc in ipairs(npcFolder:GetChildren()) do
        if not ShootSystem.isRunning then break end
        
        if npc:IsA("Model") and npc.Name == "CrackedBas" then
            local humanoid = npc:FindFirstChildOfClass("Humanoid")
            local head = npc:FindFirstChild("Head")
            
            if humanoid and head and humanoid.Health > 0 then
                local dist = (charPos - head.Position).Magnitude
                if dist <= closestDistance then
                    closestDistance = dist
                    closestTarget = npc
                end
            end
        end
    end
    
    ShootSystem.currentTarget = closestTarget
    return closestTarget
end

local function startLoop()
    if ShootSystem.connection then
        ShootSystem.connection:Disconnect()
        ShootSystem.connection = nil
    end
    
    ShootSystem.connection = RunService.Heartbeat:Connect(function()
        if ShootSystem._cleaningUp or not ShootSystem.isRunning then 
            if ShootSystem.connection then
                ShootSystem.connection:Disconnect()
                ShootSystem.connection = nil
            end
            return 
        end
        
        local currentTime = tick()
        local character = getCharacter()
        
        if not character or not character.PrimaryPart then 
            return 
        end
        
        local target = findCrackedBasTarget(character, AutoShootSettings.MaxDistance)
        
        if target then
            local shootInterval = 1 / math.clamp(AutoShootSettings.ShootingSpeed, 1, 60)
            
            if isTwoPhaseGun(AutoShootSettings.GunName) then
                local tool = getToolFromInventory(AutoShootSettings.GunName)
                if not tool then return end
                
                if currentTime - ShootSystem.lastShootTime >= 0.01 then
                    -- Simplified two-phase attack for demonstration
                    fireRegularAttack(target, AutoShootSettings.GunName, false)
                    ShootSystem.twoPhaseGunPhase = ShootSystem.twoPhaseGunPhase == 1 and 2 or 1
                    ShootSystem.lastShootTime = currentTime
                end
            else
                local isHoldWeapon = isHoldTool(AutoShootSettings.GunName)
                
                if isHoldWeapon then
                    if ShootSystem.currentTarget ~= target then
                        ShootSystem.isHolding = false
                        ShootSystem.currentTarget = target
                    end
                    
                    if not ShootSystem.isHolding then
                        ShootSystem.isHolding = true
                        ShootSystem.holdStartTime = currentTime
                        fireRegularAttack(target, AutoShootSettings.GunName, true)
                    elseif currentTime - ShootSystem.holdStartTime >= shootInterval then
                        fireRegularAttack(target, AutoShootSettings.GunName, true)
                        ShootSystem.holdStartTime = currentTime
                    end
                elseif currentTime - ShootSystem.lastShootTime >= shootInterval then
                    fireRegularAttack(target, AutoShootSettings.GunName, false)
                    ShootSystem.lastShootTime = currentTime
                end
            end
        else
            ShootSystem.isHolding = false
            ShootSystem.twoPhaseGunPhase = 1
        end
    end)
end

local function cleanup()
    if ShootSystem._cleaningUp then return end
    
    ShootSystem._cleaningUp = true
    ShootSystem.isRunning = false
    ShootSystem.isHolding = false
    ShootSystem.currentTarget = nil
    ShootSystem.twoPhaseGunPhase = 1
    
    if ShootSystem.connection then
        ShootSystem.connection:Disconnect()
        ShootSystem.connection = nil
    end
    
    task.wait(0.1)
    ShootSystem._cleaningUp = false
end

-- Add controls to Fluent UI
BadgesTab:AddInput("GunNameInput", {
    Title = "Gun Name",
    Default = "Minigun",
    Placeholder = "Enter gun name",
    Numeric = false,
    Finished = false,
    Callback = function(Text)
        AutoShootSettings.GunName = tostring(Text) or "Minigun"
    end
})

BadgesTab:AddSlider("ShootingSpeedSlider", {
    Title = "Shooting Speed",
    Description = "Shots per second",
    Default = 6,
    Min = 1,
    Max = 60,
    Rounding = 0,
    Callback = function(Value)
        AutoShootSettings.ShootingSpeed = Value
    end
})

BadgesTab:AddSlider("MaxDistanceSlider", {
    Title = "Max Distance",
    Description = "Maximum shooting distance",
    Default = 1000,
    Min = 10,
    Max = 5000,
    Rounding = 0,
    Callback = function(Value)
        AutoShootSettings.MaxDistance = Value
    end
})

BadgesTab:AddToggle("AutoShootToggle", {
    Title = "Auto Shoot CrackedBas",
    Description = "Automatically shoot CrackedBas NPCs",
    Default = false,
    Callback = function(Value)
        AutoShootSettings.Enabled = Value
        
        if Value then
            ShootSystem.isRunning = true
            task.spawn(function()
                task.wait(1)
                if ShootSystem.isRunning then
                    startLoop()
                end
            end)
        else
            cleanup()
        end
    end
})

BadgesTab:AddButton({
    Title = "Teleport To Room",
    Description = "Make sure Bas from chair is killed",
    Callback = function()
        local shopPictureFrame = workspace["#GAME"].Map._Other.Shop.ShopPictureFrame.Back
        if shopPictureFrame and shopPictureFrame.ClickDetector then
            fireclickdetector(shopPictureFrame.ClickDetector)
            Fluent:Notify({
                Title = "Teleport",
                Content = "Teleported to room",
                Duration = 3
            })
        end
    end
})

BadgesTab:AddButton({
    Title = "Teleport To WhiteBas",
    Description = "Teleport to WhiteBas location",
    Callback = function()
        local whiteBas = workspace:FindFirstChild("WhiteBas", true)
        if whiteBas then
            local char = LocalPlayer.Character
            if char and char:FindFirstChild("HumanoidRootPart") then
                char.HumanoidRootPart.CFrame = whiteBas:GetPivot() + Vector3.new(0, 5, 0)
                Fluent:Notify({
                    Title = "Teleport",
                    Content = "Teleported to WhiteBas",
                    Duration = 3
                })
            end
        end
    end
})

-- Super Secret Badge 1 Section
BadgesTab:AddParagraph({
    Title = "Super Secret Badge 1",
    Content = "Features for Super Secret Badge 1"
})

-- Super Secret 1 Settings
local SuperSecret1Settings = {
    GunName = "Minigun",
    ShootingSpeed = 6,
    MaxDistance = 1000,
    Enabled = false
}

-- Super Secret 1 System (simplified version similar to AutoShoot)
local SuperSecret1System = setmetatable({
    connection = nil,
    isRunning = false,
    _cleaningUp = false,
}, {
    __index = function(self, key)
        if key == "Player" then
            rawset(self, "Player", Players.LocalPlayer)
            return self.Player
        end
        return nil
    end
})

local function startSuperSecret1Loop()
    if SuperSecret1System.connection then
        SuperSecret1System.connection:Disconnect()
        SuperSecret1System.connection = nil
    end
    
    SuperSecret1System.connection = RunService.Heartbeat:Connect(function()
        if SuperSecret1System._cleaningUp or not SuperSecret1System.isRunning then 
            if SuperSecret1System.connection then
                SuperSecret1System.connection:Disconnect()
                SuperSecret1System.connection = nil
            end
            return 
        end
        
        -- Similar logic to AutoShoot but targeting both CrackedBas and WhiteBas
        local character = SuperSecret1System.Player.Character
        if not character or not character.PrimaryPart then return end
        
        local npcFolder = getNPCFolder()
        if not npcFolder then return end
        
        for _, npc in ipairs(npcFolder:GetChildren()) do
            if not SuperSecret1System.isRunning then break end
            
            if npc:IsA("Model") and (npc.Name == "CrackedBas" or npc.Name == "WhiteBas") then
                local humanoid = npc:FindFirstChildOfClass("Humanoid")
                local head = npc:FindFirstChild("Head")
                
                if humanoid and head and humanoid.Health > 0 then
                    local dist = (character.PrimaryPart.Position - head.Position).Magnitude
                    if dist <= SuperSecret1Settings.MaxDistance then
                        -- Simplified attack logic
                        local tool = getToolFromInventory(SuperSecret1Settings.GunName)
                        if tool then
                            -- Similar attack logic as AutoShoot
                        end
                        break
                    end
                end
            end
        end
    end)
end

BadgesTab:AddInput("SuperSecret1GunName", {
    Title = "Gun Name",
    Default = "Minigun",
    Placeholder = "Enter gun name",
    Numeric = false,
    Finished = false,
    Callback = function(Text)
        SuperSecret1Settings.GunName = tostring(Text) or "Minigun"
    end
})

BadgesTab:AddSlider("SuperSecret1ShootingSpeed", {
    Title = "Shooting Speed",
    Description = "Shots per second",
    Default = 6,
    Min = 1,
    Max = 60,
    Rounding = 0,
    Callback = function(Value)
        SuperSecret1Settings.ShootingSpeed = Value
    end
})

BadgesTab:AddSlider("SuperSecret1MaxDistance", {
    Title = "Max Distance",
    Description = "Maximum shooting distance",
    Default = 1000,
    Min = 10,
    Max = 5000,
    Rounding = 0,
    Callback = function(Value)
        SuperSecret1Settings.MaxDistance = Value
    end
})

BadgesTab:AddToggle("SuperSecret1AutoShootToggle", {
    Title = "Auto Shoot CrackedBas/WhiteBas",
    Description = "Shoot CrackedBas or WhiteBas for Super Secret Badge 1",
    Default = false,
    Callback = function(Value)
        SuperSecret1Settings.Enabled = Value
        
        if Value then
            SuperSecret1System.isRunning = true
            task.spawn(function()
                task.wait(1)
                if SuperSecret1System.isRunning then
                    startSuperSecret1Loop()
                end
            end)
        else
            SuperSecret1System.isRunning = false
            if SuperSecret1System.connection then
                SuperSecret1System.connection:Disconnect()
                SuperSecret1System.connection = nil
            end
        end
    end
})

BadgesTab:AddButton({
    Title = "View WhiteBas",
    Description = "Focus camera on WhiteBas",
    Callback = function()
        local whiteBas = workspace:FindFirstChild("WhiteBas", true)
        if whiteBas then
            workspace.CurrentCamera.CameraSubject = whiteBas
            Fluent:Notify({
                Title = "View",
                Content = "Now viewing WhiteBas",
                Duration = 3
            })
        end
    end
})

BadgesTab:AddButton({
    Title = "Unview WhiteBas",
    Description = "Return camera to character",
    Callback = function()
        local char = LocalPlayer.Character
        if char then
            workspace.CurrentCamera.CameraSubject = char
            Fluent:Notify({
                Title = "View",
                Content = "Returned to character",
                Duration = 3
            })
        end
    end
})

BadgesTab:AddButton({
    Title = "Remove Touch Part",
    Description = "Remove touch part for auto click",
    Callback = function()
        local touchPart = workspace["#GAME"] and workspace["#GAME"].Map.BlackRoom.WhiteRoom.TouchPart
        if touchPart then
            touchPart:Destroy()
            Fluent:Notify({
                Title = "Touch Part",
                Content = "Removed touch part",
                Duration = 3
            })
        end
    end
})

-- Auto Spam Click Head
local spamHeadEnabled = false
BadgesTab:AddToggle("SpamHeadToggle", {
    Title = "Auto Spam Click Head (0.1 Speed)",
    Default = false,
    Callback = function(Value)
        spamHeadEnabled = Value
        if Value then
            task.spawn(function()
                while spamHeadEnabled do
                    local clickDetector = workspace["#GAME"] and workspace["#GAME"].Map.WhiteBasFakeHead:FindFirstChild("ClickDetector")
                    if clickDetector then
                        fireclickdetector(clickDetector)
                    end
                    task.wait(0.1)
                end
            end)
            Fluent:Notify({
                Title = "Spam Head",
                Content = "Enabled",
                Duration = 2
            })
        else
            Fluent:Notify({
                Title = "Spam Head",
                Content = "Disabled",
                Duration = 2
            })
        end
    end
})

BadgesTab:AddButton({
    Title = "Bring Head Cube",
    Description = "Bring head cube to player",
    Callback = function()
        local head = workspace["#GAME"] and workspace["#GAME"].Map.WhiteBasFakeHead
        local char = LocalPlayer.Character
        if head and char and char:FindFirstChild("HumanoidRootPart") then
            head.CFrame = char.HumanoidRootPart.CFrame
            Fluent:Notify({
                Title = "Head Cube",
                Content = "Brought head to player",
                Duration = 3
            })
        end
    end
})

-- Auto Bring Head
local autoBringHeadEnabled = false
BadgesTab:AddToggle("AutoBringHeadToggle", {
    Title = "Auto Bring Head Cube (Every 0.3 Sec)",
    Default = false,
    Callback = function(Value)
        autoBringHeadEnabled = Value
        if Value then
            task.spawn(function()
                while autoBringHeadEnabled do
                    local head = workspace["#GAME"] and workspace["#GAME"].Map:FindFirstChild("WhiteBasFakeHead")
                    local char = LocalPlayer.Character
                    if head and char and char:FindFirstChild("HumanoidRootPart") then
                        head.CFrame = char.HumanoidRootPart.CFrame
                    end
                    task.wait(0.3)
                end
            end)
            Fluent:Notify({
                Title = "Auto Bring Head",
                Content = "Enabled",
                Duration = 2
            })
        else
            Fluent:Notify({
                Title = "Auto Bring Head",
                Content = "Disabled",
                Duration = 2
            })
        end
    end
})

BadgesTab:AddButton({
    Title = "Open/Close Door",
    Description = "Toggle door state",
    Callback = function()
        local door = workspace["#GAME"] and workspace["#GAME"].Map.BlackRoom.WhiteRoom.Door
        if door and door.ClickDetector then
            fireclickdetector(door.ClickDetector)
            Fluent:Notify({
                Title = "Door",
                Content = "Toggled door",
                Duration = 2
            })
        end
    end
})

-- Auto Spam All Bas
local spamAllBasEnabled = false
BadgesTab:AddToggle("SpamAllBasToggle", {
    Title = "Auto Spam Click All Bas (0.1 Speed)",
    Default = false,
    Callback = function(Value)
        spamAllBasEnabled = Value
        if Value then
            task.spawn(function()
                while spamAllBasEnabled do
                    for _, basename in ipairs({"YellowBas", "GreyBas", "BlueBas", "WhiteBas", "BlackBas"}) do
                        local bas = workspace["#GAME"] and workspace["#GAME"].Map:FindFirstChild(basename)
                        if bas and bas:FindFirstChild("ClickDetector") then
                            fireclickdetector(bas.ClickDetector)
                        end
                    end
                    task.wait(0.1)
                end
            end)
            Fluent:Notify({
                Title = "Spam All Bas",
                Content = "Enabled",
                Duration = 2
            })
        else
            Fluent:Notify({
                Title = "Spam All Bas",
                Content = "Disabled",
                Duration = 2
            })
        end
    end
})

-- Secret Badge 2 Section
BadgesTab:AddParagraph({
    Title = "Secret Badge 2",
    Content = "Features for the second secret badge"
})

BadgesTab:AddButton({
    Title = "Enable/Disable Fire",
    Description = "Toggle fireplace",
    Callback = function()
        local fireplace = workspace["#GAME"] and workspace["#GAME"].Map.Houses["Blue House"].Rooms.LivingRoom.Fireplace.Base.Dial.Interactive
        if fireplace and fireplace.ClickDetector then
            fireclickdetector(fireplace.ClickDetector)
            Fluent:Notify({
                Title = "Fire",
                Content = "Toggled fireplace",
                Duration = 2
            })
        end
    end
})

BadgesTab:AddButton({
    Title = "Collect All Bacon Parts",
    Description = "Collect bacon parts in the map",
    Callback = function()
        local map = workspace["#GAME"] and workspace["#GAME"].Map
        local collected = 0
        if map then
            for _, part in pairs(map:GetChildren()) do
                if part:IsA("BasePart") and part.Name == "Part" and part.ClickDetector then
                    fireclickdetector(part.ClickDetector)
                    collected = collected + 1
                end
            end
        end
        Fluent:Notify({
            Title = "Bacon Parts",
            Content = "Collected " .. collected .. " parts",
            Duration = 3
        })
    end
})

-- Auto Click Correct Image
local autoClickImageEnabled = false
BadgesTab:AddToggle("AutoClickImageToggle", {
    Title = "Auto Click Correct Image",
    Default = false,
    Callback = function(Value)
        autoClickImageEnabled = Value
        if Value then
            task.spawn(function()
                while autoClickImageEnabled do
                    local pictureFrame = workspace["#GAME"] and workspace["#GAME"].Map.Houses["Blue House"].Rooms.LivingRoom.Fireplace.PouwkPictureFrame
                    if pictureFrame then
                        local clickDetector = pictureFrame:FindFirstChild("ClickDetector")
                        if clickDetector then
                            fireclickdetector(clickDetector)
                        end
                    end
                    task.wait(0.01)
                end
            end)
            Fluent:Notify({
                Title = "Auto Click Image",
                Content = "Enabled",
                Duration = 2
            })
        else
            Fluent:Notify({
                Title = "Auto Click Image",
                Content = "Disabled",
                Duration = 2
            })
        end
    end
})

BadgesTab:AddButton({
    Title = "Equip All Bacon Parts",
    Description = "Stand close to fire",
    Callback = function()
        local requiredParts = {
            "Right Leg",
            "Left Leg",
            "Right Arm",
            "Left Arm",
            "Torso",
            "Head"
        }
        
        local missingParts = {}
        local character = LocalPlayer.Character
        local backpack = LocalPlayer.Backpack
        
        if character and backpack then
            for _, partName in ipairs(requiredParts) do
                local part = backpack:FindFirstChild(partName)
                if part then
                    part.Parent = character
                else
                    table.insert(missingParts, partName)
                end
            end
        end
        
        if #missingParts > 0 then
            Fluent:Notify({
                Title = "Missing Parts",
                Content = "Not Found: " .. table.concat(missingParts, ", "),
                Duration = 3
            })
        else
            Fluent:Notify({
                Title = "All Parts Equipped",
                Content = "Successfully equipped all Bacon parts.",
                Duration = 3
            })
        end
    end
})

BadgesTab:AddButton({
    Title = "Teleport To Hatred",
    Description = "Teleport to Hatred location",
    Callback = function()
        local hatred = workspace:FindFirstChild("Berend", true)
        if hatred then
            local char = LocalPlayer.Character
            if char and char:FindFirstChild("HumanoidRootPart") then
                char.HumanoidRootPart.CFrame = hatred:GetPivot() + Vector3.new(0, 5, 0)
                Fluent:Notify({
                    Title = "Teleport",
                    Content = "Teleported to Hatred",
                    Duration = 3
                })
            end
        end
    end
})

-- Super Secret Badge 2 Section
BadgesTab:AddParagraph({
    Title = "Super Secret Badge 2 (SOON)",
    Content = "Coming soon..."
})

-- Valentine's 2025 Section
BadgesTab:AddParagraph({
    Title = "Valentines 2025 - Secret Badge",
    Content = "Gerard clicking features"
})

-- Gerard System
local GerardSystem = {
    autoClicking = false,
    clickConnection = nil,
    lastClickTime = 0,
    CLICK_COOLDOWN = 0.1
}

function GerardSystem:startAutoClick()
    if self.clickConnection then
        self.clickConnection:Disconnect()
        self.clickConnection = nil
    end
    
    self.autoClicking = true
    
    self.clickConnection = RunService.Heartbeat:Connect(function()
        if not self.autoClicking then return end
        
        local currentTime = tick()
        if currentTime - self.lastClickTime < self.CLICK_COOLDOWN then return end
        
        -- Find and click Gerard
        local gerard = workspace:FindFirstChild("GERARD", true)
        if gerard then
            local clickDetector = gerard:FindFirstChildOfClass("ClickDetector")
            if clickDetector then
                fireclickdetector(clickDetector)
                self.lastClickTime = currentTime
            end
        end
    end)
end

function GerardSystem:stopAutoClick()
    self.autoClicking = false
    if self.clickConnection then
        self.clickConnection:Disconnect()
        self.clickConnection = nil
    end
end

BadgesTab:AddButton({
    Title = "Click GERARD",
    Description = "Manually click Gerard once",
    Callback = function()
        local gerard = workspace:FindFirstChild("GERARD", true)
        if gerard then
            local clickDetector = gerard:FindFirstChildOfClass("ClickDetector")
            if clickDetector then
                fireclickdetector(clickDetector)
                Fluent:Notify({
                    Title = "Gerard",
                    Content = "Clicked Gerard successfully",
                    Duration = 2
                })
            end
        end
    end
})

BadgesTab:AddToggle("AutoClickGerardToggle", {
    Title = "Auto Click GERARD",
    Description = "Automatically clicks Gerard",
    Default = false,
    Callback = function(Value)
        if Value then
            GerardSystem:startAutoClick()
            Fluent:Notify({
                Title = "Auto Click Gerard",
                Content = "Enabled",
                Duration = 2
            })
        else
            GerardSystem:stopAutoClick()
            Fluent:Notify({
                Title = "Auto Click Gerard",
                Content = "Disabled",
                Duration = 2
            })
        end
    end
})

-- Anniversary 2024 Section
BadgesTab:AddParagraph({
    Title = "Anniversary 2024 - Secret Badge",
    Content = "Anniversary badge features"
})

-- Anniversary Settings
local AnniversarySettings = {
    GunName = "Minigun",
    ShootingSpeed = 6,
    MaxDistance = 1000,
    Enabled = false
}

-- Anniversary System (simplified similar to AutoShoot)
local AnniversarySystem = setmetatable({
    connection = nil,
    isRunning = false,
    _cleaningUp = false,
}, {
    __index = function(self, key)
        if key == "Player" then
            rawset(self, "Player", Players.LocalPlayer)
            return self.Player
        end
        return nil
    end
})

local function startAnniversaryLoop()
    if AnniversarySystem.connection then
        AnniversarySystem.connection:Disconnect()
        AnniversarySystem.connection = nil
    end
    
    AnniversarySystem.connection = RunService.Heartbeat:Connect(function()
        if AnniversarySystem._cleaningUp or not AnniversarySystem.isRunning then 
            if AnniversarySystem.connection then
                AnniversarySystem.connection:Disconnect()
                AnniversarySystem.connection = nil
            end
            return 
        end
        
        -- Similar logic to AutoShoot but targeting PartyBalloons
        local character = AnniversarySystem.Player.Character
        if not character or not character.PrimaryPart then return end
        
        -- Find PartyBalloons (simplified)
        local gameFolder = Workspace:FindFirstChild("#GAME")
        if gameFolder then
            -- Look for balloons in various locations
            local balloons = {}
            
            -- Check Map folder
            local mapFolder = gameFolder:FindFirstChild("Map")
            if mapFolder then
                for _, obj in pairs(mapFolder:GetDescendants()) do
                    if obj:IsA("MeshPart") and obj.Name == "PartyBalloon" then
                        table.insert(balloons, obj)
                    end
                end
            end
            
            -- Attack nearby balloons
            for _, balloon in pairs(balloons) do
                if not AnniversarySystem.isRunning then break end
                
                local dist = (character.PrimaryPart.Position - balloon.Position).Magnitude
                if dist <= AnniversarySettings.MaxDistance then
                    -- Simplified attack logic
                    local tool = getToolFromInventory(AnniversarySettings.GunName)
                    if tool then
                        -- Attack logic here (similar to AutoShoot)
                    end
                end
            end
        end
    end)
end

BadgesTab:AddInput("AnniversaryGunName", {
    Title = "Gun Name",
    Default = "Minigun",
    Placeholder = "Enter gun name",
    Numeric = false,
    Finished = false,
    Callback = function(Text)
        AnniversarySettings.GunName = tostring(Text) or "Minigun"
    end
})

BadgesTab:AddSlider("AnniversaryShootingSpeed", {
    Title = "Shooting Speed",
    Description = "Shots per second",
    Default = 6,
    Min = 1,
    Max = 60,
    Rounding = 0,
    Callback = function(Value)
        AnniversarySettings.ShootingSpeed = Value
    end
})

BadgesTab:AddSlider("AnniversaryMaxDistance", {
    Title = "Max Distance",
    Description = "Maximum shooting distance",
    Default = 1000,
    Min = 10,
    Max = 5000,
    Rounding = 0,
    Callback = function(Value)
        AnniversarySettings.MaxDistance = Value
    end
})

BadgesTab:AddToggle("AutoShootAnniversaryToggle", {
    Title = "Auto Shoot Anniversary",
    Description = "Auto shoot PartyBalloons for anniversary badge",
    Default = false,
    Callback = function(Value)
        AnniversarySettings.Enabled = Value
        
        if Value then
            AnniversarySystem.isRunning = true
            task.spawn(function()
                task.wait(1)
                if AnniversarySystem.isRunning then
                    startAnniversaryLoop()
                end
            end)
            Fluent:Notify({
                Title = "Anniversary Auto Shoot",
                Content = "Enabled",
                Duration = 2
            })
        else
            AnniversarySystem.isRunning = false
            if AnniversarySystem.connection then
                AnniversarySystem.connection:Disconnect()
                AnniversarySystem.connection = nil
            end
            Fluent:Notify({
                Title = "Anniversary Auto Shoot",
                Content = "Disabled",
                Duration = 2
            })
        end
    end
})

-- Clown Mouse Section
local CM = {
    bring = false,
    esp = false
}

-- Auto Bring Clown Mouse
BadgesTab:AddToggle("AutoBringClownMouseToggle", {
    Title = "Auto Bring Clown Mouse",
    Description = "Attempt to bring Clown Mouse by touching its parts",
    Default = false,
    Callback = function(Value) 
        CM.bring = Value
        if not Value then return end
        
        task.spawn(function()
            while CM.bring do
                local character = LocalPlayer.Character
                if character then
                    local humanoidRootPart = character:WaitForChild("HumanoidRootPart")
                    
                    local gameFolder = workspace:FindFirstChild("#GAME")
                    if gameFolder then
                        local mapFolder = gameFolder:FindFirstChild("Map")
                        if mapFolder then
                            local clownMouseModel = mapFolder:FindFirstChild("ClownMouseModel")
                            
                            if clownMouseModel then
                                for _, part in pairs(clownMouseModel:GetDescendants()) do
                                    if part:IsA("BasePart") and part.Name == "Part" then
                                        firetouchinterest(humanoidRootPart, part, 0)
                                        firetouchinterest(humanoidRootPart, part, 1)
                                    end
                                end
                            end
                        end
                    end
                end
                task.wait(0.1)
            end
        end)
        Fluent:Notify({
            Title = "Auto Bring Clown Mouse",
            Content = "Enabled",
            Duration = 2
        })
    end
})

-- Helper function for ESP
local function createESP(model, name, text, color)
    local billboard = Instance.new("BillboardGui")
    billboard.Name = name
    billboard.Size = UDim2.new(0, 100, 0, 40)
    billboard.StudsOffset = Vector3.new(0, 3, 0)
    billboard.AlwaysOnTop = true
    billboard.Adornee = model
    
    local textLabel = Instance.new("TextLabel")
    textLabel.Size = UDim2.new(1, 0, 1, 0)
    textLabel.BackgroundTransparency = 1
    textLabel.Text = text
    textLabel.TextColor3 = color
    textLabel.TextScaled = true
    textLabel.Font = Enum.Font.GothamBold
    textLabel.Parent = billboard
    
    billboard.Parent = model
    return billboard
end

-- Helper function for Highlight
local function createHighlight(model, color, name)
    local highlight = Instance.new("Highlight")
    highlight.Name = name
    highlight.FillColor = color
    highlight.OutlineColor = color
    highlight.FillTransparency = 0.5
    highlight.OutlineTransparency = 0
    highlight.Parent = model
    return highlight
end

-- Clown Mouse ESP
BadgesTab:AddToggle("ClownMouseESPToggle", {
    Title = "Clown Mouse ESP",
    Description = "Show ESP highlight for Clown Mouse",
    Default = false,
    Callback = function(Value)
        CM.esp = Value
        if not Value then
            -- Clean up ESP elements
            for _, v in pairs(workspace:GetDescendants()) do
                if v:IsA("BillboardGui") and v.Name == "ClownMouseESP" then
                    v:Destroy()
                end
                if v:IsA("Highlight") and v.Name == "ClownMouseHighlight" then
                    v:Destroy()
                end
            end
            return
        end

        task.spawn(function()
            while CM.esp do
                local gameFolder = workspace:FindFirstChild("#GAME")
                if gameFolder then
                    local mapFolder = gameFolder:FindFirstChild("Map")
                    if mapFolder then
                        local clownMouseModel = mapFolder:FindFirstChild("ClownMouseModel")
                        
                        if clownMouseModel then
                            if not clownMouseModel:FindFirstChild("ClownMouseESP") then
                                createESP(clownMouseModel, "ClownMouseESP", "ClownMouseModel", Color3.fromRGB(255, 0, 0))
                            end
                            
                            if not clownMouseModel:FindFirstChild("ClownMouseHighlight") then
                                createHighlight(clownMouseModel, Color3.fromRGB(255, 0, 0), "ClownMouseHighlight")
                            end
                        else
                            -- Clean up if model not found
                            for _, v in pairs(workspace:GetDescendants()) do
                                if v:IsA("BillboardGui") and v.Name == "ClownMouseESP" then
                                    v:Destroy()
                                end
                                if v:IsA("Highlight") and v.Name == "ClownMouseHighlight" then
                                    v:Destroy()
                                end
                            end
                        end
                    end
                end
                task.wait(1)
            end
        end)
        Fluent:Notify({
            Title = "Clown Mouse ESP",
            Content = "Enabled",
            Duration = 2
        })
    end
})

end

do
    local ESPTab = Tabs.ESP
    
    local function createESP(parent, name, text, color)
        local esp = Instance.new("BillboardGui", parent)
        esp.Name = name
        esp.Adornee = parent
        esp.Size = UDim2.new(0, 150, 0, 40)
        esp.StudsOffset = Vector3.new(0, 2, 0)
        esp.AlwaysOnTop = true
        
        local label = Instance.new("TextLabel", esp)
        label.BackgroundTransparency = 1
        label.Size = UDim2.new(1, 0, 1, 0)
        label.TextSize = 16
        label.Font = Enum.Font.FredokaOne
        label.TextColor3 = color
        label.TextStrokeTransparency = 0.2
        label.Text = text
        
        return label
    end
    
    local function createHighlight(parent, color)
        local highlight = Instance.new("Highlight")
        highlight.Parent = parent
        highlight.FillColor = color
        highlight.FillTransparency = 0.5
        highlight.OutlineColor = color
        highlight.OutlineTransparency = 0
        highlight.DepthMode = Enum.HighlightDepthMode.AlwaysOnTop
        return highlight
    end
    
    -- Players ESP
    local playersESPToggle = ESPTab:AddToggle("PlayersESP", {
        Title = "Players ESP",
        Default = false,
        Callback = function(value)
            _G.PlayerESP = value
            
            if not value then
                for _, v in ipairs(Players:GetPlayers()) do
                    local head = v.Character and v.Character:FindFirstChild("Head")
                    if head then
                        if head:FindFirstChild("PlayerEsp") then
                            head.PlayerEsp:Destroy()
                        end
                        local highlight = head:FindFirstChildOfClass("Highlight")
                        if highlight then
                            highlight:Destroy()
                        end
                    end
                end
                return
            end
            
            task.spawn(function()
                while _G.PlayerESP do
                    for _, v in ipairs(Players:GetPlayers()) do
                        if v ~= localPlayer and v.Character and v.Character:FindFirstChild("Head") then
                            local head = v.Character.Head
                            local humanoid = v.Character:FindFirstChild("Humanoid")
                            if head and humanoid then
                                if not head:FindFirstChild("PlayerEsp") then
                                    createESP(head, "PlayerEsp", v.Name, Color3.new(1, 1, 1))
                                end
                                
                                if not head.Parent:FindFirstChildOfClass("Highlight") then
                                    createHighlight(head.Parent, Color3.new(1, 1, 1))
                                end
                            end
                        end
                    end
                    task.wait(1)
                end
            end)
            Fluent:Notify({
                Title = "Players ESP",
                Content = value and "Enabled" or "Disabled",
                Duration = 2
            })
        end
    })
    
    -- NPCs ESP
    local npcESPToggle = ESPTab:AddToggle("NPCESP", {
        Title = "NPC's ESP",
        Default = false,
        Callback = function(value)
            _G.NPCESP = value
            if not value then
                for _, v in pairs(workspace:GetDescendants()) do
                    if v:IsA("BillboardGui") and v.Name == "NPCESP" then
                        v:Destroy()
                    end
                    if v:IsA("Highlight") then
                        v:Destroy()
                    end
                end
                return
            end
            
            task.spawn(function()
                while _G.NPCESP do
                    local npcFolder = workspace:FindFirstChild("#GAME") and 
                                     workspace["#GAME"]:FindFirstChild("Folders") and 
                                     workspace["#GAME"].Folders:FindFirstChild("VisibleInstances") and 
                                     workspace["#GAME"].Folders.VisibleInstances:FindFirstChild("HumanoidFolder") and 
                                     workspace["#GAME"].Folders.VisibleInstances.HumanoidFolder:FindFirstChild("NPCFolder")
                    
                    if npcFolder then
                        for _, npc in pairs(npcFolder:GetChildren()) do
                            local humanoid = npc:FindFirstChildOfClass("Humanoid")
                            local head = npc:FindFirstChild("Head")
                            
                            if humanoid and head and humanoid.Health > 0 then
                                if not head:FindFirstChild("NPCESP") then
                                    createESP(head, "NPCESP", npc.Name, Color3.fromRGB(0, 255, 0))
                                end
                                
                                if not npc:FindFirstChildOfClass("Highlight") then
                                    createHighlight(npc, Color3.fromRGB(0, 255, 0))
                                end
                            else
                                local existingESP = head and head:FindFirstChild("NPCESP")
                                if existingESP then
                                    existingESP:Destroy()
                                end
                                local highlight = npc and npc:FindFirstChildOfClass("Highlight")
                                if highlight then
                                    highlight:Destroy()
                                end
                            end
                        end
                    end
                    task.wait(1)
                end
            end)
            Fluent:Notify({
                Title = "NPC ESP",
                Content = value and "Enabled" or "Disabled",
                Duration = 2
            })
        end
    })
    
    -- Bacon Parts ESP
    local baconESPToggle = ESPTab:AddToggle("BaconESP", {
        Title = "Bacon Parts ESP",
        Default = false,
        Callback = function(value)
            _G.PartESP = value
            if not value then
                for _, v in pairs(workspace:GetDescendants()) do
                    if v:IsA("BillboardGui") and v.Name == "PartESP" then
                        v:Destroy()
                    end
                    if v:IsA("Highlight") then
                        v:Destroy()
                    end
                end
                return
            end
            
            task.spawn(function()
                while _G.PartESP do
                    local map = workspace:FindFirstChild("#GAME") and workspace["#GAME"]:FindFirstChild("Map")
                    
                    if map then
                        for _, part in pairs(map:GetDescendants()) do
                            if part:IsA("BasePart") and part.Name == "Part" then
                                local clickDetector = part:FindFirstChild("ClickDetector")
                                
                                if clickDetector then
                                    if not part:FindFirstChild("PartESP") then
                                        createESP(part, "PartESP", "Bacon Part", Color3.fromRGB(255, 0, 0))
                                    end
                                    
                                    if not part:FindFirstChildOfClass("Highlight") then
                                        createHighlight(part, Color3.fromRGB(255, 0, 0))
                                    end
                                end
                            end
                        end
                    end
                    task.wait(1)
                end
            end)
            Fluent:Notify({
                Title = "Bacon ESP",
                Content = value and "Enabled" or "Disabled",
                Duration = 2
            })
        end
    })
    
    -- Eggs ESP
    local eggESPToggle = ESPTab:AddToggle("EggESP", {
        Title = "Eggs ESP",
        Default = false,
        Callback = function(value)
            _G.EggESP = value
            if not value then
                for _, v in pairs(workspace:GetDescendants()) do
                    if v:IsA("BillboardGui") and v.Name == "EggESP" then
                        v:Destroy()
                    end
                    if v:IsA("Highlight") then
                        v:Destroy()
                    end
                end
                return
            end
            
            task.spawn(function()
                while _G.EggESP do
                    -- Updated path
                    local generalFolder = workspace:FindFirstChild("#GAME") and 
                                         workspace["#GAME"]:FindFirstChild("Folders") and 
                                         workspace["#GAME"].Folders:FindFirstChild("GeneralFolder")  -- Changed from DumpFolder
                    
                    if generalFolder then
                        for _, item in pairs(generalFolder:GetDescendants()) do
                            if (item:IsA("MeshPart") or item:IsA("Model") or item:IsA("Part")) and 
                               string.find(item.Name, "Egg", 1, true) then
                                if not item:FindFirstChild("EggESP") then
                                    createESP(item, "EggESP", item.Name, Color3.fromRGB(255, 255, 0))
                                end
                                
                                if not item:FindFirstChildOfClass("Highlight") then
                                    createHighlight(item, Color3.fromRGB(255, 255, 0))
                                end
                            end
                        end
                    end
                    task.wait(1)
                end
            end)
            Fluent:Notify({
                Title = "Egg ESP",
                Content = value and "Enabled" or "Disabled",
                Duration = 2
            })
        end
    })
end

do
    local ShopTab = Tabs.Shop
    
    -- Define all shop items
    local allShopItems = {
        "Great King Poop Noob", "Exclusive 10k Pet", "Bob", "20k Pet", "Party Pedro", "Bombarder Noob Pet",
        "Exclusive 1 MILLION Pet", "Balloon Tank", "Party Pet", "Buoyant Pet", "Delicious Pet", "Balloon Sword",
        "Revolvah", "Revwholever", "MegAK-47", "Poop Werewolf Pet", "Scammah Pet", "Poop Noob Pet",
        "Bigger Fat Poop Noob Pet", "Biggest Mega Fat Poop Noob Pet", "Banana Cato", "Sir Stinkington",
        "Lamppost", "Pine Tree", "Billboard", "Shyserkampfwagen IV", "Turd Maus", "Sebastian", "Toilet Pouwk",
        "Toilet BULL", "Black Bas", "Turd Mouse", "BULLKERPOUWKER", "Exclusive Verdant Vanquisher",
        "Justice", "Revolutionary Rain", "Liberty Annihilator", "Chicken Gun", "The Eggsterminator",
        "Easter Egg", "Chicken", "Lil Scrambler", "Chicken Noob Pet", "Moai Pet", "Strongest Egg",
        "Bunny Noob Pet", "Supreme Chick", "Bulk Beak", "Stone Cold Cutie", "Suprahme Chick", "Easter Doggo",
        "Eggstinction Rush X", "Firework Launcher", "Bunny Ears", "Nubids Bow", "Teddy", "Heart Pet",
        "Pinky", "Nubid", "BULLkiePouwk", "Pumpkin Launcher", "Little Jack", "Biggest Cracked Bas",
        "Exclusive 10 MILLION Pet", "Corrupted Black Hole Pet", "Exclusive 100 MILLION Pet",
        "Exclusive Scarlet Slaughterer", "Soulreaper", "The Scepter", "King Biggest Mega Fat Poop Noob",
        "King Poop Noob", "Queen Poop Noob", "King Noob", "Great King Noob", "Queen Noob", "The Crown",
        "Festive Noob Pet", "Turkey Pet", "Elf Pet", "Gingerbread Pet", "Santa Pet", "Satan Santa",
        "Revolver", "Deagle", "UZI", "Tommy Gun", "AK-47", "Sawed-Off", "Trench Shotgun", "SPAS-12",
        "AWP", "Remington 700", "RPG-7", "Panzer IV", "Kriss Vector", "Hecate II", "Minigun", "S-G",
        "MG 1", "M4A3E8", "Microgun", "TMG V2", "M1 Abrams", "SMOGGTTLTSG", "Maus", "UZYeah", "Smiley Sucker",
        "Revolvahhh", "Baby Noob Pet", "Bacon Pet", "Short Bacon Pet", "Tall Bacon Pet", "Bigger Bacon Pet",
        "10k Pet", "Rock Noob Pet", "Monster Noob Pet", "Zombie Pet", "Biggest Bacon Pet", "Stick Bug",
        "Werewolf Pet", "100k Pet", "PedroMobile", "Biggest Bigger Bacon Pet", "Sticker Bug", "Cracked Stick Bug",
        "Stickest Bug", "Cracked Sticker Bug", "10 MILLION Pet", "Stickester Bug", "100 MILLION Pet",
        "1 BILLION Pet", "Evaluator \206\148", "Clown Mouse", "SGobbler", "Pouwk", "Scammer Pet", "Cracked Bas", "BULL",
        "Sjebullepouwker", "Exclusive 100k Pet", "Cursor", "Silver Cursor", "Golden Cursor", "Diamond Cursor",
        "Emerald Cursor", "Ruby Cursor", "Amethyst Cursor", "Boots", "Silver Boots", "Golden Boots",
        "Diamond Boots", "Emerald Boots", "Ruby Boots", "Amethyst Boots", "Gloves", "Silver Gloves",
        "Golden Gloves", "Diamond Gloves", "Emerald Gloves", "Ruby Gloves", "Amethyst Gloves",
        "Body Armor", "Silver Body Armor", "Golden Body Armor", "Diamond Body Armor", "Emerald Body Armor",
        "Ruby Body Armor", "Amethyst Body Armor", "Cheese", "Balloon", "Party Hat", "Lantern", "Classic Sword", "King Slayer",
        "CRACKED Mode", "Hatred", "Onion", "Noob burger", "OOOHnion", "Bigger Noob burger",
        "Biggest Noob burger", "Biggest Bigger Noob burger"
    }
    
    table.sort(allShopItems)
    
    local selectedItem = "Deagle"
    
    local itemDropdown = ShopTab:AddDropdown("ShopItemDropdown", {
        Title = "Choose What To Buy",
        Values = allShopItems,
        Default = "Deagle",
        Multi = false,
        Callback = function(value)
            selectedItem = value
        end
    })
    
    ShopTab:AddButton({
        Title = "Buy Item From Shop",
        Description = "",
        Callback = function()
            local args = {selectedItem}
            local buyEvent = ReplicatedStorage:WaitForChild("Events"):WaitForChild("BuyItem")
            if buyEvent then
                buyEvent:FireServer(unpack(args))
                Fluent:Notify({
                    Title = "Shop",
                    Content = "Purchased: " .. selectedItem,
                    Duration = 3
                })
            end
        end
    })
    
    local autoBuyToggle = ShopTab:AddToggle("AutoBuy", {
        Title = "Auto Buy Item From Shop",
        Default = false,
        Callback = function(value)
            _G.autoBuyEnabled = value
            if value then
                task.spawn(function()
                    while _G.autoBuyEnabled do
                        local args = {selectedItem}
                        local buyEvent = ReplicatedStorage:WaitForChild("Events"):WaitForChild("BuyItem")
                        if buyEvent then
                            buyEvent:FireServer(unpack(args))
                        end
                        task.wait(1)
                    end
                end)
                Fluent:Notify({
                    Title = "Auto Buy",
                    Content = "Enabled for " .. selectedItem,
                    Duration = 2
                })
            else
                Fluent:Notify({
                    Title = "Auto Buy",
                    Content = "Disabled",
                    Duration = 2
                })
            end
        end
    })

    -- Initialize global variable
    _G.EquipShopItemName = ""

    -- Textbox to input the item name
    ShopTab:AddInput("ItemNameInput", {
        Title = "Item Name to Un/Equip",
        Default = "",
        Placeholder = "Enter item name...",
        Numeric = false,
        Finished = false,
        Callback = function(Text)
            _G.EquipShopItemName = tostring(Text) or ""
            Fluent:Notify({
                Title = "Item Name Set",
                Content = "Item name set to: " .. _G.EquipShopItemName,
                Duration = 2
            })
        end
    })

    -- Button to fire the remote with the textbox input
    ShopTab:AddButton({
        Title = "Un/Equip Item From Shop",
        Description = "Equip or unequip an item from the shop",
        Callback = function()
            -- Get the item name from the textbox
            local itemName = _G.EquipShopItemName
            
            if itemName and itemName ~= "" then
                -- Create the args table
                local args = {
                    itemName
                }
                
                -- Try to fire the remote
                local success, errorMessage = pcall(function()
                    game:GetService("ReplicatedStorage"):WaitForChild("Events"):WaitForChild("EquipShopItem"):FireServer(unpack(args))
                end)
                
                if success then
                    Fluent:Notify({
                        Title = "Success",
                        Content = "Successfully sent EquipShopItem remote with item: " .. itemName,
                        Duration = 3
                    })
                else
                    Fluent:Notify({
                        Title = "Error",
                        Content = "Failed to send EquipShopItem remote: " .. tostring(errorMessage),
                        Duration = 5
                    })
                end
            else
                Fluent:Notify({
                    Title = "Warning",
                    Content = "Please enter an item name in the textbox first!",
                    Duration = 3
                })
            end
        end
    })
end

do
    local ScriptsTab = Tabs.Scripts
    
    ScriptsTab:AddParagraph({
        Title = "ZScriptX",
        Content = ""
    })
    
    ScriptsTab:AddButton({
        Title = "SAEN Script",
        Description = "Load ZScriptX script",
        Callback = function()
            loadstring(game:HttpGet('https://raw.githubusercontent.com/sederyttv-scripter/Wow/refs/heads/main/djdj'))()
            Fluent:Notify({
                Title = "Script",
                Content = "Loaded SAEN script",
                Duration = 3
            })
        end
    })
end

do
    local InventoryTab = Tabs.Inventory
    
    local playerList = {}
    
    for _, player in ipairs(Players:GetPlayers()) do
        table.insert(playerList, player.Name)
    end
    
    local selectedPlayer = localPlayer
    
    local playerDropdown = InventoryTab:AddDropdown("InventoryPlayerDropdown", {
        Title = "Select Player",
        Values = playerList,
        Default = localPlayer.Name,
        Multi = false,
        Callback = function(value)
            selectedPlayer = Players:FindFirstChild(value)
            if selectedPlayer then
                updateInventoryDisplay()
            end
        end
    })
    
    local function updateInventoryDisplay()
        local tools = {}
        
        if selectedPlayer then
            -- Check backpack
            if selectedPlayer:FindFirstChild("Backpack") then
                for _, tool in ipairs(selectedPlayer.Backpack:GetChildren()) do
                    if tool:IsA("Tool") then
                        local amount = tool:GetAttribute("Amount")
                        if amount then
                            table.insert(tools, tool.Name .. " " .. tostring(amount))
                        else
                            table.insert(tools, tool.Name)
                        end
                    end
                end
            end
            
            -- Check equipped tools
            if selectedPlayer.Character then
                for _, tool in ipairs(selectedPlayer.Character:GetChildren()) do
                    if tool:IsA("Tool") then
                        local amount = tool:GetAttribute("Amount")
                        if amount then
                            table.insert(tools, tool.Name .. " " .. tostring(amount))
                        else
                            table.insert(tools, tool.Name)
                        end
                    end
                end
            end
        end
        
        if #tools > 0 then
            inventoryText:SetDesc(table.concat(tools, "\n"))
        else
            inventoryText:SetDesc("No tools found in inventory")
        end
    end
    
    InventoryTab:AddButton({
        Title = "Update Player List",
        Description = "",
        Callback = function()
            local newList = {}
            for _, player in ipairs(Players:GetPlayers()) do
                table.insert(newList, player.Name)
            end
            playerDropdown:SetValues(newList)
            Fluent:Notify({
                Title = "Player List",
                Content = "Updated player list",
                Duration = 2
            })
        end
    })
    
    local inventoryText = InventoryTab:AddParagraph({
        Title = "Inventory Items:",
        Content = "Select a player to view their inventory"
    })
    
    local autoUpdateToggle = InventoryTab:AddToggle("AutoUpdateInventory", {
        Title = "Auto Update Inventory",
        Default = false,
        Callback = function(value)
            if value then
                local connection
                connection = RunService.Heartbeat:Connect(function()
                    if not value then
                        if connection then
                            connection:Disconnect()
                        end
                        return
                    end
                    updateInventoryDisplay()
                end)
            end
        end
    })
    
    -- Update player list when players join/leave
    Players.PlayerAdded:Connect(function()
        local newList = {}
        for _, player in ipairs(Players:GetPlayers()) do
            table.insert(newList, player.Name)
        end
        playerDropdown:SetValues(newList)
    end)
    
    Players.PlayerRemoving:Connect(function()
        local newList = {}
        for _, player in ipairs(Players:GetPlayers()) do
            table.insert(newList, player.Name)
        end
        playerDropdown:SetValues(newList)
    end)
end

do
    local HealthTab = Tabs.HealthNPCs
    
    local npcHealthText = HealthTab:AddParagraph({
        Title = "NPC Health Status:",
        Content = "NPC health information will appear here"
    })
    
    local function getNPCHealthStatus()
        local npcStatus = {}
        local npcFolder = workspace:FindFirstChild("#GAME") and 
                         workspace["#GAME"]:FindFirstChild("Folders") and 
                         workspace["#GAME"].Folders:FindFirstChild("VisibleInstances") and 
                         workspace["#GAME"].Folders.VisibleInstances:FindFirstChild("HumanoidFolder") and 
                         workspace["#GAME"].Folders.VisibleInstances.HumanoidFolder:FindFirstChild("NPCFolder")
        
        if npcFolder then
            for _, npc in ipairs(npcFolder:GetChildren()) do
                if npc:IsA("Model") then
                    local humanoid = npc:FindFirstChildOfClass("Humanoid")
                    if humanoid and humanoid.Health > 0 then
                        local currentHealth = math.floor(humanoid.Health)
                        local maxHealth = math.floor(humanoid.MaxHealth)
                        local healthText = "(" .. currentHealth .. "/" .. maxHealth .. ")"
                        
                        table.insert(npcStatus, {
                            name = npc.Name,
                            health = healthText,
                            currentHealth = currentHealth,
                            maxHealth = maxHealth
                        })
                    end
                end
            end
        end
        
        return npcStatus
    end
    
    local function updateNPCHealthDisplay()
        local npcStatus = getNPCHealthStatus()
        local displayText = ""
        
        if #npcStatus > 0 then
            table.sort(npcStatus, function(a, b)
                return a.name < b.name
            end)
            
            local maxDisplayLines = 20
            local displayedCount = 0
            
            for i = 1, #npcStatus do
                if displayedCount >= maxDisplayLines then break end
                
                local status = npcStatus[i]
                local line = status.name .. " = " .. status.health
                displayText = displayText .. line
                
                if i < #npcStatus and displayedCount < maxDisplayLines - 1 then
                    displayText = displayText .. "\n"
                end
                
                displayedCount = displayedCount + 1
            end
            
            if #npcStatus > maxDisplayLines then
                displayText = displayText .. "\n... and " .. (#npcStatus - maxDisplayLines) .. " more NPCs"
            end
            
            displayText = displayText .. "\n\nTotal NPCs: " .. #npcStatus
            local aliveCount = 0
            for _, status in ipairs(npcStatus) do
                if status.currentHealth > 0 then
                    aliveCount = aliveCount + 1
                end
            end
            displayText = displayText .. " (Alive: " .. aliveCount .. ")"
        else
            displayText = "No NPCs found or no humanoids detected"
        end
        
        npcHealthText:SetDesc(displayText)
    end
    
    HealthTab:AddButton({
        Title = "Show Full NPC Names",
        Description = "",
        Callback = function()
            local npcStatus = getNPCHealthStatus()
            if #npcStatus > 0 then
                local detailedText = "=== FULL NPC NAMES ===\n\n"
                
                for i, status in ipairs(npcStatus) do
                    local healthPercent = math.floor((status.currentHealth / status.maxHealth) * 100)
                    detailedText = detailedText .. i .. ". " .. status.name .. "\n"
                    detailedText = detailedText .. "   " .. status.health .. " (" .. healthPercent .. "%)\n\n"
                end
                
                HealthTab:AddParagraph({
                    Title = "Full NPC Details",
                    Content = detailedText
                })
            end
        end
    })
    
    local searchInput = HealthTab:AddInput("NPCSearch", {
        Title = "Search NPC by Name",
        Default = "",
        Placeholder = "Enter NPC name...",
        Numeric = false,
        Finished = false,
        Callback = function(value)
            if value and #value > 0 then
                local npcStatus = getNPCHealthStatus()
                local searchResults = {}
                local searchText = string.lower(value)
                
                for _, status in ipairs(npcStatus) do
                    if string.find(string.lower(status.name), searchText) then
                        table.insert(searchResults, status)
                    end
                end
                
                if #searchResults > 0 then
                    local resultText = "=== SEARCH RESULTS ===\n\n"
                    resultText = resultText .. "Found " .. #searchResults .. " NPCs matching '" .. value .. "'\n\n"
                    
                    for i, status in ipairs(searchResults) do
                        local healthPercent = math.floor((status.currentHealth / status.maxHealth) * 100)
                        resultText = resultText .. i .. ". " .. status.name .. "\n"
                        resultText = resultText .. "   " .. status.health .. " (" .. healthPercent .. "%)\n\n"
                    end
                    
                    npcHealthText:SetDesc(resultText)
                else
                    Fluent:Notify({
                        Title = "Search",
                        Content = "No NPCs found matching '" .. value .. "'",
                        Duration = 3
                    })
                end
            end
        end
    })
    
    local autoUpdateNPCToggle = HealthTab:AddToggle("AutoUpdateNPCHealth", {
        Title = "Auto Update NPC Health",
        Default = false,
        Callback = function(value)
            _G.AutoNPCHealth = value
            if value then
                local connection
                connection = RunService.Heartbeat:Connect(function()
                    if not _G.AutoNPCHealth then
                        if connection then
                            connection:Disconnect()
                        end
                        return
                    end
                    updateNPCHealthDisplay()
                end)
            end
        end
    })
    
    HealthTab:AddButton({
        Title = "Update NPC Health Status",
        Description = "",
        Callback = function()
            updateNPCHealthDisplay()
            Fluent:Notify({
                Title = "NPC Health",
                Content = "NPC health status updated",
                Duration = 2
            })
        end
    })
    
    HealthTab:AddButton({
        Title = "Clear NPC Health Display",
        Description = "",
        Callback = function()
            npcHealthText:SetDesc("NPC health information will appear here")
            Fluent:Notify({
                Title = "NPC Health",
                Content = "Display cleared",
                Duration = 2
            })
        end
    })
    
    HealthTab:AddButton({
        Title = "Reset to Normal View",
        Description = "",
        Callback = function()
            updateNPCHealthDisplay()
            Fluent:Notify({
                Title = "NPC Health",
                Content = "Display reset to normal view",
                Duration = 2
            })
        end
    })
end

-- Initialize Player Health variables
_G.PlayerHealthParagraph = nil
_G.AutoPlayerHealth = false
_G.AutoPlayerHealthConnection = nil

-- Function to get Player health status from PlayerFolder
local function getPlayerHealthStatus()
    local playerStatus = {}
    
    local playerFolder = workspace:FindFirstChild("#GAME") and 
                        workspace["#GAME"]:FindFirstChild("Folders") and 
                        workspace["#GAME"].Folders:FindFirstChild("VisibleInstances") and 
                        workspace["#GAME"].Folders.VisibleInstances:FindFirstChild("HumanoidFolder") and 
                        workspace["#GAME"].Folders.VisibleInstances.HumanoidFolder:FindFirstChild("PlayerFolder")
    
    if playerFolder then
        for _, playerModel in ipairs(playerFolder:GetChildren()) do
            if playerModel:IsA("Model") then
                local humanoid = playerModel:FindFirstChildOfClass("Humanoid")
                if humanoid then
                    local currentHealth = math.floor(humanoid.Health)
                    local maxHealth = math.floor(humanoid.MaxHealth)
                    
                    local healthText = "(" .. currentHealth .. "/" .. maxHealth .. ")"
                    
                    table.insert(playerStatus, {
                        name = playerModel.Name,
                        health = healthText,
                        currentHealth = currentHealth,
                        maxHealth = maxHealth
                    })
                end
            end
        end
    end
    
    return playerStatus
end

-- Function to update Player health display
local function updatePlayerHealthDisplay()
    if not _G.PlayerHealthParagraph then return end
    
    local playerStatus = getPlayerHealthStatus()
    local displayText = ""
    local maxDisplayLines = 15
    
    if #playerStatus > 0 then
        table.sort(playerStatus, function(a, b)
            return a.name < b.name
        end)
        
        local displayedCount = 0
        for i = 1, #playerStatus do
            if displayedCount >= maxDisplayLines then break end
            
            local status = playerStatus[i]
            local healthPercent = math.floor((status.currentHealth / status.maxHealth) * 100)
            local line = status.name .. " = " .. status.health .. " [" .. healthPercent .. "%]"
            
            displayText = displayText .. line
            
            if i < #playerStatus and displayedCount < maxDisplayLines - 1 then
                displayText = displayText .. "\n"
            end
            
            displayedCount = displayedCount + 1
        end
        
        if #playerStatus > maxDisplayLines then
            displayText = displayText .. "\n... and " .. (#playerStatus - maxDisplayLines) .. " more players"
        end
        
        displayText = displayText .. "\n\nTotal Players: " .. #playerStatus
        local aliveCount = 0
        for _, status in ipairs(playerStatus) do
            if status.currentHealth > 0 then
                aliveCount = aliveCount + 1
            end
        end
        displayText = displayText .. " (Alive: " .. aliveCount .. ")"
    else
        displayText = "No players found in PlayerFolder or no humanoids detected"
    end
    
    _G.PlayerHealthParagraph:Set(displayText)
end

-- Create a section first
local PlayerHealthSection = Tabs.HealthNPCs:AddSection("Player Health")

-- Add Paragraph for Player Health Display
_G.PlayerHealthParagraph = PlayerHealthSection:AddParagraph({
    Title = "Player Health Status",
    Content = "Player health information will appear here"
})

-- Auto Update Toggle
PlayerHealthSection:AddToggle("AutoUpdatePlayerHealth", {
    Title = "Auto Update Players Health",
    Description = "Automatically update player health status",
    Default = false,
    Callback = function(Value)
        _G.AutoPlayerHealth = Value
        
        if Value then
            if _G.AutoPlayerHealthConnection then
                _G.AutoPlayerHealthConnection:Disconnect()
            end
            
            _G.AutoPlayerHealthConnection = game:GetService("RunService").Heartbeat:Connect(function()
                if _G.AutoPlayerHealth then
                    updatePlayerHealthDisplay()
                end
            end)
        else
            if _G.AutoPlayerHealthConnection then
                _G.AutoPlayerHealthConnection:Disconnect()
                _G.AutoPlayerHealthConnection = nil
            end
        end
    end
})

-- Manual Update Button
PlayerHealthSection:AddButton({
    Title = "Update Player Health Status",
    Description = "Manually update player health display",
    Callback = function()
        updatePlayerHealthDisplay()
        if Fluent and Fluent.Notify then
            Fluent:Notify({
                Title = "Player Health",
                Content = "Player health status updated",
                Duration = 2
            })
        else
            print("Player health status updated")
        end
    end
})

-- Clear Display Button
PlayerHealthSection:AddButton({
    Title = "Clear Player Health Display",
    Description = "Clear the player health information",
    Callback = function()
        if _G.PlayerHealthParagraph then
            _G.PlayerHealthParagraph:Set("Player health information will appear here")
        end
        if Fluent and Fluent.Notify then
            Fluent:Notify({
                Title = "Player Health",
                Content = "Player display cleared",
                Duration = 2
            })
        else
            print("Player display cleared")
        end
    end
})

-- Reset View Button
PlayerHealthSection:AddButton({
    Title = "Reset Player View",
    Description = "Reset to normal player health view",
    Callback = function()
        updatePlayerHealthDisplay()
        if Fluent and Fluent.Notify then
            Fluent:Notify({
                Title = "Player Health",
                Content = "Player display reset to normal view",
                Duration = 2
            })
        else
            print("Player display reset to normal view")
        end
    end
})

do
    local OtherTab = Tabs.OtherStuff
    
    OtherTab:AddParagraph({
        Title = "Health Expander/Giver",
        Content = ""
    })
    
    local tankNameInput = OtherTab:AddInput("TankName", {
        Title = "Tank Name",
        Default = "",
        Placeholder = "Enter tank name...",
        Numeric = false,
        Finished = false,
        Callback = function(value)
            -- Store tank name
        end
    })
    
    local function equipAndDestroyTank()
        local tankName = tankNameInput.Value
        if tankName == "" then
            Fluent:Notify({
                Title = "Health Expander",
                Content = "Please enter a tank name first!",
                Duration = 3
            })
            return false
        end
        
        local player = localPlayer
        local character = player.Character
        if not character then
            Fluent:Notify({
                Title = "Health Expander",
                Content = "No character found!",
                Duration = 3
            })
            return false
        end
        
        local tankTool = player.Backpack:FindFirstChild(tankName)
        
        if not tankTool then
            tankTool = character:FindFirstChild(tankName)
        end
        
        if not tankTool then
            for _, item in ipairs(player.Backpack:GetChildren()) do
                if item:IsA("Tool") and string.find(item.Name:lower(), "tank") then
                    tankTool = item
                    break
                end
            end
            
            if not tankTool then
                for _, item in ipairs(character:GetChildren()) do
                    if item:IsA("Tool") and string.find(item.Name:lower(), "tank") then
                        tankTool = item
                        break
                    end
                end
            end
        end
        
        if tankTool then
            if tankTool.Parent == player.Backpack then
                local currentTool = character:FindFirstChildWhichIsA("Tool")
                if currentTool then
                    currentTool.Parent = player.Backpack
                    task.wait(0.1)
                end
                
                tankTool.Parent = character
                task.wait(0.2)
            end
            
            tankTool:Destroy()
            
            Fluent:Notify({
                Title = "Health Expander",
                Content = "Equipped and destroyed tank: " .. tankName,
                Duration = 3
            })
            
            return true
        else
            Fluent:Notify({
                Title = "Health Expander",
                Content = "Could not find tank: " .. tankName,
                Duration = 3
            })
            return false
        end
    end
    
    OtherTab:AddButton({
        Title = "Equip & Destroy Tank",
        Description = "",
        Callback = function()
            equipAndDestroyTank()
        end
    })
    
    -- Pet Clicker
    OtherTab:AddParagraph({
        Title = "Pet Clicker",
        Content = ""
    })
    
    local petNames = {
        "Turkey Pet",
        "Chicken Noob Pet",
        "Corrupted Black Hole Pet",
        "Pouwk",
        "BULLkiePouwk",
        "Sjebullepouwker",
        "BULL"
    }
    
    local selectedPet = ""
    
    local petDropdown = OtherTab:AddDropdown("PetDropdown", {
        Title = "Select Pet",
        Values = petNames,
        Default = "",
        Multi = false,
        Callback = function(value)
            selectedPet = value
        end
    })
    
    local function autoClickPet()
        while _G.isAutoClickingPet do
            local player = localPlayer
            local displayName = player.DisplayName
            
            if selectedPet == "" then
                task.wait(0.5)
                return
            end
            
            local petFolder = workspace:WaitForChild("#GAME"):WaitForChild("Folders"):WaitForChild("HumanoidFolder"):WaitForChild("NPCFolder"):WaitForChild("PetFolder")
            local petName = displayName .. "'s " .. selectedPet
            local petModel = petFolder:FindFirstChild(petName)
            
            if petModel then
                local clickDetector = petModel:FindFirstChildOfClass("ClickDetector")
                
                if clickDetector then
                    fireclickdetector(clickDetector)
                    task.wait(0.1)
                else
                    Fluent:Notify({
                        Title = "Pet Auto-Clicker",
                        Content = "ClickDetector not found for " .. petName .. ", retrying...",
                        Duration = 3
                    })
                    task.wait(0.5)
                end
            else
                Fluent:Notify({
                    Title = "Pet Auto-Clicker",
                    Content = "Pet model not found: " .. petName .. ", retrying...",
                    Duration = 3
                })
                task.wait(0.5)
            end
        end
    end
    
    local autoClickPetToggle = OtherTab:AddToggle("AutoClickPet", {
        Title = "Auto Click Pet",
        Default = false,
        Callback = function(value)
            _G.isAutoClickingPet = value
            
            if value then
                if selectedPet == "" then
                    Fluent:Notify({
                        Title = "Pet Auto-Clicker",
                        Content = "Please select a pet first!",
                        Duration = 3
                    })
                    return
                end
                
                task.spawn(function()
                    autoClickPet()
                end)
                
                Fluent:Notify({
                    Title = "Pet Auto-Clicker",
                    Content = "Started auto-clicking " .. selectedPet,
                    Duration = 3
                })
            else
                _G.isAutoClickingPet = false
                Fluent:Notify({
                    Title = "Pet Auto-Clicker",
                    Content = "Stopped auto-clicking pet",
                    Duration = 3
                })
            end
        end
    })
    
    -- Secret Prices Shower
    OtherTab:AddParagraph({
        Title = "Secret Prices Shower",
        Content = ""
    })
    
    local priceButtons = {
        {name = "Bob Pet", price = "14703 Cookies"},
        {name = "UZYeah Gun", price = "0 Coins (Only if tester/dev)"},
        {name = "Smiley Sucker Gun", price = "0 Coins (Only if tester/dev)"},
        {name = "Revolvahhh Gun", price = "0 Coins (Only if tester/dev)"},
        {name = "Easter Egg Pet", price = "-1 Coins"},
        {name = "Clown Mouse Pet", price = "0 Coins (Need Anniversary 2024 - Secret Badge)"},
        {name = "Evaluator Pet", price = "0 Coins (Only if tester/dev)"},
        {name = "Pouwk Pet", price = "0 Coins (Need Meet the Co-Owner Badge)"},
        {name = "SGobbler Pet", price = "0 Coins (Need Like Game + Join Group)"},
        {name = "Easter Doggo Pet", price = "0 Coins (Need Easter 2024 - Egg-Gathering Gladiator Badge)"},
        {name = "Scammer Pet", price = "0 Coins (Only if tester/dev)"},
        {name = "BULLkiePouwk Pet", price = "0 Coins (Need Secret Badge Valentines 2024)"},
        {name = "Cracked Bas Pet", price = "0 Coins (Need Secret Badge 1)"},
        {name = "Sjebullepouwker Pet", price = "0 Coins (Need Secret Badge Valentines 2025)"},
        {name = "BULL Pet", price = "0 Coins (Need Meet the Owner Badge)"},
        {name = "Exclusive 100k Pet", price = "100k Coins/Bites (Need Be First Player To Obtain)"},
        {name = "CRACKED Mode Item", price = "0 Coins (Need Super Secret Badge 1)"},
        {name = "Bunny Ears Item", price = "0 Coins (Need Hatched Badge)"},
        {name = "Eggstinction Rush X Item", price = "0 Coins (Need Easter 2025 - Path to Eggstinction Badge)"},
        {name = "Hatred Item", price = "0 Coins (Need Secret Badge 2)"},
        {name = "???", price = "0 Coins (Need Super Secret Badge 2)"}
    }
    
    for _, buttonInfo in ipairs(priceButtons) do
        OtherTab:AddButton({
            Title = "Check " .. buttonInfo.name .. " Price",
            Description = "",
            Callback = function()
                Fluent:Notify({
                    Title = buttonInfo.name .. " Cost",
                    Content = buttonInfo.price,
                    Duration = 5
                })
            end
        })
    end
    
    OtherTab:AddButton({
        Title = "Check Black Bas Pet Price",
        Description = "",
        Callback = function()
            local cost = workspace:GetAttribute("BlackBasCost")
            if cost then
                Fluent:Notify({
                    Title = "Black Bas Cost Found",
                    Content = "Black Bas Cost Coins is: " .. tostring(cost),
                    Duration = 5
                })
            else
                Fluent:Notify({
                    Title = "Black Bas Cost Not Found",
                    Content = "The 'BlackBasCost' attribute was not found",
                    Duration = 5
                })
            end
        end
    })
end

ChangelogsTab = Tabs.Changelogs

ChangelogsTab:AddParagraph({
    Title = "Hub Version",
    Content = "Latest updates and changes"
})

-- Add multiple changelog entries using paragraphs
ChangelogsTab:AddParagraph({
    Title = "V. 3.5.7",
    Content = [[
[-] Removed Negative Coins Option On Auto Eat Choosed Type Dropdown (Its Same As Stink Coins)
[x] Fixed Auto Eat Burgers Option On Auto Eat Choosed Type Dropdown (Was Eating Only 3-4 Burgers)
[x] Fixed Auto Eat Pouwkoins/BULLoney Options On Auto Eat Choosed Type Dropdown (Was Eating All Noobs)
[+] Added 3 More Guns To Support For All Auto Shoots (Firework Launcher, Nubids Bow and Pumpkin Launcher)
[+] Added Auto Use Hatred Tool Toggle
[x] Fixed Auto Bring NPC's Toggle (Was Bringing Bas From Chair Too)
[-] Removed Delete All NPC's Once Button
[+] Added Auto Spawn Noobs From Pad Toggle
[x] Fixed Teleport To Hatred Button (Was Path Issue)
[x] Fixed Click GERARD Button (Was Path Issue)
[+] Added Auto Click GERARD (24 Times Only Max) Toggle
[+] Added Anniversary 2024 - Secret Badge Section
[+] Added Auto Shoot Stuff Only On Party Balloons
[+] Added Auto Bring Clown Mouse (Kinda Works) Toggle
[+] Added Clown Mouse ESP Toggle
[+] Added On Equip/Unequip/Shop Tab New Items (Evaluator, Balloon and Party Hat)
[+] Added Boombox Stuff Section
[+] Added Put Any Roblox Music/Sound ID Textbox
[+] Added Apply Custom Music/Sound Button
[+] Added Show Evaluator Pet Price Button

Settings:
[+] = Added
[x] = Fixed/Changed
[-] = Removed
]]
})

CreditsTab = Tabs.Credits

CreditsTab:AddParagraph({
    Title = "Credits & Special Thanks",
    Content = "Thanks to everyone who contributed!"
})

CreditsTab:AddParagraph({
    Title = "Credits Users",
    Content = [[
Scripter - (Youtube, Discord)
ZScriptX - Discord
]]
})

CreditsTab:AddParagraph({
    Title = "Helpers",
    Content = "ZScriptX - Auto Shoot"
})

-- Add link buttons
local linksSection = CreditsTab:AddSection("Links", "Left")

linksSection:AddButton({
    Title = "Scripter (Youtube)",
    Description = "Copy YouTube link to clipboard",
    Callback = function()
        setclipboard("https://www.youtube.com/@Scripter-Coder")
        Fluent:Notify({
            Title = "Link Copied",
            Content = "YouTube link copied to clipboard!",
            Duration = 3
        })
    end
})

linksSection:AddButton({
    Title = "Scripter (Discord)",
    Description = "Copy Discord link to clipboard",
    Callback = function()
        setclipboard("https://discord.gg/k8vJHZM6")
        Fluent:Notify({
            Title = "Link Copied",
            Content = "Discord link copied to clipboard!",
            Duration = 3
        })
    end
})

linksSection:AddButton({
    Title = "ZScriptX (Discord)",
    Description = "Copy Discord link to clipboard",
    Callback = function()
        setclipboard("https://discord.gg/HvevRJVWWm")
        Fluent:Notify({
            Title = "Link Copied",
            Content = "Discord link copied to clipboard!",
            Duration = 3
        })
    end
})

-- SETTINGS TAB - Using Tabs.Settings from your Tabs table
SettingsTab = Tabs.Settings

-- Add sections
local otherStuffSection = SettingsTab:AddSection("Other Stuff", "Left")
local safespotSection = SettingsTab:AddSection("Safespot Stuff", "Right")
local antiSettingsSection = SettingsTab:AddSection("Anti Settings", "Left")
local serverSettingsSection = SettingsTab:AddSection("Server Settings", "Right")
local destroyScriptSection = SettingsTab:AddSection("Destroy Script", "Left")

-- Freecam and Noclip System
local FreecamController = {
    isFreecamEnabled = false,
    freecamConnection = nil,
    originalCameraType = nil,
    originalCFrame = nil,
    isNoclipEnabled = false,
    noclipConnection = nil,
    freecamSpeed = 5,
    freecamSensitivity = 0.5,
    freecamCFrame = nil
}

-- Freecam functions
function FreecamController:enableFreecam()
    if self.isFreecamEnabled then return end
    
    local player = game.Players.LocalPlayer
    local camera = workspace.CurrentCamera
    
    self.originalCameraType = camera.CameraType
    self.originalCFrame = camera.CFrame
    camera.CameraType = Enum.CameraType.Scriptable
    
    local character = player.Character
    if character then
        local humanoidRootPart = character:FindFirstChild("HumanoidRootPart")
        if humanoidRootPart then
            self.freecamCFrame = humanoidRootPart.CFrame + Vector3.new(0, 5, 0)
            camera.CFrame = self.freecamCFrame
        else
            self.freecamCFrame = CFrame.new(0, 10, 0)
            camera.CFrame = self.freecamCFrame
        end
    else
        self.freecamCFrame = CFrame.new(0, 10, 0)
        camera.CFrame = self.freecamCFrame
    end
    
    self.isFreecamEnabled = true
    self.freecamConnection = game:GetService("RunService").RenderStepped:Connect(function(deltaTime)
        if not self.isFreecamEnabled then return end
        
        local inputService = game:GetService("UserInputService")
        local moveVector = Vector3.new(0, 0, 0)
        
        if inputService:IsKeyDown(Enum.KeyCode.W) then
            moveVector = moveVector + camera.CFrame.LookVector
        end
        if inputService:IsKeyDown(Enum.KeyCode.S) then
            moveVector = moveVector - camera.CFrame.LookVector
        end
        if inputService:IsKeyDown(Enum.KeyCode.A) then
            moveVector = moveVector - camera.CFrame.RightVector
        end
        if inputService:IsKeyDown(Enum.KeyCode.D) then
            moveVector = moveVector + camera.CFrame.RightVector
        end
        if inputService:IsKeyDown(Enum.KeyCode.Space) then
            moveVector = moveVector + Vector3.new(0, 1, 0)
        end
        if inputService:IsKeyDown(Enum.KeyCode.LeftControl) or inputService:IsKeyDown(Enum.KeyCode.RightControl) then
            moveVector = moveVector - Vector3.new(0, 1, 0)
        end
        
        if moveVector.Magnitude > 0 then
            moveVector = moveVector.Unit * self.freecamSpeed
            self.freecamCFrame = self.freecamCFrame + (moveVector * deltaTime * 60)
        end
        
        local delta = inputService:GetMouseDelta()
        if delta.X ~= 0 or delta.Y ~= 0 then
            local yaw = delta.X * self.freecamSensitivity * 0.01
            local pitch = delta.Y * self.freecamSensitivity * 0.01
            
            local currentCFrame = self.freecamCFrame
            local yawCFrame = CFrame.fromAxisAngle(Vector3.new(0, 1, 0), -yaw)
            local pitchCFrame = CFrame.fromAxisAngle(currentCFrame.RightVector, -pitch)
            
            self.freecamCFrame = currentCFrame * yawCFrame * pitchCFrame
        end
        
        camera.CFrame = self.freecamCFrame
    end)
    
    Fluent:Notify({
        Title = "Freecam",
        Content = "Freecam enabled! Use WASD + Space/Ctrl to move, mouse to look",
        Duration = 5
    })
end

function FreecamController:disableFreecam()
    if not self.isFreecamEnabled then return end
    
    self.isFreecamEnabled = false
    if self.freecamConnection then
        self.freecamConnection:Disconnect()
        self.freecamConnection = nil
    end
    
    local camera = workspace.CurrentCamera
    camera.CameraType = self.originalCameraType or Enum.CameraType.Custom
    
    local player = game.Players.LocalPlayer
    local character = player.Character
    if character then
        local humanoidRootPart = character:FindFirstChild("HumanoidRootPart")
        if humanoidRootPart then
            camera.CFrame = humanoidRootPart.CFrame + Vector3.new(0, 5, -10)
        end
    end
    
    self.freecamCFrame = nil
    self.originalCameraType = nil
    self.originalCFrame = nil
end

function FreecamController:enableNoclip()
    if self.isNoclipEnabled then return end
    
    self.isNoclipEnabled = true
    
    local function noclipLoop()
        if not self.isNoclipEnabled then return end
        
        local character = game.Players.LocalPlayer.Character
        if character then
            for _, part in pairs(character:GetDescendants()) do
                if part:IsA("BasePart") and part.CanCollide then
                    part.CanCollide = false
                end
            end
        end
    end
    
    self.noclipConnection = game:GetService("RunService").Stepped:Connect(noclipLoop)
    
    Fluent:Notify({
        Title = "Noclip",
        Content = "Noclip enabled - You can pass through walls",
        Duration = 3
    })
end

function FreecamController:disableNoclip()
    if not self.isNoclipEnabled then return end
    
    self.isNoclipEnabled = false
    
    if self.noclipConnection then
        self.noclipConnection:Disconnect()
        self.noclipConnection = nil
    end
    
    local character = game.Players.LocalPlayer.Character
    if character then
        for _, part in pairs(character:GetDescendants()) do
            if part:IsA("BasePart") then
                part.CanCollide = true
            end
        end
    end
end

game.Players.LocalPlayer.CharacterRemoving:Connect(function()
    FreecamController:disableFreecam()
    FreecamController:disableNoclip()
end)

-- Add Freecam controls to Other Stuff section
otherStuffSection:AddButton({
    Title = "Freecam Enable",
    Callback = function()
        FreecamController:enableFreecam()
    end
})

otherStuffSection:AddButton({
    Title = "Freecam Disable",
    Callback = function()
        FreecamController:disableFreecam()
    end
})

otherStuffSection:AddToggle("NoclipToggle", {
    Title = "Noclip",
    Default = false,
    Callback = function(value)
        if value then
            FreecamController:enableNoclip()
        else
            FreecamController:disableNoclip()
        end
    end
})

otherStuffSection:AddSlider("FreecamSpeed", {
    Title = "Freecam Speed",
    Min = 1,
    Max = 50,
    Default = 5,
    Increment = 1,
    Rounding = 0,  -- Add this line
    Callback = function(value)
        FreecamController.freecamSpeed = value
    end
})

-- For the Freecam Sensitivity slider:
otherStuffSection:AddSlider("FreecamSensitivity", {
    Title = "Freecam Sensitivity",
    Min = 0.1,
    Max = 2,
    Default = 0.5,
    Increment = 0.1,
    Rounding = 1,  -- 1 decimal place
    Callback = function(value)
        FreecamController.freecamSensitivity = value
    end
})

otherStuffSection:AddButton({
    Title = "Return to Character",
    Callback = function()
        if FreecamController.isFreecamEnabled then
            local player = game.Players.LocalPlayer
            local character = player.Character
            local camera = workspace.CurrentCamera
            
            if character then
                local humanoidRootPart = character:FindFirstChild("HumanoidRootPart")
                if humanoidRootPart then
                    FreecamController.freecamCFrame = humanoidRootPart.CFrame + Vector3.new(0, 5, -10)
                    camera.CFrame = FreecamController.freecamCFrame
                end
            end
        end
    end
})

-- Freeze/Unfreeze System
local FreezeSystem = {
    isFrozen = false,
    originalAnchored = {},
    originalGravity = nil
}

local function freezeCharacter()
    local player = game.Players.LocalPlayer
    local character = player.Character
    if not character then return end
    
    if FreezeSystem.isFrozen then
        Fluent:Notify({
            Title = "Freeze",
            Content = "Character is already frozen!",
            Duration = 2
        })
        return
    end
    
    FreezeSystem.originalAnchored = {}
    FreezeSystem.originalGravity = workspace.Gravity
    
    for _, part in ipairs(character:GetDescendants()) do
        if part:IsA("BasePart") then
            FreezeSystem.originalAnchored[part] = part.Anchored
            part.Anchored = true
            part.Velocity = Vector3.new(0, 0, 0)
            part.RotVelocity = Vector3.new(0, 0, 0)
            part.CFrame = part.CFrame
        end
    end
    
    local humanoid = character:FindFirstChildOfClass("Humanoid")
    if humanoid then
        humanoid.WalkSpeed = 0
        humanoid.JumpPower = 0
        for _, track in pairs(humanoid:GetPlayingAnimationTracks()) do
            track:Stop()
        end
    end
    
    workspace.Gravity = 0
    FreezeSystem.isFrozen = true
    
    Fluent:Notify({
        Title = "Freeze",
        Content = "Character frozen successfully!",
        Duration = 3
    })
end

local function unfreezeCharacter()
    local player = game.Players.LocalPlayer
    local character = player.Character
    if not character then return end
    
    if not FreezeSystem.isFrozen then
        Fluent:Notify({
            Title = "Unfreeze",
            Content = "Character is not frozen!",
            Duration = 2
        })
        return
    end
    
    for part, wasAnchored in pairs(FreezeSystem.originalAnchored) do
        if part and part.Parent then
            part.Anchored = wasAnchored
        end
    end
    
    local humanoid = character:FindFirstChildOfClass("Humanoid")
    if humanoid then
        humanoid.WalkSpeed = 16
        humanoid.JumpPower = 50
    end
    
    if FreezeSystem.originalGravity then
        workspace.Gravity = FreezeSystem.originalGravity
    else
        workspace.Gravity = 196.2
    end
    
    FreezeSystem.originalAnchored = {}
    FreezeSystem.originalGravity = nil
    FreezeSystem.isFrozen = false
    
    Fluent:Notify({
        Title = "Unfreeze",
        Content = "Character unfrozen successfully!",
        Duration = 3
    })
end

-- Add Freeze buttons
otherStuffSection:AddButton({
    Title = "Freeze",
    Callback = function()
        freezeCharacter()
    end
})

otherStuffSection:AddButton({
    Title = "Unfreeze",
    Callback = function()
        unfreezeCharacter()
    end
})

-- Teleport Platform System (Simplified for Fluent)
local TeleportPlatform = {
    platformName = "TeleportPlatform",
    platform = nil,
    platformPosition = Vector3.new(55, -46, -262),
    platformSize = Vector3.new(100, 1, 100),
    isAutoTeleportEnabled = false,
    teleportConnection = nil,
    teleportCooldown = 10,
    lastTeleportTime = 0,
    isPlatformCreated = false
}

function TeleportPlatform:createPlatform()
    if workspace:FindFirstChild(self.platformName) then
        workspace[self.platformName]:Destroy()
    end
    
    local platform = Instance.new("Part")
    platform.Name = self.platformName
    platform.Size = self.platformSize
    platform.Position = self.platformPosition
    platform.Anchored = true
    platform.CanCollide = true
    platform.Transparency = 0.5
    platform.Color = Color3.new(1, 0.5, 0)
    platform.Material = Enum.Material.Neon
    platform.Parent = workspace
    
    local light = Instance.new("SurfaceLight", platform)
    light.Brightness = 0.5
    light.Face = Enum.NormalId.Top
    light.Range = 20
    light.Color = Color3.new(1, 0.6, 0.2)
    
    self.platform = platform
    self.isPlatformCreated = true
    
    Fluent:Notify({
        Title = "Platform",
        Content = "Platform created at position (55, -46, -262)",
        Duration = 3
    })
    
    return platform
end

function TeleportPlatform:removePlatform()
    if workspace:FindFirstChild(self.platformName) then
        workspace[self.platformName]:Destroy()
        self.platform = nil
        self.isPlatformCreated = false
        
        Fluent:Notify({
            Title = "Platform",
            Content = "Platform removed",
            Duration = 3
        })
    end
end

function TeleportPlatform:teleportToPlatform()
    local character = game.Players.LocalPlayer.Character
    if not character then return false end
    
    local humanoidRootPart = character:FindFirstChild("HumanoidRootPart")
    if not humanoidRootPart then return false end
    
    if not self.isPlatformCreated then
        self:createPlatform()
    end
    
    local humanoid = character:FindFirstChildOfClass("Humanoid")
    if not humanoid or humanoid.Health <= 0 then
        return false
    end
    
    humanoidRootPart.CFrame = CFrame.new(self.platformPosition + Vector3.new(0, 5, 0))
    self.lastTeleportTime = tick()
    
    Fluent:Notify({
        Title = "Teleport",
        Content = "Teleported to platform!",
        Duration = 2
    })
    
    return true
end

function TeleportPlatform:startAutoTeleport()
    if self.isAutoTeleportEnabled then return end
    
    if not self.isPlatformCreated then
        self:createPlatform()
    end
    
    self.isAutoTeleportEnabled = true
    self.lastTeleportTime = 0
    
    self.teleportConnection = game:GetService("RunService").Heartbeat:Connect(function()
        if not self.isAutoTeleportEnabled then return end
        
        local currentTime = tick()
        if currentTime - self.lastTeleportTime >= self.teleportCooldown then
            self:teleportToPlatform()
        end
    end)
    
    Fluent:Notify({
        Title = "Auto Teleport",
        Content = "Auto-teleport enabled! Teleporting every " .. self.teleportCooldown .. " seconds",
        Duration = 3
    })
end

function TeleportPlatform:stopAutoTeleport()
    if not self.isAutoTeleportEnabled then return end
    
    self.isAutoTeleportEnabled = false
    
    if self.teleportConnection then
        self.teleportConnection:Disconnect()
        self.teleportConnection = nil
    end
    
    Fluent:Notify({
        Title = "Auto Teleport",
        Content = "Auto-teleport disabled",
        Duration = 3
    })
end

-- Add Teleport Platform controls to Safespot section
safespotSection:AddButton({
    Title = "Create Platform",
    Callback = function()
        TeleportPlatform:createPlatform()
    end
})

safespotSection:AddButton({
    Title = "Remove Platform",
    Callback = function()
        TeleportPlatform:removePlatform()
        if TeleportPlatform.isAutoTeleportEnabled then
            TeleportPlatform:stopAutoTeleport()
        end
    end
})

safespotSection:AddButton({
    Title = "Teleport Once",
    Callback = function()
        TeleportPlatform:teleportToPlatform()
    end
})

safespotSection:AddToggle("AutoTeleportToggle", {
    Title = "Auto Teleport",
    Default = false,
    Callback = function(value)
        if value then
            TeleportPlatform:startAutoTeleport()
        else
            TeleportPlatform:stopAutoTeleport()
        end
    end
})

safespotSection:AddSlider("TeleportCooldown", {
    Title = "Teleport Every (seconds)",
    Min = 1,
    Max = 60,
    Default = 10,
    Increment = 1,
    Rounding = 0,  -- Add this line
    Callback = function(value)
        TeleportPlatform.teleportCooldown = value
        if TeleportPlatform.isAutoTeleportEnabled then
            TeleportPlatform:stopAutoTeleport()
            task.wait(0.1)
            TeleportPlatform:startAutoTeleport()
        end
    end
})

safespotSection:AddButton({
    Title = "Quick Setup",
    Callback = function()
        if not TeleportPlatform.isPlatformCreated then
            TeleportPlatform:createPlatform()
            task.wait(0.5)
        end
        
        if not TeleportPlatform.isAutoTeleportEnabled then
            TeleportPlatform:startAutoTeleport()
        end
        
        Fluent:Notify({
            Title = "Quick Setup",
            Content = "Platform created and auto-teleport enabled!",
            Duration = 3
        })
    end
})

safespotSection:AddButton({
    Title = "Full Reset",
    Callback = function()
        TeleportPlatform:stopAutoTeleport()
        TeleportPlatform:removePlatform()
        
        Fluent:Notify({
            Title = "Reset",
            Content = "Platform removed and auto-teleport stopped",
            Duration = 3
        })
    end
})

-- Anti Settings
antiSettingsSection:AddButton({
    Title = "Anti Void",
    Callback = function()
        if workspace:FindFirstChild("AntiVoid1") == nil then
            local function createAntiVoidPart(name, positionX, positionY, positionZ, color)
                local AntiVoid = Instance.new("Part", workspace)
                AntiVoid.Name = name
                AntiVoid.CFrame = CFrame.new(positionX, positionY, positionZ, 1, 0, 0, 0, 1, 0, 0, 0, 1)
                AntiVoid.Size = Vector3.new(2044, 1, 2044)
                AntiVoid.Anchored = true
                AntiVoid.CanCollide = true
                AntiVoid.Transparency = 0.8
                AntiVoid.Material = Enum.Material.Neon
                AntiVoid.BrickColor = BrickColor.new(color)
                
                local SurfaceLight = Instance.new("SurfaceLight", AntiVoid)
                SurfaceLight.Brightness = 0.5
                SurfaceLight.Face = Enum.NormalId.Top
                SurfaceLight.Range = 10
                SurfaceLight.Color = Color3.new(0, 0.5, 1)
                
                local SelectionBox = Instance.new("SelectionBox", AntiVoid)
                SelectionBox.Adornee = AntiVoid
                SelectionBox.Color3 = Color3.new(0, 0.7, 1)
                SelectionBox.Transparency = 0.5
                SelectionBox.LineThickness = 0.05
                
                Fluent:Notify({
                    Title = "Anti Void",
                    Content = "Created anti-void at position",
                    Duration = 3
                })
                
                return AntiVoid
            end
            
            createAntiVoidPart("AntiVoid1", 0, -40, 0, "Bright blue")
            createAntiVoidPart("AntiVoid2", 992, -40, -233, "Bright green")
            createAntiVoidPart("AntiVoid3", -1018, -40, -222, "Bright yellow")
            
            Fluent:Notify({
                Title = "Anti Void",
                Content = "3 Floating anti-voids created!",
                Duration = 5
            })
        else
            local removedCount = 0
            for _, part in pairs(workspace:GetChildren()) do
                if string.find(part.Name, "AntiVoid") then
                    part:Destroy()
                    removedCount = removedCount + 1
                end
            end
            Fluent:Notify({
                Title = "Anti Void",
                Content = removedCount .. " anti-voids removed successfully!",
                Duration = 3
            })
        end
    end
})

-- Anti Sit Toggle
_G.isAntiSit = false
_G.setAllSeatsCanTouch = function(canTouch)
    for _, seat in pairs(workspace:GetDescendants()) do
        if seat:IsA("VehicleSeat") or seat:IsA("Seat") then
            seat.CanTouch = canTouch
        end
    end
end

antiSettingsSection:AddToggle("AntiSitToggle", {
    Title = "Anti Sit",
    Default = false,
    Callback = function(Value)
        _G.isAntiSit = Value
        if Value then
            _G.setAllSeatsCanTouch(false)
        else
            _G.setAllSeatsCanTouch(true)
        end
    end
})

antiSettingsSection:AddToggle("AntiAfkToggle", {
    Title = "Anti Afk",
    Default = false,
    Callback = function(Value)
        _G.AntiAfk = Value
        local VirtualUser = game:GetService('VirtualUser')
        game:GetService('Players').LocalPlayer.Idled:Connect(function()
            VirtualUser:CaptureController()
            VirtualUser:ClickButton2(Vector2.new())
        end)
    end
})

antiSettingsSection:AddToggle("AntiKickToggle", {
    Title = "Anti Kick",
    Default = false,
    Callback = function(Value)
        _G.AntiKick = Value
        while _G.AntiKick do
            for i,v in pairs(game.CoreGui.RobloxPromptGui.promptOverlay:GetDescendants()) do
                if v.Name == "ErrorPrompt" then
                    game:GetService("TeleportService"):TeleportToPlaceInstance(game.PlaceId, game.JobId, game.Players.LocalPlayer)
                end
            end
            task.wait()
        end
    end
})

-- Server Settings
serverSettingsSection:AddButton({
    Title = "Rejoin",
    Callback = function()
        loadstring(game:HttpGet("https://raw.githubusercontent.com/Jelly-plays/Rejoin-script/main/obf_L744By559M18BbuseSG6en8r1zL31daK9060LV7WyvmS4bQp92aONWfwRE36FdcZ.lua.txt"))()
    end
})

serverSettingsSection:AddButton({
    Title = "ServerHop (Regular Server)",
    Callback = function()
        local PlaceID = game.PlaceId
        local AllIDs = {}
        local foundAnything = ""
        local actualHour = os.date("!*t").hour
        
        local File = pcall(function()
            AllIDs = game:GetService('HttpService'):JSONDecode(readfile("NotSameServers.json"))
        end)
        if not File then
            table.insert(AllIDs, actualHour)
            writefile("NotSameServers.json", game:GetService('HttpService'):JSONEncode(AllIDs))
        end
        
        function TPReturner()
            local Site;
            if foundAnything == "" then
                Site = game.HttpService:JSONDecode(game:HttpGet('https://games.roblox.com/v1/games/' .. PlaceID .. '/servers/Public?sortOrder=Asc&limit=100'))
            else
                Site = game.HttpService:JSONDecode(game:HttpGet('https://games.roblox.com/v1/games/' .. PlaceID .. '/servers/Public?sortOrder=Asc&limit=100&cursor=' .. foundAnything))
            end
            
            local ID = ""
            if Site.nextPageCursor and Site.nextPageCursor ~= "null" and Site.nextPageCursor ~= nil then
                foundAnything = Site.nextPageCursor
            end
            
            for i,v in pairs(Site.data) do
                local Possible = true
                ID = tostring(v.id)
                if tonumber(v.maxPlayers) > tonumber(v.playing) then
                    for _,Existing in pairs(AllIDs) do
                        if ID == tostring(Existing) then
                            Possible = false
                        end
                    end
                    if Possible == true then
                        table.insert(AllIDs, ID)
                        pcall(function()
                            writefile("NotSameServers.json", game:GetService('HttpService'):JSONEncode(AllIDs))
                            game:GetService("TeleportService"):TeleportToPlaceInstance(PlaceID, ID, game.Players.LocalPlayer)
                        end)
                        wait(4)
                    end
                end
            end
        end
        
        function Teleport()
            while wait() do
                pcall(function()
                    TPReturner()
                    if foundAnything ~= "" then
                        TPReturner()
                    end
                end)
            end
        end
        
        Teleport()
    end
})

serverSettingsSection:AddButton({
    Title = "ServerHop (Small Server)",
    Callback = function()
        local Http = game:GetService("HttpService")
        local TPS = game:GetService("TeleportService")
        local Api = "https://games.roblox.com/v1/games/"
        
        local _place = game.PlaceId
        local _servers = Api.._place.."/servers/Public?sortOrder=Asc&limit=100"
        function ListServers(cursor)
            local Raw = game:HttpGet(_servers .. ((cursor and "&cursor="..cursor) or ""))
            return Http:JSONDecode(Raw)
        end
        
        local Server, Next;
        repeat
            local Servers = ListServers(Next)
            Server = Servers.data[1]
            Next = Servers.nextPageCursor
        until Server
        
        TPS:TeleportToPlaceInstance(_place,Server.id,game:GetService('Players').LocalPlayer)
    end
})

serverSettingsSection:AddButton({
    Title = "Reset Player",
    Callback = function()
        local character = game.Players.LocalPlayer.Character
        if character then
            local humanoid = character:FindFirstChildOfClass("Humanoid")
            if humanoid then
                humanoid.Health = 0
            end
        end
    end
})

-- Destroy Script
destroyScriptSection:AddButton({
    Title = "Destroy GUI",
    Callback = function()
        -- Use Fluent's destroy method
        Fluent:Destroy()
    end
})

-- ============================================
-- SAVE MANAGER AND INTERFACE MANAGER
-- ============================================

SaveManager:SetLibrary(Fluent)
InterfaceManager:SetLibrary(Fluent)

SaveManager:IgnoreThemeSettings()
SaveManager:SetIgnoreIndexes({})

InterfaceManager:SetFolder("FluentSAEN")
SaveManager:SetFolder("FluentSAEN/" .. game.PlaceId)

InterfaceManager:BuildInterfaceSection(Tabs.Settings)
SaveManager:BuildConfigSection(Tabs.Settings)

Window:SelectTab(1)

SaveManager:LoadAutoloadConfig()

Fluent:Notify({
    Title = gameName .. " Hub Loaded",
    Content = "Fluent Edition V. 3.5.7 Ready! All features working!",
    Duration = 5
})
